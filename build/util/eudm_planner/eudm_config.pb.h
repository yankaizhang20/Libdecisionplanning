// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eudm_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_eudm_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_eudm_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_eudm_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_eudm_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_eudm_5fconfig_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_eudm_5fconfig_2eproto_metadata_getter(int index);
namespace planning {
namespace eudm {
class ActiveLaneChangeCfg;
struct ActiveLaneChangeCfgDefaultTypeInternal;
extern ActiveLaneChangeCfgDefaultTypeInternal _ActiveLaneChangeCfg_default_instance_;
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class CostAssessCfg;
struct CostAssessCfgDefaultTypeInternal;
extern CostAssessCfgDefaultTypeInternal _CostAssessCfg_default_instance_;
class EfficiencyAssessDetail;
struct EfficiencyAssessDetailDefaultTypeInternal;
extern EfficiencyAssessDetailDefaultTypeInternal _EfficiencyAssessDetail_default_instance_;
class EvasiveSimDetail;
struct EvasiveSimDetailDefaultTypeInternal;
extern EvasiveSimDetailDefaultTypeInternal _EvasiveSimDetail_default_instance_;
class ForwardSimDetail;
struct ForwardSimDetailDefaultTypeInternal;
extern ForwardSimDetailDefaultTypeInternal _ForwardSimDetail_default_instance_;
class FunctionCfg;
struct FunctionCfgDefaultTypeInternal;
extern FunctionCfgDefaultTypeInternal _FunctionCfg_default_instance_;
class LatSimDetail;
struct LatSimDetailDefaultTypeInternal;
extern LatSimDetailDefaultTypeInternal _LatSimDetail_default_instance_;
class LatSimLimit;
struct LatSimLimitDefaultTypeInternal;
extern LatSimLimitDefaultTypeInternal _LatSimLimit_default_instance_;
class LatSimPurePursuit;
struct LatSimPurePursuitDefaultTypeInternal;
extern LatSimPurePursuitDefaultTypeInternal _LatSimPurePursuit_default_instance_;
class LonSimDetail;
struct LonSimDetailDefaultTypeInternal;
extern LonSimDetailDefaultTypeInternal _LonSimDetail_default_instance_;
class LonSimIdm;
struct LonSimIdmDefaultTypeInternal;
extern LonSimIdmDefaultTypeInternal _LonSimIdm_default_instance_;
class LonSimLimit;
struct LonSimLimitDefaultTypeInternal;
extern LonSimLimitDefaultTypeInternal _LonSimLimit_default_instance_;
class NavigationAssessDetail;
struct NavigationAssessDetailDefaultTypeInternal;
extern NavigationAssessDetailDefaultTypeInternal _NavigationAssessDetail_default_instance_;
class RssCfg;
struct RssCfgDefaultTypeInternal;
extern RssCfgDefaultTypeInternal _RssCfg_default_instance_;
class SafetyAssessDetail;
struct SafetyAssessDetailDefaultTypeInternal;
extern SafetyAssessDetailDefaultTypeInternal _SafetyAssessDetail_default_instance_;
class SafetyCfg;
struct SafetyCfgDefaultTypeInternal;
extern SafetyCfgDefaultTypeInternal _SafetyCfg_default_instance_;
class SimCfg;
struct SimCfgDefaultTypeInternal;
extern SimCfgDefaultTypeInternal _SimCfg_default_instance_;
class SimDurationDetail;
struct SimDurationDetailDefaultTypeInternal;
extern SimDurationDetailDefaultTypeInternal _SimDurationDetail_default_instance_;
class SimRefLine;
struct SimRefLineDefaultTypeInternal;
extern SimRefLineDefaultTypeInternal _SimRefLine_default_instance_;
class StrictCheckCfg;
struct StrictCheckCfgDefaultTypeInternal;
extern StrictCheckCfgDefaultTypeInternal _StrictCheckCfg_default_instance_;
class UserIntentionAssessDetail;
struct UserIntentionAssessDetailDefaultTypeInternal;
extern UserIntentionAssessDetailDefaultTypeInternal _UserIntentionAssessDetail_default_instance_;
}  // namespace eudm
}  // namespace planning
PROTOBUF_NAMESPACE_OPEN
template<> ::planning::eudm::ActiveLaneChangeCfg* Arena::CreateMaybeMessage<::planning::eudm::ActiveLaneChangeCfg>(Arena*);
template<> ::planning::eudm::Config* Arena::CreateMaybeMessage<::planning::eudm::Config>(Arena*);
template<> ::planning::eudm::CostAssessCfg* Arena::CreateMaybeMessage<::planning::eudm::CostAssessCfg>(Arena*);
template<> ::planning::eudm::EfficiencyAssessDetail* Arena::CreateMaybeMessage<::planning::eudm::EfficiencyAssessDetail>(Arena*);
template<> ::planning::eudm::EvasiveSimDetail* Arena::CreateMaybeMessage<::planning::eudm::EvasiveSimDetail>(Arena*);
template<> ::planning::eudm::ForwardSimDetail* Arena::CreateMaybeMessage<::planning::eudm::ForwardSimDetail>(Arena*);
template<> ::planning::eudm::FunctionCfg* Arena::CreateMaybeMessage<::planning::eudm::FunctionCfg>(Arena*);
template<> ::planning::eudm::LatSimDetail* Arena::CreateMaybeMessage<::planning::eudm::LatSimDetail>(Arena*);
template<> ::planning::eudm::LatSimLimit* Arena::CreateMaybeMessage<::planning::eudm::LatSimLimit>(Arena*);
template<> ::planning::eudm::LatSimPurePursuit* Arena::CreateMaybeMessage<::planning::eudm::LatSimPurePursuit>(Arena*);
template<> ::planning::eudm::LonSimDetail* Arena::CreateMaybeMessage<::planning::eudm::LonSimDetail>(Arena*);
template<> ::planning::eudm::LonSimIdm* Arena::CreateMaybeMessage<::planning::eudm::LonSimIdm>(Arena*);
template<> ::planning::eudm::LonSimLimit* Arena::CreateMaybeMessage<::planning::eudm::LonSimLimit>(Arena*);
template<> ::planning::eudm::NavigationAssessDetail* Arena::CreateMaybeMessage<::planning::eudm::NavigationAssessDetail>(Arena*);
template<> ::planning::eudm::RssCfg* Arena::CreateMaybeMessage<::planning::eudm::RssCfg>(Arena*);
template<> ::planning::eudm::SafetyAssessDetail* Arena::CreateMaybeMessage<::planning::eudm::SafetyAssessDetail>(Arena*);
template<> ::planning::eudm::SafetyCfg* Arena::CreateMaybeMessage<::planning::eudm::SafetyCfg>(Arena*);
template<> ::planning::eudm::SimCfg* Arena::CreateMaybeMessage<::planning::eudm::SimCfg>(Arena*);
template<> ::planning::eudm::SimDurationDetail* Arena::CreateMaybeMessage<::planning::eudm::SimDurationDetail>(Arena*);
template<> ::planning::eudm::SimRefLine* Arena::CreateMaybeMessage<::planning::eudm::SimRefLine>(Arena*);
template<> ::planning::eudm::StrictCheckCfg* Arena::CreateMaybeMessage<::planning::eudm::StrictCheckCfg>(Arena*);
template<> ::planning::eudm::UserIntentionAssessDetail* Arena::CreateMaybeMessage<::planning::eudm::UserIntentionAssessDetail>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace planning {
namespace eudm {

// ===================================================================

class EfficiencyAssessDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.EfficiencyAssessDetail) */ {
 public:
  inline EfficiencyAssessDetail() : EfficiencyAssessDetail(nullptr) {}
  virtual ~EfficiencyAssessDetail();
  explicit constexpr EfficiencyAssessDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EfficiencyAssessDetail(const EfficiencyAssessDetail& from);
  EfficiencyAssessDetail(EfficiencyAssessDetail&& from) noexcept
    : EfficiencyAssessDetail() {
    *this = ::std::move(from);
  }

  inline EfficiencyAssessDetail& operator=(const EfficiencyAssessDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline EfficiencyAssessDetail& operator=(EfficiencyAssessDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EfficiencyAssessDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const EfficiencyAssessDetail* internal_default_instance() {
    return reinterpret_cast<const EfficiencyAssessDetail*>(
               &_EfficiencyAssessDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EfficiencyAssessDetail& a, EfficiencyAssessDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(EfficiencyAssessDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EfficiencyAssessDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EfficiencyAssessDetail* New() const final {
    return CreateMaybeMessage<EfficiencyAssessDetail>(nullptr);
  }

  EfficiencyAssessDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EfficiencyAssessDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EfficiencyAssessDetail& from);
  void MergeFrom(const EfficiencyAssessDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EfficiencyAssessDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.EfficiencyAssessDetail";
  }
  protected:
  explicit EfficiencyAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgoLackSpeedToDesiredUnitCostFieldNumber = 1,
    kEgoOverSpeedToDesiredUnitCostFieldNumber = 2,
    kEgoDesiredSpeedTolerateGapFieldNumber = 3,
    kLeadingDistanceThFieldNumber = 4,
    kMinDistanceRatioFieldNumber = 5,
    kEgoSpeedBlockedByLeadingUnitCostFieldNumber = 6,
    kLeadingSpeedBlockedDesiredVelUnitCostFieldNumber = 7,
  };
  // required double ego_lack_speed_to_desired_unit_cost = 1;
  bool has_ego_lack_speed_to_desired_unit_cost() const;
  private:
  bool _internal_has_ego_lack_speed_to_desired_unit_cost() const;
  public:
  void clear_ego_lack_speed_to_desired_unit_cost();
  double ego_lack_speed_to_desired_unit_cost() const;
  void set_ego_lack_speed_to_desired_unit_cost(double value);
  private:
  double _internal_ego_lack_speed_to_desired_unit_cost() const;
  void _internal_set_ego_lack_speed_to_desired_unit_cost(double value);
  public:

  // required double ego_over_speed_to_desired_unit_cost = 2;
  bool has_ego_over_speed_to_desired_unit_cost() const;
  private:
  bool _internal_has_ego_over_speed_to_desired_unit_cost() const;
  public:
  void clear_ego_over_speed_to_desired_unit_cost();
  double ego_over_speed_to_desired_unit_cost() const;
  void set_ego_over_speed_to_desired_unit_cost(double value);
  private:
  double _internal_ego_over_speed_to_desired_unit_cost() const;
  void _internal_set_ego_over_speed_to_desired_unit_cost(double value);
  public:

  // required double ego_desired_speed_tolerate_gap = 3;
  bool has_ego_desired_speed_tolerate_gap() const;
  private:
  bool _internal_has_ego_desired_speed_tolerate_gap() const;
  public:
  void clear_ego_desired_speed_tolerate_gap();
  double ego_desired_speed_tolerate_gap() const;
  void set_ego_desired_speed_tolerate_gap(double value);
  private:
  double _internal_ego_desired_speed_tolerate_gap() const;
  void _internal_set_ego_desired_speed_tolerate_gap(double value);
  public:

  // required double leading_distance_th = 4;
  bool has_leading_distance_th() const;
  private:
  bool _internal_has_leading_distance_th() const;
  public:
  void clear_leading_distance_th();
  double leading_distance_th() const;
  void set_leading_distance_th(double value);
  private:
  double _internal_leading_distance_th() const;
  void _internal_set_leading_distance_th(double value);
  public:

  // required double min_distance_ratio = 5;
  bool has_min_distance_ratio() const;
  private:
  bool _internal_has_min_distance_ratio() const;
  public:
  void clear_min_distance_ratio();
  double min_distance_ratio() const;
  void set_min_distance_ratio(double value);
  private:
  double _internal_min_distance_ratio() const;
  void _internal_set_min_distance_ratio(double value);
  public:

  // required double ego_speed_blocked_by_leading_unit_cost = 6;
  bool has_ego_speed_blocked_by_leading_unit_cost() const;
  private:
  bool _internal_has_ego_speed_blocked_by_leading_unit_cost() const;
  public:
  void clear_ego_speed_blocked_by_leading_unit_cost();
  double ego_speed_blocked_by_leading_unit_cost() const;
  void set_ego_speed_blocked_by_leading_unit_cost(double value);
  private:
  double _internal_ego_speed_blocked_by_leading_unit_cost() const;
  void _internal_set_ego_speed_blocked_by_leading_unit_cost(double value);
  public:

  // required double leading_speed_blocked_desired_vel_unit_cost = 7;
  bool has_leading_speed_blocked_desired_vel_unit_cost() const;
  private:
  bool _internal_has_leading_speed_blocked_desired_vel_unit_cost() const;
  public:
  void clear_leading_speed_blocked_desired_vel_unit_cost();
  double leading_speed_blocked_desired_vel_unit_cost() const;
  void set_leading_speed_blocked_desired_vel_unit_cost(double value);
  private:
  double _internal_leading_speed_blocked_desired_vel_unit_cost() const;
  void _internal_set_leading_speed_blocked_desired_vel_unit_cost(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.EfficiencyAssessDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double ego_lack_speed_to_desired_unit_cost_;
  double ego_over_speed_to_desired_unit_cost_;
  double ego_desired_speed_tolerate_gap_;
  double leading_distance_th_;
  double min_distance_ratio_;
  double ego_speed_blocked_by_leading_unit_cost_;
  double leading_speed_blocked_desired_vel_unit_cost_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SafetyAssessDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.SafetyAssessDetail) */ {
 public:
  inline SafetyAssessDetail() : SafetyAssessDetail(nullptr) {}
  virtual ~SafetyAssessDetail();
  explicit constexpr SafetyAssessDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafetyAssessDetail(const SafetyAssessDetail& from);
  SafetyAssessDetail(SafetyAssessDetail&& from) noexcept
    : SafetyAssessDetail() {
    *this = ::std::move(from);
  }

  inline SafetyAssessDetail& operator=(const SafetyAssessDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyAssessDetail& operator=(SafetyAssessDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SafetyAssessDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafetyAssessDetail* internal_default_instance() {
    return reinterpret_cast<const SafetyAssessDetail*>(
               &_SafetyAssessDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SafetyAssessDetail& a, SafetyAssessDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(SafetyAssessDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafetyAssessDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SafetyAssessDetail* New() const final {
    return CreateMaybeMessage<SafetyAssessDetail>(nullptr);
  }

  SafetyAssessDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SafetyAssessDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SafetyAssessDetail& from);
  void MergeFrom(const SafetyAssessDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyAssessDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.SafetyAssessDetail";
  }
  protected:
  explicit SafetyAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRssOverSpeedPowerCoeffFieldNumber = 2,
    kRssOverSpeedLinearCoeffFieldNumber = 3,
    kRssLackSpeedPowerCoeffFieldNumber = 4,
    kRssLackSpeedLinearCoeffFieldNumber = 5,
    kOccuLaneUnitCostFieldNumber = 7,
    kRssCostEnableFieldNumber = 1,
    kOccuLaneEnableFieldNumber = 6,
  };
  // required double rss_over_speed_power_coeff = 2;
  bool has_rss_over_speed_power_coeff() const;
  private:
  bool _internal_has_rss_over_speed_power_coeff() const;
  public:
  void clear_rss_over_speed_power_coeff();
  double rss_over_speed_power_coeff() const;
  void set_rss_over_speed_power_coeff(double value);
  private:
  double _internal_rss_over_speed_power_coeff() const;
  void _internal_set_rss_over_speed_power_coeff(double value);
  public:

  // required double rss_over_speed_linear_coeff = 3;
  bool has_rss_over_speed_linear_coeff() const;
  private:
  bool _internal_has_rss_over_speed_linear_coeff() const;
  public:
  void clear_rss_over_speed_linear_coeff();
  double rss_over_speed_linear_coeff() const;
  void set_rss_over_speed_linear_coeff(double value);
  private:
  double _internal_rss_over_speed_linear_coeff() const;
  void _internal_set_rss_over_speed_linear_coeff(double value);
  public:

  // required double rss_lack_speed_power_coeff = 4;
  bool has_rss_lack_speed_power_coeff() const;
  private:
  bool _internal_has_rss_lack_speed_power_coeff() const;
  public:
  void clear_rss_lack_speed_power_coeff();
  double rss_lack_speed_power_coeff() const;
  void set_rss_lack_speed_power_coeff(double value);
  private:
  double _internal_rss_lack_speed_power_coeff() const;
  void _internal_set_rss_lack_speed_power_coeff(double value);
  public:

  // required double rss_lack_speed_linear_coeff = 5;
  bool has_rss_lack_speed_linear_coeff() const;
  private:
  bool _internal_has_rss_lack_speed_linear_coeff() const;
  public:
  void clear_rss_lack_speed_linear_coeff();
  double rss_lack_speed_linear_coeff() const;
  void set_rss_lack_speed_linear_coeff(double value);
  private:
  double _internal_rss_lack_speed_linear_coeff() const;
  void _internal_set_rss_lack_speed_linear_coeff(double value);
  public:

  // required double occu_lane_unit_cost = 7;
  bool has_occu_lane_unit_cost() const;
  private:
  bool _internal_has_occu_lane_unit_cost() const;
  public:
  void clear_occu_lane_unit_cost();
  double occu_lane_unit_cost() const;
  void set_occu_lane_unit_cost(double value);
  private:
  double _internal_occu_lane_unit_cost() const;
  void _internal_set_occu_lane_unit_cost(double value);
  public:

  // required bool rss_cost_enable = 1;
  bool has_rss_cost_enable() const;
  private:
  bool _internal_has_rss_cost_enable() const;
  public:
  void clear_rss_cost_enable();
  bool rss_cost_enable() const;
  void set_rss_cost_enable(bool value);
  private:
  bool _internal_rss_cost_enable() const;
  void _internal_set_rss_cost_enable(bool value);
  public:

  // required bool occu_lane_enable = 6;
  bool has_occu_lane_enable() const;
  private:
  bool _internal_has_occu_lane_enable() const;
  public:
  void clear_occu_lane_enable();
  bool occu_lane_enable() const;
  void set_occu_lane_enable(bool value);
  private:
  bool _internal_occu_lane_enable() const;
  void _internal_set_occu_lane_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.SafetyAssessDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double rss_over_speed_power_coeff_;
  double rss_over_speed_linear_coeff_;
  double rss_lack_speed_power_coeff_;
  double rss_lack_speed_linear_coeff_;
  double occu_lane_unit_cost_;
  bool rss_cost_enable_;
  bool occu_lane_enable_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class UserIntentionAssessDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.UserIntentionAssessDetail) */ {
 public:
  inline UserIntentionAssessDetail() : UserIntentionAssessDetail(nullptr) {}
  virtual ~UserIntentionAssessDetail();
  explicit constexpr UserIntentionAssessDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIntentionAssessDetail(const UserIntentionAssessDetail& from);
  UserIntentionAssessDetail(UserIntentionAssessDetail&& from) noexcept
    : UserIntentionAssessDetail() {
    *this = ::std::move(from);
  }

  inline UserIntentionAssessDetail& operator=(const UserIntentionAssessDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIntentionAssessDetail& operator=(UserIntentionAssessDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserIntentionAssessDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIntentionAssessDetail* internal_default_instance() {
    return reinterpret_cast<const UserIntentionAssessDetail*>(
               &_UserIntentionAssessDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserIntentionAssessDetail& a, UserIntentionAssessDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIntentionAssessDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIntentionAssessDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserIntentionAssessDetail* New() const final {
    return CreateMaybeMessage<UserIntentionAssessDetail>(nullptr);
  }

  UserIntentionAssessDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserIntentionAssessDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserIntentionAssessDetail& from);
  void MergeFrom(const UserIntentionAssessDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIntentionAssessDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.UserIntentionAssessDetail";
  }
  protected:
  explicit UserIntentionAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLateOperateUnitCostFieldNumber = 1,
    kCancelOperationUnitCostFieldNumber = 2,
  };
  // required double late_operate_unit_cost = 1;
  bool has_late_operate_unit_cost() const;
  private:
  bool _internal_has_late_operate_unit_cost() const;
  public:
  void clear_late_operate_unit_cost();
  double late_operate_unit_cost() const;
  void set_late_operate_unit_cost(double value);
  private:
  double _internal_late_operate_unit_cost() const;
  void _internal_set_late_operate_unit_cost(double value);
  public:

  // required double cancel_operation_unit_cost = 2;
  bool has_cancel_operation_unit_cost() const;
  private:
  bool _internal_has_cancel_operation_unit_cost() const;
  public:
  void clear_cancel_operation_unit_cost();
  double cancel_operation_unit_cost() const;
  void set_cancel_operation_unit_cost(double value);
  private:
  double _internal_cancel_operation_unit_cost() const;
  void _internal_set_cancel_operation_unit_cost(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.UserIntentionAssessDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double late_operate_unit_cost_;
  double cancel_operation_unit_cost_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class NavigationAssessDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.NavigationAssessDetail) */ {
 public:
  inline NavigationAssessDetail() : NavigationAssessDetail(nullptr) {}
  virtual ~NavigationAssessDetail();
  explicit constexpr NavigationAssessDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationAssessDetail(const NavigationAssessDetail& from);
  NavigationAssessDetail(NavigationAssessDetail&& from) noexcept
    : NavigationAssessDetail() {
    *this = ::std::move(from);
  }

  inline NavigationAssessDetail& operator=(const NavigationAssessDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationAssessDetail& operator=(NavigationAssessDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationAssessDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationAssessDetail* internal_default_instance() {
    return reinterpret_cast<const NavigationAssessDetail*>(
               &_NavigationAssessDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NavigationAssessDetail& a, NavigationAssessDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationAssessDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationAssessDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationAssessDetail* New() const final {
    return CreateMaybeMessage<NavigationAssessDetail>(nullptr);
  }

  NavigationAssessDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationAssessDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationAssessDetail& from);
  void MergeFrom(const NavigationAssessDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationAssessDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.NavigationAssessDetail";
  }
  protected:
  explicit NavigationAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneChangeLeftUnitCostFieldNumber = 1,
    kLaneChangeRightUnitCostFieldNumber = 2,
    kLaneChangeUnitCostVelLbFieldNumber = 3,
    kLaneChangeLeftRecommendationRewardFieldNumber = 4,
    kLaneChangeRightRecommendationRewardFieldNumber = 5,
  };
  // required double lane_change_left_unit_cost = 1;
  bool has_lane_change_left_unit_cost() const;
  private:
  bool _internal_has_lane_change_left_unit_cost() const;
  public:
  void clear_lane_change_left_unit_cost();
  double lane_change_left_unit_cost() const;
  void set_lane_change_left_unit_cost(double value);
  private:
  double _internal_lane_change_left_unit_cost() const;
  void _internal_set_lane_change_left_unit_cost(double value);
  public:

  // required double lane_change_right_unit_cost = 2;
  bool has_lane_change_right_unit_cost() const;
  private:
  bool _internal_has_lane_change_right_unit_cost() const;
  public:
  void clear_lane_change_right_unit_cost();
  double lane_change_right_unit_cost() const;
  void set_lane_change_right_unit_cost(double value);
  private:
  double _internal_lane_change_right_unit_cost() const;
  void _internal_set_lane_change_right_unit_cost(double value);
  public:

  // required double lane_change_unit_cost_vel_lb = 3;
  bool has_lane_change_unit_cost_vel_lb() const;
  private:
  bool _internal_has_lane_change_unit_cost_vel_lb() const;
  public:
  void clear_lane_change_unit_cost_vel_lb();
  double lane_change_unit_cost_vel_lb() const;
  void set_lane_change_unit_cost_vel_lb(double value);
  private:
  double _internal_lane_change_unit_cost_vel_lb() const;
  void _internal_set_lane_change_unit_cost_vel_lb(double value);
  public:

  // required double lane_change_left_recommendation_reward = 4;
  bool has_lane_change_left_recommendation_reward() const;
  private:
  bool _internal_has_lane_change_left_recommendation_reward() const;
  public:
  void clear_lane_change_left_recommendation_reward();
  double lane_change_left_recommendation_reward() const;
  void set_lane_change_left_recommendation_reward(double value);
  private:
  double _internal_lane_change_left_recommendation_reward() const;
  void _internal_set_lane_change_left_recommendation_reward(double value);
  public:

  // required double lane_change_right_recommendation_reward = 5;
  bool has_lane_change_right_recommendation_reward() const;
  private:
  bool _internal_has_lane_change_right_recommendation_reward() const;
  public:
  void clear_lane_change_right_recommendation_reward();
  double lane_change_right_recommendation_reward() const;
  void set_lane_change_right_recommendation_reward(double value);
  private:
  double _internal_lane_change_right_recommendation_reward() const;
  void _internal_set_lane_change_right_recommendation_reward(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.NavigationAssessDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double lane_change_left_unit_cost_;
  double lane_change_right_unit_cost_;
  double lane_change_unit_cost_vel_lb_;
  double lane_change_left_recommendation_reward_;
  double lane_change_right_recommendation_reward_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CostAssessCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.CostAssessCfg) */ {
 public:
  inline CostAssessCfg() : CostAssessCfg(nullptr) {}
  virtual ~CostAssessCfg();
  explicit constexpr CostAssessCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CostAssessCfg(const CostAssessCfg& from);
  CostAssessCfg(CostAssessCfg&& from) noexcept
    : CostAssessCfg() {
    *this = ::std::move(from);
  }

  inline CostAssessCfg& operator=(const CostAssessCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostAssessCfg& operator=(CostAssessCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CostAssessCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostAssessCfg* internal_default_instance() {
    return reinterpret_cast<const CostAssessCfg*>(
               &_CostAssessCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CostAssessCfg& a, CostAssessCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(CostAssessCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostAssessCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CostAssessCfg* New() const final {
    return CreateMaybeMessage<CostAssessCfg>(nullptr);
  }

  CostAssessCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CostAssessCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CostAssessCfg& from);
  void MergeFrom(const CostAssessCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CostAssessCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.CostAssessCfg";
  }
  protected:
  explicit CostAssessCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffciencyFieldNumber = 1,
    kSafetyFieldNumber = 2,
    kUserFieldNumber = 3,
    kNavigationFieldNumber = 4,
    kDiscountFactorFieldNumber = 5,
  };
  // required .planning.eudm.EfficiencyAssessDetail effciency = 1;
  bool has_effciency() const;
  private:
  bool _internal_has_effciency() const;
  public:
  void clear_effciency();
  const ::planning::eudm::EfficiencyAssessDetail& effciency() const;
  ::planning::eudm::EfficiencyAssessDetail* release_effciency();
  ::planning::eudm::EfficiencyAssessDetail* mutable_effciency();
  void set_allocated_effciency(::planning::eudm::EfficiencyAssessDetail* effciency);
  private:
  const ::planning::eudm::EfficiencyAssessDetail& _internal_effciency() const;
  ::planning::eudm::EfficiencyAssessDetail* _internal_mutable_effciency();
  public:
  void unsafe_arena_set_allocated_effciency(
      ::planning::eudm::EfficiencyAssessDetail* effciency);
  ::planning::eudm::EfficiencyAssessDetail* unsafe_arena_release_effciency();

  // required .planning.eudm.SafetyAssessDetail safety = 2;
  bool has_safety() const;
  private:
  bool _internal_has_safety() const;
  public:
  void clear_safety();
  const ::planning::eudm::SafetyAssessDetail& safety() const;
  ::planning::eudm::SafetyAssessDetail* release_safety();
  ::planning::eudm::SafetyAssessDetail* mutable_safety();
  void set_allocated_safety(::planning::eudm::SafetyAssessDetail* safety);
  private:
  const ::planning::eudm::SafetyAssessDetail& _internal_safety() const;
  ::planning::eudm::SafetyAssessDetail* _internal_mutable_safety();
  public:
  void unsafe_arena_set_allocated_safety(
      ::planning::eudm::SafetyAssessDetail* safety);
  ::planning::eudm::SafetyAssessDetail* unsafe_arena_release_safety();

  // required .planning.eudm.UserIntentionAssessDetail user = 3;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::planning::eudm::UserIntentionAssessDetail& user() const;
  ::planning::eudm::UserIntentionAssessDetail* release_user();
  ::planning::eudm::UserIntentionAssessDetail* mutable_user();
  void set_allocated_user(::planning::eudm::UserIntentionAssessDetail* user);
  private:
  const ::planning::eudm::UserIntentionAssessDetail& _internal_user() const;
  ::planning::eudm::UserIntentionAssessDetail* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::planning::eudm::UserIntentionAssessDetail* user);
  ::planning::eudm::UserIntentionAssessDetail* unsafe_arena_release_user();

  // required .planning.eudm.NavigationAssessDetail navigation = 4;
  bool has_navigation() const;
  private:
  bool _internal_has_navigation() const;
  public:
  void clear_navigation();
  const ::planning::eudm::NavigationAssessDetail& navigation() const;
  ::planning::eudm::NavigationAssessDetail* release_navigation();
  ::planning::eudm::NavigationAssessDetail* mutable_navigation();
  void set_allocated_navigation(::planning::eudm::NavigationAssessDetail* navigation);
  private:
  const ::planning::eudm::NavigationAssessDetail& _internal_navigation() const;
  ::planning::eudm::NavigationAssessDetail* _internal_mutable_navigation();
  public:
  void unsafe_arena_set_allocated_navigation(
      ::planning::eudm::NavigationAssessDetail* navigation);
  ::planning::eudm::NavigationAssessDetail* unsafe_arena_release_navigation();

  // required double discount_factor = 5;
  bool has_discount_factor() const;
  private:
  bool _internal_has_discount_factor() const;
  public:
  void clear_discount_factor();
  double discount_factor() const;
  void set_discount_factor(double value);
  private:
  double _internal_discount_factor() const;
  void _internal_set_discount_factor(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.CostAssessCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::EfficiencyAssessDetail* effciency_;
  ::planning::eudm::SafetyAssessDetail* safety_;
  ::planning::eudm::UserIntentionAssessDetail* user_;
  ::planning::eudm::NavigationAssessDetail* navigation_;
  double discount_factor_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SimDurationDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.SimDurationDetail) */ {
 public:
  inline SimDurationDetail() : SimDurationDetail(nullptr) {}
  virtual ~SimDurationDetail();
  explicit constexpr SimDurationDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimDurationDetail(const SimDurationDetail& from);
  SimDurationDetail(SimDurationDetail&& from) noexcept
    : SimDurationDetail() {
    *this = ::std::move(from);
  }

  inline SimDurationDetail& operator=(const SimDurationDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimDurationDetail& operator=(SimDurationDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimDurationDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimDurationDetail* internal_default_instance() {
    return reinterpret_cast<const SimDurationDetail*>(
               &_SimDurationDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SimDurationDetail& a, SimDurationDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(SimDurationDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimDurationDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimDurationDetail* New() const final {
    return CreateMaybeMessage<SimDurationDetail>(nullptr);
  }

  SimDurationDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimDurationDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimDurationDetail& from);
  void MergeFrom(const SimDurationDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimDurationDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.SimDurationDetail";
  }
  protected:
  explicit SimDurationDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kLastLayerFieldNumber = 2,
    kStepFieldNumber = 3,
    kTreeHeightFieldNumber = 4,
  };
  // required double layer = 1;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  double layer() const;
  void set_layer(double value);
  private:
  double _internal_layer() const;
  void _internal_set_layer(double value);
  public:

  // required double last_layer = 2;
  bool has_last_layer() const;
  private:
  bool _internal_has_last_layer() const;
  public:
  void clear_last_layer();
  double last_layer() const;
  void set_last_layer(double value);
  private:
  double _internal_last_layer() const;
  void _internal_set_last_layer(double value);
  public:

  // required double step = 3;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  double step() const;
  void set_step(double value);
  private:
  double _internal_step() const;
  void _internal_set_step(double value);
  public:

  // required int32 tree_height = 4;
  bool has_tree_height() const;
  private:
  bool _internal_has_tree_height() const;
  public:
  void clear_tree_height();
  ::PROTOBUF_NAMESPACE_ID::int32 tree_height() const;
  void set_tree_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tree_height() const;
  void _internal_set_tree_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.SimDurationDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double layer_;
  double last_layer_;
  double step_;
  ::PROTOBUF_NAMESPACE_ID::int32 tree_height_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LonSimLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LonSimLimit) */ {
 public:
  inline LonSimLimit() : LonSimLimit(nullptr) {}
  virtual ~LonSimLimit();
  explicit constexpr LonSimLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LonSimLimit(const LonSimLimit& from);
  LonSimLimit(LonSimLimit&& from) noexcept
    : LonSimLimit() {
    *this = ::std::move(from);
  }

  inline LonSimLimit& operator=(const LonSimLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LonSimLimit& operator=(LonSimLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LonSimLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const LonSimLimit* internal_default_instance() {
    return reinterpret_cast<const LonSimLimit*>(
               &_LonSimLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LonSimLimit& a, LonSimLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(LonSimLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LonSimLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LonSimLimit* New() const final {
    return CreateMaybeMessage<LonSimLimit>(nullptr);
  }

  LonSimLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LonSimLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LonSimLimit& from);
  void MergeFrom(const LonSimLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LonSimLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LonSimLimit";
  }
  protected:
  explicit LonSimLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccFieldNumber = 1,
    kAccJerkFieldNumber = 2,
    kSoftBrakeFieldNumber = 3,
    kHardBrakeFieldNumber = 4,
    kBrakeJerkFieldNumber = 5,
  };
  // required double acc = 1;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  double acc() const;
  void set_acc(double value);
  private:
  double _internal_acc() const;
  void _internal_set_acc(double value);
  public:

  // required double acc_jerk = 2;
  bool has_acc_jerk() const;
  private:
  bool _internal_has_acc_jerk() const;
  public:
  void clear_acc_jerk();
  double acc_jerk() const;
  void set_acc_jerk(double value);
  private:
  double _internal_acc_jerk() const;
  void _internal_set_acc_jerk(double value);
  public:

  // required double soft_brake = 3;
  bool has_soft_brake() const;
  private:
  bool _internal_has_soft_brake() const;
  public:
  void clear_soft_brake();
  double soft_brake() const;
  void set_soft_brake(double value);
  private:
  double _internal_soft_brake() const;
  void _internal_set_soft_brake(double value);
  public:

  // required double hard_brake = 4;
  bool has_hard_brake() const;
  private:
  bool _internal_has_hard_brake() const;
  public:
  void clear_hard_brake();
  double hard_brake() const;
  void set_hard_brake(double value);
  private:
  double _internal_hard_brake() const;
  void _internal_set_hard_brake(double value);
  public:

  // required double brake_jerk = 5;
  bool has_brake_jerk() const;
  private:
  bool _internal_has_brake_jerk() const;
  public:
  void clear_brake_jerk();
  double brake_jerk() const;
  void set_brake_jerk(double value);
  private:
  double _internal_brake_jerk() const;
  void _internal_set_brake_jerk(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.LonSimLimit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double acc_;
  double acc_jerk_;
  double soft_brake_;
  double hard_brake_;
  double brake_jerk_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LonSimIdm PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LonSimIdm) */ {
 public:
  inline LonSimIdm() : LonSimIdm(nullptr) {}
  virtual ~LonSimIdm();
  explicit constexpr LonSimIdm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LonSimIdm(const LonSimIdm& from);
  LonSimIdm(LonSimIdm&& from) noexcept
    : LonSimIdm() {
    *this = ::std::move(from);
  }

  inline LonSimIdm& operator=(const LonSimIdm& from) {
    CopyFrom(from);
    return *this;
  }
  inline LonSimIdm& operator=(LonSimIdm&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LonSimIdm& default_instance() {
    return *internal_default_instance();
  }
  static inline const LonSimIdm* internal_default_instance() {
    return reinterpret_cast<const LonSimIdm*>(
               &_LonSimIdm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LonSimIdm& a, LonSimIdm& b) {
    a.Swap(&b);
  }
  inline void Swap(LonSimIdm* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LonSimIdm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LonSimIdm* New() const final {
    return CreateMaybeMessage<LonSimIdm>(nullptr);
  }

  LonSimIdm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LonSimIdm>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LonSimIdm& from);
  void MergeFrom(const LonSimIdm& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LonSimIdm* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LonSimIdm";
  }
  protected:
  explicit LonSimIdm(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinSpacingFieldNumber = 1,
    kHeadTimeFieldNumber = 2,
    kExponentFieldNumber = 3,
  };
  // required double min_spacing = 1;
  bool has_min_spacing() const;
  private:
  bool _internal_has_min_spacing() const;
  public:
  void clear_min_spacing();
  double min_spacing() const;
  void set_min_spacing(double value);
  private:
  double _internal_min_spacing() const;
  void _internal_set_min_spacing(double value);
  public:

  // required double head_time = 2;
  bool has_head_time() const;
  private:
  bool _internal_has_head_time() const;
  public:
  void clear_head_time();
  double head_time() const;
  void set_head_time(double value);
  private:
  double _internal_head_time() const;
  void _internal_set_head_time(double value);
  public:

  // required int32 exponent = 3;
  bool has_exponent() const;
  private:
  bool _internal_has_exponent() const;
  public:
  void clear_exponent();
  ::PROTOBUF_NAMESPACE_ID::int32 exponent() const;
  void set_exponent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_exponent() const;
  void _internal_set_exponent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.LonSimIdm)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double min_spacing_;
  double head_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 exponent_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LonSimDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LonSimDetail) */ {
 public:
  inline LonSimDetail() : LonSimDetail(nullptr) {}
  virtual ~LonSimDetail();
  explicit constexpr LonSimDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LonSimDetail(const LonSimDetail& from);
  LonSimDetail(LonSimDetail&& from) noexcept
    : LonSimDetail() {
    *this = ::std::move(from);
  }

  inline LonSimDetail& operator=(const LonSimDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline LonSimDetail& operator=(LonSimDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LonSimDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const LonSimDetail* internal_default_instance() {
    return reinterpret_cast<const LonSimDetail*>(
               &_LonSimDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LonSimDetail& a, LonSimDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(LonSimDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LonSimDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LonSimDetail* New() const final {
    return CreateMaybeMessage<LonSimDetail>(nullptr);
  }

  LonSimDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LonSimDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LonSimDetail& from);
  void MergeFrom(const LonSimDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LonSimDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LonSimDetail";
  }
  protected:
  explicit LonSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdmFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // required .planning.eudm.LonSimIdm idm = 1;
  bool has_idm() const;
  private:
  bool _internal_has_idm() const;
  public:
  void clear_idm();
  const ::planning::eudm::LonSimIdm& idm() const;
  ::planning::eudm::LonSimIdm* release_idm();
  ::planning::eudm::LonSimIdm* mutable_idm();
  void set_allocated_idm(::planning::eudm::LonSimIdm* idm);
  private:
  const ::planning::eudm::LonSimIdm& _internal_idm() const;
  ::planning::eudm::LonSimIdm* _internal_mutable_idm();
  public:
  void unsafe_arena_set_allocated_idm(
      ::planning::eudm::LonSimIdm* idm);
  ::planning::eudm::LonSimIdm* unsafe_arena_release_idm();

  // required .planning.eudm.LonSimLimit limit = 2;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const ::planning::eudm::LonSimLimit& limit() const;
  ::planning::eudm::LonSimLimit* release_limit();
  ::planning::eudm::LonSimLimit* mutable_limit();
  void set_allocated_limit(::planning::eudm::LonSimLimit* limit);
  private:
  const ::planning::eudm::LonSimLimit& _internal_limit() const;
  ::planning::eudm::LonSimLimit* _internal_mutable_limit();
  public:
  void unsafe_arena_set_allocated_limit(
      ::planning::eudm::LonSimLimit* limit);
  ::planning::eudm::LonSimLimit* unsafe_arena_release_limit();

  // @@protoc_insertion_point(class_scope:planning.eudm.LonSimDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::LonSimIdm* idm_;
  ::planning::eudm::LonSimLimit* limit_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LatSimLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LatSimLimit) */ {
 public:
  inline LatSimLimit() : LatSimLimit(nullptr) {}
  virtual ~LatSimLimit();
  explicit constexpr LatSimLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LatSimLimit(const LatSimLimit& from);
  LatSimLimit(LatSimLimit&& from) noexcept
    : LatSimLimit() {
    *this = ::std::move(from);
  }

  inline LatSimLimit& operator=(const LatSimLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatSimLimit& operator=(LatSimLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatSimLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatSimLimit* internal_default_instance() {
    return reinterpret_cast<const LatSimLimit*>(
               &_LatSimLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LatSimLimit& a, LatSimLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(LatSimLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatSimLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatSimLimit* New() const final {
    return CreateMaybeMessage<LatSimLimit>(nullptr);
  }

  LatSimLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatSimLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatSimLimit& from);
  void MergeFrom(const LatSimLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatSimLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LatSimLimit";
  }
  protected:
  explicit LatSimLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccFieldNumber = 1,
    kJerkFieldNumber = 2,
    kCurvatureFieldNumber = 3,
    kSteerAngleFieldNumber = 4,
    kSteerRateFieldNumber = 5,
  };
  // required double acc = 1;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  double acc() const;
  void set_acc(double value);
  private:
  double _internal_acc() const;
  void _internal_set_acc(double value);
  public:

  // required double jerk = 2;
  bool has_jerk() const;
  private:
  bool _internal_has_jerk() const;
  public:
  void clear_jerk();
  double jerk() const;
  void set_jerk(double value);
  private:
  double _internal_jerk() const;
  void _internal_set_jerk(double value);
  public:

  // required double curvature = 3;
  bool has_curvature() const;
  private:
  bool _internal_has_curvature() const;
  public:
  void clear_curvature();
  double curvature() const;
  void set_curvature(double value);
  private:
  double _internal_curvature() const;
  void _internal_set_curvature(double value);
  public:

  // required double steer_angle = 4;
  bool has_steer_angle() const;
  private:
  bool _internal_has_steer_angle() const;
  public:
  void clear_steer_angle();
  double steer_angle() const;
  void set_steer_angle(double value);
  private:
  double _internal_steer_angle() const;
  void _internal_set_steer_angle(double value);
  public:

  // required double steer_rate = 5;
  bool has_steer_rate() const;
  private:
  bool _internal_has_steer_rate() const;
  public:
  void clear_steer_rate();
  double steer_rate() const;
  void set_steer_rate(double value);
  private:
  double _internal_steer_rate() const;
  void _internal_set_steer_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.LatSimLimit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double acc_;
  double jerk_;
  double curvature_;
  double steer_angle_;
  double steer_rate_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LatSimPurePursuit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LatSimPurePursuit) */ {
 public:
  inline LatSimPurePursuit() : LatSimPurePursuit(nullptr) {}
  virtual ~LatSimPurePursuit();
  explicit constexpr LatSimPurePursuit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LatSimPurePursuit(const LatSimPurePursuit& from);
  LatSimPurePursuit(LatSimPurePursuit&& from) noexcept
    : LatSimPurePursuit() {
    *this = ::std::move(from);
  }

  inline LatSimPurePursuit& operator=(const LatSimPurePursuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatSimPurePursuit& operator=(LatSimPurePursuit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatSimPurePursuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatSimPurePursuit* internal_default_instance() {
    return reinterpret_cast<const LatSimPurePursuit*>(
               &_LatSimPurePursuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LatSimPurePursuit& a, LatSimPurePursuit& b) {
    a.Swap(&b);
  }
  inline void Swap(LatSimPurePursuit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatSimPurePursuit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatSimPurePursuit* New() const final {
    return CreateMaybeMessage<LatSimPurePursuit>(nullptr);
  }

  LatSimPurePursuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatSimPurePursuit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatSimPurePursuit& from);
  void MergeFrom(const LatSimPurePursuit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatSimPurePursuit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LatSimPurePursuit";
  }
  protected:
  explicit LatSimPurePursuit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGainFieldNumber = 1,
    kMaxLookaheadDistFieldNumber = 2,
    kMinLookaheadDistFieldNumber = 3,
  };
  // required double gain = 1;
  bool has_gain() const;
  private:
  bool _internal_has_gain() const;
  public:
  void clear_gain();
  double gain() const;
  void set_gain(double value);
  private:
  double _internal_gain() const;
  void _internal_set_gain(double value);
  public:

  // required double max_lookahead_dist = 2;
  bool has_max_lookahead_dist() const;
  private:
  bool _internal_has_max_lookahead_dist() const;
  public:
  void clear_max_lookahead_dist();
  double max_lookahead_dist() const;
  void set_max_lookahead_dist(double value);
  private:
  double _internal_max_lookahead_dist() const;
  void _internal_set_max_lookahead_dist(double value);
  public:

  // required double min_lookahead_dist = 3;
  bool has_min_lookahead_dist() const;
  private:
  bool _internal_has_min_lookahead_dist() const;
  public:
  void clear_min_lookahead_dist();
  double min_lookahead_dist() const;
  void set_min_lookahead_dist(double value);
  private:
  double _internal_min_lookahead_dist() const;
  void _internal_set_min_lookahead_dist(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.LatSimPurePursuit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double gain_;
  double max_lookahead_dist_;
  double min_lookahead_dist_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LatSimDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.LatSimDetail) */ {
 public:
  inline LatSimDetail() : LatSimDetail(nullptr) {}
  virtual ~LatSimDetail();
  explicit constexpr LatSimDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LatSimDetail(const LatSimDetail& from);
  LatSimDetail(LatSimDetail&& from) noexcept
    : LatSimDetail() {
    *this = ::std::move(from);
  }

  inline LatSimDetail& operator=(const LatSimDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatSimDetail& operator=(LatSimDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LatSimDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatSimDetail* internal_default_instance() {
    return reinterpret_cast<const LatSimDetail*>(
               &_LatSimDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LatSimDetail& a, LatSimDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(LatSimDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatSimDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LatSimDetail* New() const final {
    return CreateMaybeMessage<LatSimDetail>(nullptr);
  }

  LatSimDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LatSimDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LatSimDetail& from);
  void MergeFrom(const LatSimDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LatSimDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.LatSimDetail";
  }
  protected:
  explicit LatSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPurePursuitFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
  bool has_pure_pursuit() const;
  private:
  bool _internal_has_pure_pursuit() const;
  public:
  void clear_pure_pursuit();
  const ::planning::eudm::LatSimPurePursuit& pure_pursuit() const;
  ::planning::eudm::LatSimPurePursuit* release_pure_pursuit();
  ::planning::eudm::LatSimPurePursuit* mutable_pure_pursuit();
  void set_allocated_pure_pursuit(::planning::eudm::LatSimPurePursuit* pure_pursuit);
  private:
  const ::planning::eudm::LatSimPurePursuit& _internal_pure_pursuit() const;
  ::planning::eudm::LatSimPurePursuit* _internal_mutable_pure_pursuit();
  public:
  void unsafe_arena_set_allocated_pure_pursuit(
      ::planning::eudm::LatSimPurePursuit* pure_pursuit);
  ::planning::eudm::LatSimPurePursuit* unsafe_arena_release_pure_pursuit();

  // required .planning.eudm.LatSimLimit limit = 2;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const ::planning::eudm::LatSimLimit& limit() const;
  ::planning::eudm::LatSimLimit* release_limit();
  ::planning::eudm::LatSimLimit* mutable_limit();
  void set_allocated_limit(::planning::eudm::LatSimLimit* limit);
  private:
  const ::planning::eudm::LatSimLimit& _internal_limit() const;
  ::planning::eudm::LatSimLimit* _internal_mutable_limit();
  public:
  void unsafe_arena_set_allocated_limit(
      ::planning::eudm::LatSimLimit* limit);
  ::planning::eudm::LatSimLimit* unsafe_arena_release_limit();

  // @@protoc_insertion_point(class_scope:planning.eudm.LatSimDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::LatSimPurePursuit* pure_pursuit_;
  ::planning::eudm::LatSimLimit* limit_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class EvasiveSimDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.EvasiveSimDetail) */ {
 public:
  inline EvasiveSimDetail() : EvasiveSimDetail(nullptr) {}
  virtual ~EvasiveSimDetail();
  explicit constexpr EvasiveSimDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvasiveSimDetail(const EvasiveSimDetail& from);
  EvasiveSimDetail(EvasiveSimDetail&& from) noexcept
    : EvasiveSimDetail() {
    *this = ::std::move(from);
  }

  inline EvasiveSimDetail& operator=(const EvasiveSimDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvasiveSimDetail& operator=(EvasiveSimDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EvasiveSimDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvasiveSimDetail* internal_default_instance() {
    return reinterpret_cast<const EvasiveSimDetail*>(
               &_EvasiveSimDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EvasiveSimDetail& a, EvasiveSimDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(EvasiveSimDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvasiveSimDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EvasiveSimDetail* New() const final {
    return CreateMaybeMessage<EvasiveSimDetail>(nullptr);
  }

  EvasiveSimDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EvasiveSimDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EvasiveSimDetail& from);
  void MergeFrom(const EvasiveSimDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvasiveSimDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.EvasiveSimDetail";
  }
  protected:
  explicit EvasiveSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLonAccFieldNumber = 2,
    kLonJerkFieldNumber = 3,
    kLonExtraspeedFieldNumber = 4,
    kHeadTimeFieldNumber = 5,
    kVirtualBarrierTicFieldNumber = 7,
    kEvasiveEnableFieldNumber = 1,
    kVirtualBarrierEnableFieldNumber = 6,
  };
  // required double lon_acc = 2;
  bool has_lon_acc() const;
  private:
  bool _internal_has_lon_acc() const;
  public:
  void clear_lon_acc();
  double lon_acc() const;
  void set_lon_acc(double value);
  private:
  double _internal_lon_acc() const;
  void _internal_set_lon_acc(double value);
  public:

  // required double lon_jerk = 3;
  bool has_lon_jerk() const;
  private:
  bool _internal_has_lon_jerk() const;
  public:
  void clear_lon_jerk();
  double lon_jerk() const;
  void set_lon_jerk(double value);
  private:
  double _internal_lon_jerk() const;
  void _internal_set_lon_jerk(double value);
  public:

  // required double lon_extraspeed = 4;
  bool has_lon_extraspeed() const;
  private:
  bool _internal_has_lon_extraspeed() const;
  public:
  void clear_lon_extraspeed();
  double lon_extraspeed() const;
  void set_lon_extraspeed(double value);
  private:
  double _internal_lon_extraspeed() const;
  void _internal_set_lon_extraspeed(double value);
  public:

  // required double head_time = 5;
  bool has_head_time() const;
  private:
  bool _internal_has_head_time() const;
  public:
  void clear_head_time();
  double head_time() const;
  void set_head_time(double value);
  private:
  double _internal_head_time() const;
  void _internal_set_head_time(double value);
  public:

  // required double virtual_barrier_tic = 7;
  bool has_virtual_barrier_tic() const;
  private:
  bool _internal_has_virtual_barrier_tic() const;
  public:
  void clear_virtual_barrier_tic();
  double virtual_barrier_tic() const;
  void set_virtual_barrier_tic(double value);
  private:
  double _internal_virtual_barrier_tic() const;
  void _internal_set_virtual_barrier_tic(double value);
  public:

  // required bool evasive_enable = 1;
  bool has_evasive_enable() const;
  private:
  bool _internal_has_evasive_enable() const;
  public:
  void clear_evasive_enable();
  bool evasive_enable() const;
  void set_evasive_enable(bool value);
  private:
  bool _internal_evasive_enable() const;
  void _internal_set_evasive_enable(bool value);
  public:

  // required bool virtual_barrier_enable = 6;
  bool has_virtual_barrier_enable() const;
  private:
  bool _internal_has_virtual_barrier_enable() const;
  public:
  void clear_virtual_barrier_enable();
  bool virtual_barrier_enable() const;
  void set_virtual_barrier_enable(bool value);
  private:
  bool _internal_virtual_barrier_enable() const;
  void _internal_set_virtual_barrier_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.EvasiveSimDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double lon_acc_;
  double lon_jerk_;
  double lon_extraspeed_;
  double head_time_;
  double virtual_barrier_tic_;
  bool evasive_enable_;
  bool virtual_barrier_enable_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ForwardSimDetail PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.ForwardSimDetail) */ {
 public:
  inline ForwardSimDetail() : ForwardSimDetail(nullptr) {}
  virtual ~ForwardSimDetail();
  explicit constexpr ForwardSimDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardSimDetail(const ForwardSimDetail& from);
  ForwardSimDetail(ForwardSimDetail&& from) noexcept
    : ForwardSimDetail() {
    *this = ::std::move(from);
  }

  inline ForwardSimDetail& operator=(const ForwardSimDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardSimDetail& operator=(ForwardSimDetail&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ForwardSimDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardSimDetail* internal_default_instance() {
    return reinterpret_cast<const ForwardSimDetail*>(
               &_ForwardSimDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ForwardSimDetail& a, ForwardSimDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardSimDetail* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardSimDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ForwardSimDetail* New() const final {
    return CreateMaybeMessage<ForwardSimDetail>(nullptr);
  }

  ForwardSimDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ForwardSimDetail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ForwardSimDetail& from);
  void MergeFrom(const ForwardSimDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardSimDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.ForwardSimDetail";
  }
  protected:
  explicit ForwardSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLonFieldNumber = 1,
    kLatFieldNumber = 2,
    kEvasiveFieldNumber = 3,
    kCooperativeLatRangeFieldNumber = 5,
    kLonAggressiveRatioFieldNumber = 6,
    kAutoDecIfLatFailedFieldNumber = 4,
  };
  // required .planning.eudm.LonSimDetail lon = 1;
  bool has_lon() const;
  private:
  bool _internal_has_lon() const;
  public:
  void clear_lon();
  const ::planning::eudm::LonSimDetail& lon() const;
  ::planning::eudm::LonSimDetail* release_lon();
  ::planning::eudm::LonSimDetail* mutable_lon();
  void set_allocated_lon(::planning::eudm::LonSimDetail* lon);
  private:
  const ::planning::eudm::LonSimDetail& _internal_lon() const;
  ::planning::eudm::LonSimDetail* _internal_mutable_lon();
  public:
  void unsafe_arena_set_allocated_lon(
      ::planning::eudm::LonSimDetail* lon);
  ::planning::eudm::LonSimDetail* unsafe_arena_release_lon();

  // required .planning.eudm.LatSimDetail lat = 2;
  bool has_lat() const;
  private:
  bool _internal_has_lat() const;
  public:
  void clear_lat();
  const ::planning::eudm::LatSimDetail& lat() const;
  ::planning::eudm::LatSimDetail* release_lat();
  ::planning::eudm::LatSimDetail* mutable_lat();
  void set_allocated_lat(::planning::eudm::LatSimDetail* lat);
  private:
  const ::planning::eudm::LatSimDetail& _internal_lat() const;
  ::planning::eudm::LatSimDetail* _internal_mutable_lat();
  public:
  void unsafe_arena_set_allocated_lat(
      ::planning::eudm::LatSimDetail* lat);
  ::planning::eudm::LatSimDetail* unsafe_arena_release_lat();

  // required .planning.eudm.EvasiveSimDetail evasive = 3;
  bool has_evasive() const;
  private:
  bool _internal_has_evasive() const;
  public:
  void clear_evasive();
  const ::planning::eudm::EvasiveSimDetail& evasive() const;
  ::planning::eudm::EvasiveSimDetail* release_evasive();
  ::planning::eudm::EvasiveSimDetail* mutable_evasive();
  void set_allocated_evasive(::planning::eudm::EvasiveSimDetail* evasive);
  private:
  const ::planning::eudm::EvasiveSimDetail& _internal_evasive() const;
  ::planning::eudm::EvasiveSimDetail* _internal_mutable_evasive();
  public:
  void unsafe_arena_set_allocated_evasive(
      ::planning::eudm::EvasiveSimDetail* evasive);
  ::planning::eudm::EvasiveSimDetail* unsafe_arena_release_evasive();

  // required double cooperative_lat_range = 5;
  bool has_cooperative_lat_range() const;
  private:
  bool _internal_has_cooperative_lat_range() const;
  public:
  void clear_cooperative_lat_range();
  double cooperative_lat_range() const;
  void set_cooperative_lat_range(double value);
  private:
  double _internal_cooperative_lat_range() const;
  void _internal_set_cooperative_lat_range(double value);
  public:

  // required double lon_aggressive_ratio = 6;
  bool has_lon_aggressive_ratio() const;
  private:
  bool _internal_has_lon_aggressive_ratio() const;
  public:
  void clear_lon_aggressive_ratio();
  double lon_aggressive_ratio() const;
  void set_lon_aggressive_ratio(double value);
  private:
  double _internal_lon_aggressive_ratio() const;
  void _internal_set_lon_aggressive_ratio(double value);
  public:

  // required bool auto_dec_if_lat_failed = 4;
  bool has_auto_dec_if_lat_failed() const;
  private:
  bool _internal_has_auto_dec_if_lat_failed() const;
  public:
  void clear_auto_dec_if_lat_failed();
  bool auto_dec_if_lat_failed() const;
  void set_auto_dec_if_lat_failed(bool value);
  private:
  bool _internal_auto_dec_if_lat_failed() const;
  void _internal_set_auto_dec_if_lat_failed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.ForwardSimDetail)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::LonSimDetail* lon_;
  ::planning::eudm::LatSimDetail* lat_;
  ::planning::eudm::EvasiveSimDetail* evasive_;
  double cooperative_lat_range_;
  double lon_aggressive_ratio_;
  bool auto_dec_if_lat_failed_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SimRefLine PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.SimRefLine) */ {
 public:
  inline SimRefLine() : SimRefLine(nullptr) {}
  virtual ~SimRefLine();
  explicit constexpr SimRefLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimRefLine(const SimRefLine& from);
  SimRefLine(SimRefLine&& from) noexcept
    : SimRefLine() {
    *this = ::std::move(from);
  }

  inline SimRefLine& operator=(const SimRefLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimRefLine& operator=(SimRefLine&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimRefLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimRefLine* internal_default_instance() {
    return reinterpret_cast<const SimRefLine*>(
               &_SimRefLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SimRefLine& a, SimRefLine& b) {
    a.Swap(&b);
  }
  inline void Swap(SimRefLine* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimRefLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimRefLine* New() const final {
    return CreateMaybeMessage<SimRefLine>(nullptr);
  }

  SimRefLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimRefLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimRefLine& from);
  void MergeFrom(const SimRefLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimRefLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.SimRefLine";
  }
  protected:
  explicit SimRefLine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenVelCoeffFieldNumber = 1,
    kForwardLenMaxFieldNumber = 2,
    kForwardLenMinFieldNumber = 3,
    kBackwardLenMaxFieldNumber = 4,
  };
  // required double len_vel_coeff = 1;
  bool has_len_vel_coeff() const;
  private:
  bool _internal_has_len_vel_coeff() const;
  public:
  void clear_len_vel_coeff();
  double len_vel_coeff() const;
  void set_len_vel_coeff(double value);
  private:
  double _internal_len_vel_coeff() const;
  void _internal_set_len_vel_coeff(double value);
  public:

  // required double forward_len_max = 2;
  bool has_forward_len_max() const;
  private:
  bool _internal_has_forward_len_max() const;
  public:
  void clear_forward_len_max();
  double forward_len_max() const;
  void set_forward_len_max(double value);
  private:
  double _internal_forward_len_max() const;
  void _internal_set_forward_len_max(double value);
  public:

  // required double forward_len_min = 3;
  bool has_forward_len_min() const;
  private:
  bool _internal_has_forward_len_min() const;
  public:
  void clear_forward_len_min();
  double forward_len_min() const;
  void set_forward_len_min(double value);
  private:
  double _internal_forward_len_min() const;
  void _internal_set_forward_len_min(double value);
  public:

  // required double backward_len_max = 4;
  bool has_backward_len_max() const;
  private:
  bool _internal_has_backward_len_max() const;
  public:
  void clear_backward_len_max();
  double backward_len_max() const;
  void set_backward_len_max(double value);
  private:
  double _internal_backward_len_max() const;
  void _internal_set_backward_len_max(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.SimRefLine)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double len_vel_coeff_;
  double forward_len_max_;
  double forward_len_min_;
  double backward_len_max_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SimCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.SimCfg) */ {
 public:
  inline SimCfg() : SimCfg(nullptr) {}
  virtual ~SimCfg();
  explicit constexpr SimCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimCfg(const SimCfg& from);
  SimCfg(SimCfg&& from) noexcept
    : SimCfg() {
    *this = ::std::move(from);
  }

  inline SimCfg& operator=(const SimCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimCfg& operator=(SimCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimCfg* internal_default_instance() {
    return reinterpret_cast<const SimCfg*>(
               &_SimCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SimCfg& a, SimCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(SimCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimCfg* New() const final {
    return CreateMaybeMessage<SimCfg>(nullptr);
  }

  SimCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimCfg& from);
  void MergeFrom(const SimCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.SimCfg";
  }
  protected:
  explicit SimCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kEgoFieldNumber = 2,
    kAgentFieldNumber = 3,
    kRefLineFieldNumber = 6,
    kAccCmdVelGapFieldNumber = 4,
    kDecCmdVelGapFieldNumber = 5,
  };
  // required .planning.eudm.SimDurationDetail duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::planning::eudm::SimDurationDetail& duration() const;
  ::planning::eudm::SimDurationDetail* release_duration();
  ::planning::eudm::SimDurationDetail* mutable_duration();
  void set_allocated_duration(::planning::eudm::SimDurationDetail* duration);
  private:
  const ::planning::eudm::SimDurationDetail& _internal_duration() const;
  ::planning::eudm::SimDurationDetail* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::planning::eudm::SimDurationDetail* duration);
  ::planning::eudm::SimDurationDetail* unsafe_arena_release_duration();

  // required .planning.eudm.ForwardSimDetail ego = 2;
  bool has_ego() const;
  private:
  bool _internal_has_ego() const;
  public:
  void clear_ego();
  const ::planning::eudm::ForwardSimDetail& ego() const;
  ::planning::eudm::ForwardSimDetail* release_ego();
  ::planning::eudm::ForwardSimDetail* mutable_ego();
  void set_allocated_ego(::planning::eudm::ForwardSimDetail* ego);
  private:
  const ::planning::eudm::ForwardSimDetail& _internal_ego() const;
  ::planning::eudm::ForwardSimDetail* _internal_mutable_ego();
  public:
  void unsafe_arena_set_allocated_ego(
      ::planning::eudm::ForwardSimDetail* ego);
  ::planning::eudm::ForwardSimDetail* unsafe_arena_release_ego();

  // required .planning.eudm.ForwardSimDetail agent = 3;
  bool has_agent() const;
  private:
  bool _internal_has_agent() const;
  public:
  void clear_agent();
  const ::planning::eudm::ForwardSimDetail& agent() const;
  ::planning::eudm::ForwardSimDetail* release_agent();
  ::planning::eudm::ForwardSimDetail* mutable_agent();
  void set_allocated_agent(::planning::eudm::ForwardSimDetail* agent);
  private:
  const ::planning::eudm::ForwardSimDetail& _internal_agent() const;
  ::planning::eudm::ForwardSimDetail* _internal_mutable_agent();
  public:
  void unsafe_arena_set_allocated_agent(
      ::planning::eudm::ForwardSimDetail* agent);
  ::planning::eudm::ForwardSimDetail* unsafe_arena_release_agent();

  // required .planning.eudm.SimRefLine ref_line = 6;
  bool has_ref_line() const;
  private:
  bool _internal_has_ref_line() const;
  public:
  void clear_ref_line();
  const ::planning::eudm::SimRefLine& ref_line() const;
  ::planning::eudm::SimRefLine* release_ref_line();
  ::planning::eudm::SimRefLine* mutable_ref_line();
  void set_allocated_ref_line(::planning::eudm::SimRefLine* ref_line);
  private:
  const ::planning::eudm::SimRefLine& _internal_ref_line() const;
  ::planning::eudm::SimRefLine* _internal_mutable_ref_line();
  public:
  void unsafe_arena_set_allocated_ref_line(
      ::planning::eudm::SimRefLine* ref_line);
  ::planning::eudm::SimRefLine* unsafe_arena_release_ref_line();

  // required double acc_cmd_vel_gap = 4;
  bool has_acc_cmd_vel_gap() const;
  private:
  bool _internal_has_acc_cmd_vel_gap() const;
  public:
  void clear_acc_cmd_vel_gap();
  double acc_cmd_vel_gap() const;
  void set_acc_cmd_vel_gap(double value);
  private:
  double _internal_acc_cmd_vel_gap() const;
  void _internal_set_acc_cmd_vel_gap(double value);
  public:

  // required double dec_cmd_vel_gap = 5;
  bool has_dec_cmd_vel_gap() const;
  private:
  bool _internal_has_dec_cmd_vel_gap() const;
  public:
  void clear_dec_cmd_vel_gap();
  double dec_cmd_vel_gap() const;
  void set_dec_cmd_vel_gap(double value);
  private:
  double _internal_dec_cmd_vel_gap() const;
  void _internal_set_dec_cmd_vel_gap(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.SimCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::SimDurationDetail* duration_;
  ::planning::eudm::ForwardSimDetail* ego_;
  ::planning::eudm::ForwardSimDetail* agent_;
  ::planning::eudm::SimRefLine* ref_line_;
  double acc_cmd_vel_gap_;
  double dec_cmd_vel_gap_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ActiveLaneChangeCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.ActiveLaneChangeCfg) */ {
 public:
  inline ActiveLaneChangeCfg() : ActiveLaneChangeCfg(nullptr) {}
  virtual ~ActiveLaneChangeCfg();
  explicit constexpr ActiveLaneChangeCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveLaneChangeCfg(const ActiveLaneChangeCfg& from);
  ActiveLaneChangeCfg(ActiveLaneChangeCfg&& from) noexcept
    : ActiveLaneChangeCfg() {
    *this = ::std::move(from);
  }

  inline ActiveLaneChangeCfg& operator=(const ActiveLaneChangeCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveLaneChangeCfg& operator=(ActiveLaneChangeCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActiveLaneChangeCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveLaneChangeCfg* internal_default_instance() {
    return reinterpret_cast<const ActiveLaneChangeCfg*>(
               &_ActiveLaneChangeCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ActiveLaneChangeCfg& a, ActiveLaneChangeCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveLaneChangeCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveLaneChangeCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActiveLaneChangeCfg* New() const final {
    return CreateMaybeMessage<ActiveLaneChangeCfg>(nullptr);
  }

  ActiveLaneChangeCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActiveLaneChangeCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActiveLaneChangeCfg& from);
  void MergeFrom(const ActiveLaneChangeCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveLaneChangeCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.ActiveLaneChangeCfg";
  }
  protected:
  explicit ActiveLaneChangeCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColdDurationFieldNumber = 1,
    kActivateSpeedLowerBoundFieldNumber = 2,
    kActivateSpeedUpperBoundFieldNumber = 3,
    kActivateMaxDurationInSecondsFieldNumber = 4,
    kActiveMinOperationInSecondsFieldNumber = 5,
    kConsistentOperateTimeMinGapFieldNumber = 6,
    kConsistentMinNumFrameFieldNumber = 7,
    kAutoCancelIfLateForSecondsFieldNumber = 12,
    kEnableClearAccumulationByForbidSignalFieldNumber = 8,
    kEnableAutoCancelByForbidSignalFieldNumber = 9,
    kEnableAutoCancelByOutdateTimeFieldNumber = 10,
    kEnableAutoCanbelByStickSignalFieldNumber = 11,
  };
  // required double cold_duration = 1;
  bool has_cold_duration() const;
  private:
  bool _internal_has_cold_duration() const;
  public:
  void clear_cold_duration();
  double cold_duration() const;
  void set_cold_duration(double value);
  private:
  double _internal_cold_duration() const;
  void _internal_set_cold_duration(double value);
  public:

  // required double activate_speed_lower_bound = 2;
  bool has_activate_speed_lower_bound() const;
  private:
  bool _internal_has_activate_speed_lower_bound() const;
  public:
  void clear_activate_speed_lower_bound();
  double activate_speed_lower_bound() const;
  void set_activate_speed_lower_bound(double value);
  private:
  double _internal_activate_speed_lower_bound() const;
  void _internal_set_activate_speed_lower_bound(double value);
  public:

  // required double activate_speed_upper_bound = 3;
  bool has_activate_speed_upper_bound() const;
  private:
  bool _internal_has_activate_speed_upper_bound() const;
  public:
  void clear_activate_speed_upper_bound();
  double activate_speed_upper_bound() const;
  void set_activate_speed_upper_bound(double value);
  private:
  double _internal_activate_speed_upper_bound() const;
  void _internal_set_activate_speed_upper_bound(double value);
  public:

  // required double activate_max_duration_in_seconds = 4;
  bool has_activate_max_duration_in_seconds() const;
  private:
  bool _internal_has_activate_max_duration_in_seconds() const;
  public:
  void clear_activate_max_duration_in_seconds();
  double activate_max_duration_in_seconds() const;
  void set_activate_max_duration_in_seconds(double value);
  private:
  double _internal_activate_max_duration_in_seconds() const;
  void _internal_set_activate_max_duration_in_seconds(double value);
  public:

  // required double active_min_operation_in_seconds = 5;
  bool has_active_min_operation_in_seconds() const;
  private:
  bool _internal_has_active_min_operation_in_seconds() const;
  public:
  void clear_active_min_operation_in_seconds();
  double active_min_operation_in_seconds() const;
  void set_active_min_operation_in_seconds(double value);
  private:
  double _internal_active_min_operation_in_seconds() const;
  void _internal_set_active_min_operation_in_seconds(double value);
  public:

  // required double consistent_operate_time_min_gap = 6;
  bool has_consistent_operate_time_min_gap() const;
  private:
  bool _internal_has_consistent_operate_time_min_gap() const;
  public:
  void clear_consistent_operate_time_min_gap();
  double consistent_operate_time_min_gap() const;
  void set_consistent_operate_time_min_gap(double value);
  private:
  double _internal_consistent_operate_time_min_gap() const;
  void _internal_set_consistent_operate_time_min_gap(double value);
  public:

  // required double consistent_min_num_frame = 7;
  bool has_consistent_min_num_frame() const;
  private:
  bool _internal_has_consistent_min_num_frame() const;
  public:
  void clear_consistent_min_num_frame();
  double consistent_min_num_frame() const;
  void set_consistent_min_num_frame(double value);
  private:
  double _internal_consistent_min_num_frame() const;
  void _internal_set_consistent_min_num_frame(double value);
  public:

  // required double auto_cancel_if_late_for_seconds = 12;
  bool has_auto_cancel_if_late_for_seconds() const;
  private:
  bool _internal_has_auto_cancel_if_late_for_seconds() const;
  public:
  void clear_auto_cancel_if_late_for_seconds();
  double auto_cancel_if_late_for_seconds() const;
  void set_auto_cancel_if_late_for_seconds(double value);
  private:
  double _internal_auto_cancel_if_late_for_seconds() const;
  void _internal_set_auto_cancel_if_late_for_seconds(double value);
  public:

  // required bool enable_clear_accumulation_by_forbid_signal = 8;
  bool has_enable_clear_accumulation_by_forbid_signal() const;
  private:
  bool _internal_has_enable_clear_accumulation_by_forbid_signal() const;
  public:
  void clear_enable_clear_accumulation_by_forbid_signal();
  bool enable_clear_accumulation_by_forbid_signal() const;
  void set_enable_clear_accumulation_by_forbid_signal(bool value);
  private:
  bool _internal_enable_clear_accumulation_by_forbid_signal() const;
  void _internal_set_enable_clear_accumulation_by_forbid_signal(bool value);
  public:

  // required bool enable_auto_cancel_by_forbid_signal = 9;
  bool has_enable_auto_cancel_by_forbid_signal() const;
  private:
  bool _internal_has_enable_auto_cancel_by_forbid_signal() const;
  public:
  void clear_enable_auto_cancel_by_forbid_signal();
  bool enable_auto_cancel_by_forbid_signal() const;
  void set_enable_auto_cancel_by_forbid_signal(bool value);
  private:
  bool _internal_enable_auto_cancel_by_forbid_signal() const;
  void _internal_set_enable_auto_cancel_by_forbid_signal(bool value);
  public:

  // required bool enable_auto_cancel_by_outdate_time = 10;
  bool has_enable_auto_cancel_by_outdate_time() const;
  private:
  bool _internal_has_enable_auto_cancel_by_outdate_time() const;
  public:
  void clear_enable_auto_cancel_by_outdate_time();
  bool enable_auto_cancel_by_outdate_time() const;
  void set_enable_auto_cancel_by_outdate_time(bool value);
  private:
  bool _internal_enable_auto_cancel_by_outdate_time() const;
  void _internal_set_enable_auto_cancel_by_outdate_time(bool value);
  public:

  // required bool enable_auto_canbel_by_stick_signal = 11;
  bool has_enable_auto_canbel_by_stick_signal() const;
  private:
  bool _internal_has_enable_auto_canbel_by_stick_signal() const;
  public:
  void clear_enable_auto_canbel_by_stick_signal();
  bool enable_auto_canbel_by_stick_signal() const;
  void set_enable_auto_canbel_by_stick_signal(bool value);
  private:
  bool _internal_enable_auto_canbel_by_stick_signal() const;
  void _internal_set_enable_auto_canbel_by_stick_signal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.ActiveLaneChangeCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double cold_duration_;
  double activate_speed_lower_bound_;
  double activate_speed_upper_bound_;
  double activate_max_duration_in_seconds_;
  double active_min_operation_in_seconds_;
  double consistent_operate_time_min_gap_;
  double consistent_min_num_frame_;
  double auto_cancel_if_late_for_seconds_;
  bool enable_clear_accumulation_by_forbid_signal_;
  bool enable_auto_cancel_by_forbid_signal_;
  bool enable_auto_cancel_by_outdate_time_;
  bool enable_auto_canbel_by_stick_signal_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class FunctionCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.FunctionCfg) */ {
 public:
  inline FunctionCfg() : FunctionCfg(nullptr) {}
  virtual ~FunctionCfg();
  explicit constexpr FunctionCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionCfg(const FunctionCfg& from);
  FunctionCfg(FunctionCfg&& from) noexcept
    : FunctionCfg() {
    *this = ::std::move(from);
  }

  inline FunctionCfg& operator=(const FunctionCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCfg& operator=(FunctionCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FunctionCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionCfg* internal_default_instance() {
    return reinterpret_cast<const FunctionCfg*>(
               &_FunctionCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FunctionCfg& a, FunctionCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionCfg* New() const final {
    return CreateMaybeMessage<FunctionCfg>(nullptr);
  }

  FunctionCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FunctionCfg& from);
  void MergeFrom(const FunctionCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.FunctionCfg";
  }
  protected:
  explicit FunctionCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveLcFieldNumber = 3,
    kStickLaneChangeInSecondsFieldNumber = 4,
    kMobilEnableFieldNumber = 1,
    kActiveLcEnableFieldNumber = 2,
  };
  // required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
  bool has_active_lc() const;
  private:
  bool _internal_has_active_lc() const;
  public:
  void clear_active_lc();
  const ::planning::eudm::ActiveLaneChangeCfg& active_lc() const;
  ::planning::eudm::ActiveLaneChangeCfg* release_active_lc();
  ::planning::eudm::ActiveLaneChangeCfg* mutable_active_lc();
  void set_allocated_active_lc(::planning::eudm::ActiveLaneChangeCfg* active_lc);
  private:
  const ::planning::eudm::ActiveLaneChangeCfg& _internal_active_lc() const;
  ::planning::eudm::ActiveLaneChangeCfg* _internal_mutable_active_lc();
  public:
  void unsafe_arena_set_allocated_active_lc(
      ::planning::eudm::ActiveLaneChangeCfg* active_lc);
  ::planning::eudm::ActiveLaneChangeCfg* unsafe_arena_release_active_lc();

  // required double stick_lane_change_in_seconds = 4;
  bool has_stick_lane_change_in_seconds() const;
  private:
  bool _internal_has_stick_lane_change_in_seconds() const;
  public:
  void clear_stick_lane_change_in_seconds();
  double stick_lane_change_in_seconds() const;
  void set_stick_lane_change_in_seconds(double value);
  private:
  double _internal_stick_lane_change_in_seconds() const;
  void _internal_set_stick_lane_change_in_seconds(double value);
  public:

  // required bool mobil_enable = 1;
  bool has_mobil_enable() const;
  private:
  bool _internal_has_mobil_enable() const;
  public:
  void clear_mobil_enable();
  bool mobil_enable() const;
  void set_mobil_enable(bool value);
  private:
  bool _internal_mobil_enable() const;
  void _internal_set_mobil_enable(bool value);
  public:

  // required bool active_lc_enable = 2;
  bool has_active_lc_enable() const;
  private:
  bool _internal_has_active_lc_enable() const;
  public:
  void clear_active_lc_enable();
  bool active_lc_enable() const;
  void set_active_lc_enable(bool value);
  private:
  bool _internal_active_lc_enable() const;
  void _internal_set_active_lc_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.FunctionCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::ActiveLaneChangeCfg* active_lc_;
  double stick_lane_change_in_seconds_;
  bool mobil_enable_;
  bool active_lc_enable_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class RssCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.RssCfg) */ {
 public:
  inline RssCfg() : RssCfg(nullptr) {}
  virtual ~RssCfg();
  explicit constexpr RssCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RssCfg(const RssCfg& from);
  RssCfg(RssCfg&& from) noexcept
    : RssCfg() {
    *this = ::std::move(from);
  }

  inline RssCfg& operator=(const RssCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RssCfg& operator=(RssCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RssCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RssCfg* internal_default_instance() {
    return reinterpret_cast<const RssCfg*>(
               &_RssCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RssCfg& a, RssCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(RssCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RssCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RssCfg* New() const final {
    return CreateMaybeMessage<RssCfg>(nullptr);
  }

  RssCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RssCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RssCfg& from);
  void MergeFrom(const RssCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RssCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.RssCfg";
  }
  protected:
  explicit RssCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseTimeFieldNumber = 1,
    kLongitudinalAccMaxFieldNumber = 2,
    kLongitudinalBrakeMinFieldNumber = 3,
    kLongitudinalBrakeMaxFieldNumber = 4,
    kLateralAccMaxFieldNumber = 5,
    kLateralBrakeMinFieldNumber = 6,
    kLateralBrakeMaxFieldNumber = 7,
    kLateralMiuFieldNumber = 8,
  };
  // required double response_time = 1;
  bool has_response_time() const;
  private:
  bool _internal_has_response_time() const;
  public:
  void clear_response_time();
  double response_time() const;
  void set_response_time(double value);
  private:
  double _internal_response_time() const;
  void _internal_set_response_time(double value);
  public:

  // required double longitudinal_acc_max = 2;
  bool has_longitudinal_acc_max() const;
  private:
  bool _internal_has_longitudinal_acc_max() const;
  public:
  void clear_longitudinal_acc_max();
  double longitudinal_acc_max() const;
  void set_longitudinal_acc_max(double value);
  private:
  double _internal_longitudinal_acc_max() const;
  void _internal_set_longitudinal_acc_max(double value);
  public:

  // required double longitudinal_brake_min = 3;
  bool has_longitudinal_brake_min() const;
  private:
  bool _internal_has_longitudinal_brake_min() const;
  public:
  void clear_longitudinal_brake_min();
  double longitudinal_brake_min() const;
  void set_longitudinal_brake_min(double value);
  private:
  double _internal_longitudinal_brake_min() const;
  void _internal_set_longitudinal_brake_min(double value);
  public:

  // required double longitudinal_brake_max = 4;
  bool has_longitudinal_brake_max() const;
  private:
  bool _internal_has_longitudinal_brake_max() const;
  public:
  void clear_longitudinal_brake_max();
  double longitudinal_brake_max() const;
  void set_longitudinal_brake_max(double value);
  private:
  double _internal_longitudinal_brake_max() const;
  void _internal_set_longitudinal_brake_max(double value);
  public:

  // required double lateral_acc_max = 5;
  bool has_lateral_acc_max() const;
  private:
  bool _internal_has_lateral_acc_max() const;
  public:
  void clear_lateral_acc_max();
  double lateral_acc_max() const;
  void set_lateral_acc_max(double value);
  private:
  double _internal_lateral_acc_max() const;
  void _internal_set_lateral_acc_max(double value);
  public:

  // required double lateral_brake_min = 6;
  bool has_lateral_brake_min() const;
  private:
  bool _internal_has_lateral_brake_min() const;
  public:
  void clear_lateral_brake_min();
  double lateral_brake_min() const;
  void set_lateral_brake_min(double value);
  private:
  double _internal_lateral_brake_min() const;
  void _internal_set_lateral_brake_min(double value);
  public:

  // required double lateral_brake_max = 7;
  bool has_lateral_brake_max() const;
  private:
  bool _internal_has_lateral_brake_max() const;
  public:
  void clear_lateral_brake_max();
  double lateral_brake_max() const;
  void set_lateral_brake_max(double value);
  private:
  double _internal_lateral_brake_max() const;
  void _internal_set_lateral_brake_max(double value);
  public:

  // required double lateral_miu = 8;
  bool has_lateral_miu() const;
  private:
  bool _internal_has_lateral_miu() const;
  public:
  void clear_lateral_miu();
  double lateral_miu() const;
  void set_lateral_miu(double value);
  private:
  double _internal_lateral_miu() const;
  void _internal_set_lateral_miu(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.RssCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double response_time_;
  double longitudinal_acc_max_;
  double longitudinal_brake_min_;
  double longitudinal_brake_max_;
  double lateral_acc_max_;
  double lateral_brake_min_;
  double lateral_brake_max_;
  double lateral_miu_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class StrictCheckCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.StrictCheckCfg) */ {
 public:
  inline StrictCheckCfg() : StrictCheckCfg(nullptr) {}
  virtual ~StrictCheckCfg();
  explicit constexpr StrictCheckCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrictCheckCfg(const StrictCheckCfg& from);
  StrictCheckCfg(StrictCheckCfg&& from) noexcept
    : StrictCheckCfg() {
    *this = ::std::move(from);
  }

  inline StrictCheckCfg& operator=(const StrictCheckCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictCheckCfg& operator=(StrictCheckCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StrictCheckCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrictCheckCfg* internal_default_instance() {
    return reinterpret_cast<const StrictCheckCfg*>(
               &_StrictCheckCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StrictCheckCfg& a, StrictCheckCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(StrictCheckCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictCheckCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrictCheckCfg* New() const final {
    return CreateMaybeMessage<StrictCheckCfg>(nullptr);
  }

  StrictCheckCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrictCheckCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrictCheckCfg& from);
  void MergeFrom(const StrictCheckCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrictCheckCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.StrictCheckCfg";
  }
  protected:
  explicit StrictCheckCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInflationWFieldNumber = 1,
    kInflationHFieldNumber = 2,
  };
  // required double inflation_w = 1;
  bool has_inflation_w() const;
  private:
  bool _internal_has_inflation_w() const;
  public:
  void clear_inflation_w();
  double inflation_w() const;
  void set_inflation_w(double value);
  private:
  double _internal_inflation_w() const;
  void _internal_set_inflation_w(double value);
  public:

  // required double inflation_h = 2;
  bool has_inflation_h() const;
  private:
  bool _internal_has_inflation_h() const;
  public:
  void clear_inflation_h();
  double inflation_h() const;
  void set_inflation_h(double value);
  private:
  double _internal_inflation_h() const;
  void _internal_set_inflation_h(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.StrictCheckCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double inflation_w_;
  double inflation_h_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SafetyCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.SafetyCfg) */ {
 public:
  inline SafetyCfg() : SafetyCfg(nullptr) {}
  virtual ~SafetyCfg();
  explicit constexpr SafetyCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafetyCfg(const SafetyCfg& from);
  SafetyCfg(SafetyCfg&& from) noexcept
    : SafetyCfg() {
    *this = ::std::move(from);
  }

  inline SafetyCfg& operator=(const SafetyCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyCfg& operator=(SafetyCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SafetyCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafetyCfg* internal_default_instance() {
    return reinterpret_cast<const SafetyCfg*>(
               &_SafetyCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SafetyCfg& a, SafetyCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(SafetyCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafetyCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SafetyCfg* New() const final {
    return CreateMaybeMessage<SafetyCfg>(nullptr);
  }

  SafetyCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SafetyCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SafetyCfg& from);
  void MergeFrom(const SafetyCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SafetyCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.SafetyCfg";
  }
  protected:
  explicit SafetyCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrictFieldNumber = 1,
    kRssFieldNumber = 3,
    kRssStrictAsFrontFieldNumber = 5,
    kRssStrictAsRearFieldNumber = 6,
    kStrictCheckEnableFieldNumber = 2,
    kRssCheckEnableFieldNumber = 4,
    kRssForLayersEnableFieldNumber = 7,
  };
  // required .planning.eudm.StrictCheckCfg strict = 1;
  bool has_strict() const;
  private:
  bool _internal_has_strict() const;
  public:
  void clear_strict();
  const ::planning::eudm::StrictCheckCfg& strict() const;
  ::planning::eudm::StrictCheckCfg* release_strict();
  ::planning::eudm::StrictCheckCfg* mutable_strict();
  void set_allocated_strict(::planning::eudm::StrictCheckCfg* strict);
  private:
  const ::planning::eudm::StrictCheckCfg& _internal_strict() const;
  ::planning::eudm::StrictCheckCfg* _internal_mutable_strict();
  public:
  void unsafe_arena_set_allocated_strict(
      ::planning::eudm::StrictCheckCfg* strict);
  ::planning::eudm::StrictCheckCfg* unsafe_arena_release_strict();

  // required .planning.eudm.RssCfg rss = 3;
  bool has_rss() const;
  private:
  bool _internal_has_rss() const;
  public:
  void clear_rss();
  const ::planning::eudm::RssCfg& rss() const;
  ::planning::eudm::RssCfg* release_rss();
  ::planning::eudm::RssCfg* mutable_rss();
  void set_allocated_rss(::planning::eudm::RssCfg* rss);
  private:
  const ::planning::eudm::RssCfg& _internal_rss() const;
  ::planning::eudm::RssCfg* _internal_mutable_rss();
  public:
  void unsafe_arena_set_allocated_rss(
      ::planning::eudm::RssCfg* rss);
  ::planning::eudm::RssCfg* unsafe_arena_release_rss();

  // required .planning.eudm.RssCfg rss_strict_as_front = 5;
  bool has_rss_strict_as_front() const;
  private:
  bool _internal_has_rss_strict_as_front() const;
  public:
  void clear_rss_strict_as_front();
  const ::planning::eudm::RssCfg& rss_strict_as_front() const;
  ::planning::eudm::RssCfg* release_rss_strict_as_front();
  ::planning::eudm::RssCfg* mutable_rss_strict_as_front();
  void set_allocated_rss_strict_as_front(::planning::eudm::RssCfg* rss_strict_as_front);
  private:
  const ::planning::eudm::RssCfg& _internal_rss_strict_as_front() const;
  ::planning::eudm::RssCfg* _internal_mutable_rss_strict_as_front();
  public:
  void unsafe_arena_set_allocated_rss_strict_as_front(
      ::planning::eudm::RssCfg* rss_strict_as_front);
  ::planning::eudm::RssCfg* unsafe_arena_release_rss_strict_as_front();

  // required .planning.eudm.RssCfg rss_strict_as_rear = 6;
  bool has_rss_strict_as_rear() const;
  private:
  bool _internal_has_rss_strict_as_rear() const;
  public:
  void clear_rss_strict_as_rear();
  const ::planning::eudm::RssCfg& rss_strict_as_rear() const;
  ::planning::eudm::RssCfg* release_rss_strict_as_rear();
  ::planning::eudm::RssCfg* mutable_rss_strict_as_rear();
  void set_allocated_rss_strict_as_rear(::planning::eudm::RssCfg* rss_strict_as_rear);
  private:
  const ::planning::eudm::RssCfg& _internal_rss_strict_as_rear() const;
  ::planning::eudm::RssCfg* _internal_mutable_rss_strict_as_rear();
  public:
  void unsafe_arena_set_allocated_rss_strict_as_rear(
      ::planning::eudm::RssCfg* rss_strict_as_rear);
  ::planning::eudm::RssCfg* unsafe_arena_release_rss_strict_as_rear();

  // required bool strict_check_enable = 2;
  bool has_strict_check_enable() const;
  private:
  bool _internal_has_strict_check_enable() const;
  public:
  void clear_strict_check_enable();
  bool strict_check_enable() const;
  void set_strict_check_enable(bool value);
  private:
  bool _internal_strict_check_enable() const;
  void _internal_set_strict_check_enable(bool value);
  public:

  // required bool rss_check_enable = 4;
  bool has_rss_check_enable() const;
  private:
  bool _internal_has_rss_check_enable() const;
  public:
  void clear_rss_check_enable();
  bool rss_check_enable() const;
  void set_rss_check_enable(bool value);
  private:
  bool _internal_rss_check_enable() const;
  void _internal_set_rss_check_enable(bool value);
  public:

  // required bool rss_for_layers_enable = 7;
  bool has_rss_for_layers_enable() const;
  private:
  bool _internal_has_rss_for_layers_enable() const;
  public:
  void clear_rss_for_layers_enable();
  bool rss_for_layers_enable() const;
  void set_rss_for_layers_enable(bool value);
  private:
  bool _internal_rss_for_layers_enable() const;
  void _internal_set_rss_for_layers_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.eudm.SafetyCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::eudm::StrictCheckCfg* strict_;
  ::planning::eudm::RssCfg* rss_;
  ::planning::eudm::RssCfg* rss_strict_as_front_;
  ::planning::eudm::RssCfg* rss_strict_as_rear_;
  bool strict_check_enable_;
  bool rss_check_enable_;
  bool rss_for_layers_enable_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.eudm.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  virtual ~Config();
  explicit constexpr Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.eudm.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_eudm_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kStatusFieldNumber = 3,
    kCostFieldNumber = 4,
    kSimFieldNumber = 5,
    kFunctionFieldNumber = 6,
    kSafetyFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required string status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // required .planning.eudm.CostAssessCfg cost = 4;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  const ::planning::eudm::CostAssessCfg& cost() const;
  ::planning::eudm::CostAssessCfg* release_cost();
  ::planning::eudm::CostAssessCfg* mutable_cost();
  void set_allocated_cost(::planning::eudm::CostAssessCfg* cost);
  private:
  const ::planning::eudm::CostAssessCfg& _internal_cost() const;
  ::planning::eudm::CostAssessCfg* _internal_mutable_cost();
  public:
  void unsafe_arena_set_allocated_cost(
      ::planning::eudm::CostAssessCfg* cost);
  ::planning::eudm::CostAssessCfg* unsafe_arena_release_cost();

  // required .planning.eudm.SimCfg sim = 5;
  bool has_sim() const;
  private:
  bool _internal_has_sim() const;
  public:
  void clear_sim();
  const ::planning::eudm::SimCfg& sim() const;
  ::planning::eudm::SimCfg* release_sim();
  ::planning::eudm::SimCfg* mutable_sim();
  void set_allocated_sim(::planning::eudm::SimCfg* sim);
  private:
  const ::planning::eudm::SimCfg& _internal_sim() const;
  ::planning::eudm::SimCfg* _internal_mutable_sim();
  public:
  void unsafe_arena_set_allocated_sim(
      ::planning::eudm::SimCfg* sim);
  ::planning::eudm::SimCfg* unsafe_arena_release_sim();

  // required .planning.eudm.FunctionCfg function = 6;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const ::planning::eudm::FunctionCfg& function() const;
  ::planning::eudm::FunctionCfg* release_function();
  ::planning::eudm::FunctionCfg* mutable_function();
  void set_allocated_function(::planning::eudm::FunctionCfg* function);
  private:
  const ::planning::eudm::FunctionCfg& _internal_function() const;
  ::planning::eudm::FunctionCfg* _internal_mutable_function();
  public:
  void unsafe_arena_set_allocated_function(
      ::planning::eudm::FunctionCfg* function);
  ::planning::eudm::FunctionCfg* unsafe_arena_release_function();

  // required .planning.eudm.SafetyCfg safety = 7;
  bool has_safety() const;
  private:
  bool _internal_has_safety() const;
  public:
  void clear_safety();
  const ::planning::eudm::SafetyCfg& safety() const;
  ::planning::eudm::SafetyCfg* release_safety();
  ::planning::eudm::SafetyCfg* mutable_safety();
  void set_allocated_safety(::planning::eudm::SafetyCfg* safety);
  private:
  const ::planning::eudm::SafetyCfg& _internal_safety() const;
  ::planning::eudm::SafetyCfg* _internal_mutable_safety();
  public:
  void unsafe_arena_set_allocated_safety(
      ::planning::eudm::SafetyCfg* safety);
  ::planning::eudm::SafetyCfg* unsafe_arena_release_safety();

  // @@protoc_insertion_point(class_scope:planning.eudm.Config)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::planning::eudm::CostAssessCfg* cost_;
  ::planning::eudm::SimCfg* sim_;
  ::planning::eudm::FunctionCfg* function_;
  ::planning::eudm::SafetyCfg* safety_;
  friend struct ::TableStruct_eudm_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EfficiencyAssessDetail

// required double ego_lack_speed_to_desired_unit_cost = 1;
inline bool EfficiencyAssessDetail::_internal_has_ego_lack_speed_to_desired_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_ego_lack_speed_to_desired_unit_cost() const {
  return _internal_has_ego_lack_speed_to_desired_unit_cost();
}
inline void EfficiencyAssessDetail::clear_ego_lack_speed_to_desired_unit_cost() {
  ego_lack_speed_to_desired_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double EfficiencyAssessDetail::_internal_ego_lack_speed_to_desired_unit_cost() const {
  return ego_lack_speed_to_desired_unit_cost_;
}
inline double EfficiencyAssessDetail::ego_lack_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.ego_lack_speed_to_desired_unit_cost)
  return _internal_ego_lack_speed_to_desired_unit_cost();
}
inline void EfficiencyAssessDetail::_internal_set_ego_lack_speed_to_desired_unit_cost(double value) {
  _has_bits_[0] |= 0x00000001u;
  ego_lack_speed_to_desired_unit_cost_ = value;
}
inline void EfficiencyAssessDetail::set_ego_lack_speed_to_desired_unit_cost(double value) {
  _internal_set_ego_lack_speed_to_desired_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.ego_lack_speed_to_desired_unit_cost)
}

// required double ego_over_speed_to_desired_unit_cost = 2;
inline bool EfficiencyAssessDetail::_internal_has_ego_over_speed_to_desired_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_ego_over_speed_to_desired_unit_cost() const {
  return _internal_has_ego_over_speed_to_desired_unit_cost();
}
inline void EfficiencyAssessDetail::clear_ego_over_speed_to_desired_unit_cost() {
  ego_over_speed_to_desired_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double EfficiencyAssessDetail::_internal_ego_over_speed_to_desired_unit_cost() const {
  return ego_over_speed_to_desired_unit_cost_;
}
inline double EfficiencyAssessDetail::ego_over_speed_to_desired_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.ego_over_speed_to_desired_unit_cost)
  return _internal_ego_over_speed_to_desired_unit_cost();
}
inline void EfficiencyAssessDetail::_internal_set_ego_over_speed_to_desired_unit_cost(double value) {
  _has_bits_[0] |= 0x00000002u;
  ego_over_speed_to_desired_unit_cost_ = value;
}
inline void EfficiencyAssessDetail::set_ego_over_speed_to_desired_unit_cost(double value) {
  _internal_set_ego_over_speed_to_desired_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.ego_over_speed_to_desired_unit_cost)
}

// required double ego_desired_speed_tolerate_gap = 3;
inline bool EfficiencyAssessDetail::_internal_has_ego_desired_speed_tolerate_gap() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_ego_desired_speed_tolerate_gap() const {
  return _internal_has_ego_desired_speed_tolerate_gap();
}
inline void EfficiencyAssessDetail::clear_ego_desired_speed_tolerate_gap() {
  ego_desired_speed_tolerate_gap_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double EfficiencyAssessDetail::_internal_ego_desired_speed_tolerate_gap() const {
  return ego_desired_speed_tolerate_gap_;
}
inline double EfficiencyAssessDetail::ego_desired_speed_tolerate_gap() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.ego_desired_speed_tolerate_gap)
  return _internal_ego_desired_speed_tolerate_gap();
}
inline void EfficiencyAssessDetail::_internal_set_ego_desired_speed_tolerate_gap(double value) {
  _has_bits_[0] |= 0x00000004u;
  ego_desired_speed_tolerate_gap_ = value;
}
inline void EfficiencyAssessDetail::set_ego_desired_speed_tolerate_gap(double value) {
  _internal_set_ego_desired_speed_tolerate_gap(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.ego_desired_speed_tolerate_gap)
}

// required double leading_distance_th = 4;
inline bool EfficiencyAssessDetail::_internal_has_leading_distance_th() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_leading_distance_th() const {
  return _internal_has_leading_distance_th();
}
inline void EfficiencyAssessDetail::clear_leading_distance_th() {
  leading_distance_th_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double EfficiencyAssessDetail::_internal_leading_distance_th() const {
  return leading_distance_th_;
}
inline double EfficiencyAssessDetail::leading_distance_th() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.leading_distance_th)
  return _internal_leading_distance_th();
}
inline void EfficiencyAssessDetail::_internal_set_leading_distance_th(double value) {
  _has_bits_[0] |= 0x00000008u;
  leading_distance_th_ = value;
}
inline void EfficiencyAssessDetail::set_leading_distance_th(double value) {
  _internal_set_leading_distance_th(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.leading_distance_th)
}

// required double min_distance_ratio = 5;
inline bool EfficiencyAssessDetail::_internal_has_min_distance_ratio() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_min_distance_ratio() const {
  return _internal_has_min_distance_ratio();
}
inline void EfficiencyAssessDetail::clear_min_distance_ratio() {
  min_distance_ratio_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double EfficiencyAssessDetail::_internal_min_distance_ratio() const {
  return min_distance_ratio_;
}
inline double EfficiencyAssessDetail::min_distance_ratio() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.min_distance_ratio)
  return _internal_min_distance_ratio();
}
inline void EfficiencyAssessDetail::_internal_set_min_distance_ratio(double value) {
  _has_bits_[0] |= 0x00000010u;
  min_distance_ratio_ = value;
}
inline void EfficiencyAssessDetail::set_min_distance_ratio(double value) {
  _internal_set_min_distance_ratio(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.min_distance_ratio)
}

// required double ego_speed_blocked_by_leading_unit_cost = 6;
inline bool EfficiencyAssessDetail::_internal_has_ego_speed_blocked_by_leading_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_ego_speed_blocked_by_leading_unit_cost() const {
  return _internal_has_ego_speed_blocked_by_leading_unit_cost();
}
inline void EfficiencyAssessDetail::clear_ego_speed_blocked_by_leading_unit_cost() {
  ego_speed_blocked_by_leading_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double EfficiencyAssessDetail::_internal_ego_speed_blocked_by_leading_unit_cost() const {
  return ego_speed_blocked_by_leading_unit_cost_;
}
inline double EfficiencyAssessDetail::ego_speed_blocked_by_leading_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.ego_speed_blocked_by_leading_unit_cost)
  return _internal_ego_speed_blocked_by_leading_unit_cost();
}
inline void EfficiencyAssessDetail::_internal_set_ego_speed_blocked_by_leading_unit_cost(double value) {
  _has_bits_[0] |= 0x00000020u;
  ego_speed_blocked_by_leading_unit_cost_ = value;
}
inline void EfficiencyAssessDetail::set_ego_speed_blocked_by_leading_unit_cost(double value) {
  _internal_set_ego_speed_blocked_by_leading_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.ego_speed_blocked_by_leading_unit_cost)
}

// required double leading_speed_blocked_desired_vel_unit_cost = 7;
inline bool EfficiencyAssessDetail::_internal_has_leading_speed_blocked_desired_vel_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EfficiencyAssessDetail::has_leading_speed_blocked_desired_vel_unit_cost() const {
  return _internal_has_leading_speed_blocked_desired_vel_unit_cost();
}
inline void EfficiencyAssessDetail::clear_leading_speed_blocked_desired_vel_unit_cost() {
  leading_speed_blocked_desired_vel_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double EfficiencyAssessDetail::_internal_leading_speed_blocked_desired_vel_unit_cost() const {
  return leading_speed_blocked_desired_vel_unit_cost_;
}
inline double EfficiencyAssessDetail::leading_speed_blocked_desired_vel_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EfficiencyAssessDetail.leading_speed_blocked_desired_vel_unit_cost)
  return _internal_leading_speed_blocked_desired_vel_unit_cost();
}
inline void EfficiencyAssessDetail::_internal_set_leading_speed_blocked_desired_vel_unit_cost(double value) {
  _has_bits_[0] |= 0x00000040u;
  leading_speed_blocked_desired_vel_unit_cost_ = value;
}
inline void EfficiencyAssessDetail::set_leading_speed_blocked_desired_vel_unit_cost(double value) {
  _internal_set_leading_speed_blocked_desired_vel_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EfficiencyAssessDetail.leading_speed_blocked_desired_vel_unit_cost)
}

// -------------------------------------------------------------------

// SafetyAssessDetail

// required bool rss_cost_enable = 1;
inline bool SafetyAssessDetail::_internal_has_rss_cost_enable() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_rss_cost_enable() const {
  return _internal_has_rss_cost_enable();
}
inline void SafetyAssessDetail::clear_rss_cost_enable() {
  rss_cost_enable_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SafetyAssessDetail::_internal_rss_cost_enable() const {
  return rss_cost_enable_;
}
inline bool SafetyAssessDetail::rss_cost_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.rss_cost_enable)
  return _internal_rss_cost_enable();
}
inline void SafetyAssessDetail::_internal_set_rss_cost_enable(bool value) {
  _has_bits_[0] |= 0x00000020u;
  rss_cost_enable_ = value;
}
inline void SafetyAssessDetail::set_rss_cost_enable(bool value) {
  _internal_set_rss_cost_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.rss_cost_enable)
}

// required double rss_over_speed_power_coeff = 2;
inline bool SafetyAssessDetail::_internal_has_rss_over_speed_power_coeff() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_rss_over_speed_power_coeff() const {
  return _internal_has_rss_over_speed_power_coeff();
}
inline void SafetyAssessDetail::clear_rss_over_speed_power_coeff() {
  rss_over_speed_power_coeff_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SafetyAssessDetail::_internal_rss_over_speed_power_coeff() const {
  return rss_over_speed_power_coeff_;
}
inline double SafetyAssessDetail::rss_over_speed_power_coeff() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.rss_over_speed_power_coeff)
  return _internal_rss_over_speed_power_coeff();
}
inline void SafetyAssessDetail::_internal_set_rss_over_speed_power_coeff(double value) {
  _has_bits_[0] |= 0x00000001u;
  rss_over_speed_power_coeff_ = value;
}
inline void SafetyAssessDetail::set_rss_over_speed_power_coeff(double value) {
  _internal_set_rss_over_speed_power_coeff(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.rss_over_speed_power_coeff)
}

// required double rss_over_speed_linear_coeff = 3;
inline bool SafetyAssessDetail::_internal_has_rss_over_speed_linear_coeff() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_rss_over_speed_linear_coeff() const {
  return _internal_has_rss_over_speed_linear_coeff();
}
inline void SafetyAssessDetail::clear_rss_over_speed_linear_coeff() {
  rss_over_speed_linear_coeff_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SafetyAssessDetail::_internal_rss_over_speed_linear_coeff() const {
  return rss_over_speed_linear_coeff_;
}
inline double SafetyAssessDetail::rss_over_speed_linear_coeff() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.rss_over_speed_linear_coeff)
  return _internal_rss_over_speed_linear_coeff();
}
inline void SafetyAssessDetail::_internal_set_rss_over_speed_linear_coeff(double value) {
  _has_bits_[0] |= 0x00000002u;
  rss_over_speed_linear_coeff_ = value;
}
inline void SafetyAssessDetail::set_rss_over_speed_linear_coeff(double value) {
  _internal_set_rss_over_speed_linear_coeff(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.rss_over_speed_linear_coeff)
}

// required double rss_lack_speed_power_coeff = 4;
inline bool SafetyAssessDetail::_internal_has_rss_lack_speed_power_coeff() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_rss_lack_speed_power_coeff() const {
  return _internal_has_rss_lack_speed_power_coeff();
}
inline void SafetyAssessDetail::clear_rss_lack_speed_power_coeff() {
  rss_lack_speed_power_coeff_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SafetyAssessDetail::_internal_rss_lack_speed_power_coeff() const {
  return rss_lack_speed_power_coeff_;
}
inline double SafetyAssessDetail::rss_lack_speed_power_coeff() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.rss_lack_speed_power_coeff)
  return _internal_rss_lack_speed_power_coeff();
}
inline void SafetyAssessDetail::_internal_set_rss_lack_speed_power_coeff(double value) {
  _has_bits_[0] |= 0x00000004u;
  rss_lack_speed_power_coeff_ = value;
}
inline void SafetyAssessDetail::set_rss_lack_speed_power_coeff(double value) {
  _internal_set_rss_lack_speed_power_coeff(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.rss_lack_speed_power_coeff)
}

// required double rss_lack_speed_linear_coeff = 5;
inline bool SafetyAssessDetail::_internal_has_rss_lack_speed_linear_coeff() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_rss_lack_speed_linear_coeff() const {
  return _internal_has_rss_lack_speed_linear_coeff();
}
inline void SafetyAssessDetail::clear_rss_lack_speed_linear_coeff() {
  rss_lack_speed_linear_coeff_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SafetyAssessDetail::_internal_rss_lack_speed_linear_coeff() const {
  return rss_lack_speed_linear_coeff_;
}
inline double SafetyAssessDetail::rss_lack_speed_linear_coeff() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.rss_lack_speed_linear_coeff)
  return _internal_rss_lack_speed_linear_coeff();
}
inline void SafetyAssessDetail::_internal_set_rss_lack_speed_linear_coeff(double value) {
  _has_bits_[0] |= 0x00000008u;
  rss_lack_speed_linear_coeff_ = value;
}
inline void SafetyAssessDetail::set_rss_lack_speed_linear_coeff(double value) {
  _internal_set_rss_lack_speed_linear_coeff(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.rss_lack_speed_linear_coeff)
}

// required bool occu_lane_enable = 6;
inline bool SafetyAssessDetail::_internal_has_occu_lane_enable() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_occu_lane_enable() const {
  return _internal_has_occu_lane_enable();
}
inline void SafetyAssessDetail::clear_occu_lane_enable() {
  occu_lane_enable_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool SafetyAssessDetail::_internal_occu_lane_enable() const {
  return occu_lane_enable_;
}
inline bool SafetyAssessDetail::occu_lane_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.occu_lane_enable)
  return _internal_occu_lane_enable();
}
inline void SafetyAssessDetail::_internal_set_occu_lane_enable(bool value) {
  _has_bits_[0] |= 0x00000040u;
  occu_lane_enable_ = value;
}
inline void SafetyAssessDetail::set_occu_lane_enable(bool value) {
  _internal_set_occu_lane_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.occu_lane_enable)
}

// required double occu_lane_unit_cost = 7;
inline bool SafetyAssessDetail::_internal_has_occu_lane_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SafetyAssessDetail::has_occu_lane_unit_cost() const {
  return _internal_has_occu_lane_unit_cost();
}
inline void SafetyAssessDetail::clear_occu_lane_unit_cost() {
  occu_lane_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SafetyAssessDetail::_internal_occu_lane_unit_cost() const {
  return occu_lane_unit_cost_;
}
inline double SafetyAssessDetail::occu_lane_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyAssessDetail.occu_lane_unit_cost)
  return _internal_occu_lane_unit_cost();
}
inline void SafetyAssessDetail::_internal_set_occu_lane_unit_cost(double value) {
  _has_bits_[0] |= 0x00000010u;
  occu_lane_unit_cost_ = value;
}
inline void SafetyAssessDetail::set_occu_lane_unit_cost(double value) {
  _internal_set_occu_lane_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyAssessDetail.occu_lane_unit_cost)
}

// -------------------------------------------------------------------

// UserIntentionAssessDetail

// required double late_operate_unit_cost = 1;
inline bool UserIntentionAssessDetail::_internal_has_late_operate_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserIntentionAssessDetail::has_late_operate_unit_cost() const {
  return _internal_has_late_operate_unit_cost();
}
inline void UserIntentionAssessDetail::clear_late_operate_unit_cost() {
  late_operate_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double UserIntentionAssessDetail::_internal_late_operate_unit_cost() const {
  return late_operate_unit_cost_;
}
inline double UserIntentionAssessDetail::late_operate_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.UserIntentionAssessDetail.late_operate_unit_cost)
  return _internal_late_operate_unit_cost();
}
inline void UserIntentionAssessDetail::_internal_set_late_operate_unit_cost(double value) {
  _has_bits_[0] |= 0x00000001u;
  late_operate_unit_cost_ = value;
}
inline void UserIntentionAssessDetail::set_late_operate_unit_cost(double value) {
  _internal_set_late_operate_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.UserIntentionAssessDetail.late_operate_unit_cost)
}

// required double cancel_operation_unit_cost = 2;
inline bool UserIntentionAssessDetail::_internal_has_cancel_operation_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserIntentionAssessDetail::has_cancel_operation_unit_cost() const {
  return _internal_has_cancel_operation_unit_cost();
}
inline void UserIntentionAssessDetail::clear_cancel_operation_unit_cost() {
  cancel_operation_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double UserIntentionAssessDetail::_internal_cancel_operation_unit_cost() const {
  return cancel_operation_unit_cost_;
}
inline double UserIntentionAssessDetail::cancel_operation_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.UserIntentionAssessDetail.cancel_operation_unit_cost)
  return _internal_cancel_operation_unit_cost();
}
inline void UserIntentionAssessDetail::_internal_set_cancel_operation_unit_cost(double value) {
  _has_bits_[0] |= 0x00000002u;
  cancel_operation_unit_cost_ = value;
}
inline void UserIntentionAssessDetail::set_cancel_operation_unit_cost(double value) {
  _internal_set_cancel_operation_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.UserIntentionAssessDetail.cancel_operation_unit_cost)
}

// -------------------------------------------------------------------

// NavigationAssessDetail

// required double lane_change_left_unit_cost = 1;
inline bool NavigationAssessDetail::_internal_has_lane_change_left_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavigationAssessDetail::has_lane_change_left_unit_cost() const {
  return _internal_has_lane_change_left_unit_cost();
}
inline void NavigationAssessDetail::clear_lane_change_left_unit_cost() {
  lane_change_left_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double NavigationAssessDetail::_internal_lane_change_left_unit_cost() const {
  return lane_change_left_unit_cost_;
}
inline double NavigationAssessDetail::lane_change_left_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.NavigationAssessDetail.lane_change_left_unit_cost)
  return _internal_lane_change_left_unit_cost();
}
inline void NavigationAssessDetail::_internal_set_lane_change_left_unit_cost(double value) {
  _has_bits_[0] |= 0x00000001u;
  lane_change_left_unit_cost_ = value;
}
inline void NavigationAssessDetail::set_lane_change_left_unit_cost(double value) {
  _internal_set_lane_change_left_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.NavigationAssessDetail.lane_change_left_unit_cost)
}

// required double lane_change_right_unit_cost = 2;
inline bool NavigationAssessDetail::_internal_has_lane_change_right_unit_cost() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NavigationAssessDetail::has_lane_change_right_unit_cost() const {
  return _internal_has_lane_change_right_unit_cost();
}
inline void NavigationAssessDetail::clear_lane_change_right_unit_cost() {
  lane_change_right_unit_cost_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double NavigationAssessDetail::_internal_lane_change_right_unit_cost() const {
  return lane_change_right_unit_cost_;
}
inline double NavigationAssessDetail::lane_change_right_unit_cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.NavigationAssessDetail.lane_change_right_unit_cost)
  return _internal_lane_change_right_unit_cost();
}
inline void NavigationAssessDetail::_internal_set_lane_change_right_unit_cost(double value) {
  _has_bits_[0] |= 0x00000002u;
  lane_change_right_unit_cost_ = value;
}
inline void NavigationAssessDetail::set_lane_change_right_unit_cost(double value) {
  _internal_set_lane_change_right_unit_cost(value);
  // @@protoc_insertion_point(field_set:planning.eudm.NavigationAssessDetail.lane_change_right_unit_cost)
}

// required double lane_change_unit_cost_vel_lb = 3;
inline bool NavigationAssessDetail::_internal_has_lane_change_unit_cost_vel_lb() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NavigationAssessDetail::has_lane_change_unit_cost_vel_lb() const {
  return _internal_has_lane_change_unit_cost_vel_lb();
}
inline void NavigationAssessDetail::clear_lane_change_unit_cost_vel_lb() {
  lane_change_unit_cost_vel_lb_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double NavigationAssessDetail::_internal_lane_change_unit_cost_vel_lb() const {
  return lane_change_unit_cost_vel_lb_;
}
inline double NavigationAssessDetail::lane_change_unit_cost_vel_lb() const {
  // @@protoc_insertion_point(field_get:planning.eudm.NavigationAssessDetail.lane_change_unit_cost_vel_lb)
  return _internal_lane_change_unit_cost_vel_lb();
}
inline void NavigationAssessDetail::_internal_set_lane_change_unit_cost_vel_lb(double value) {
  _has_bits_[0] |= 0x00000004u;
  lane_change_unit_cost_vel_lb_ = value;
}
inline void NavigationAssessDetail::set_lane_change_unit_cost_vel_lb(double value) {
  _internal_set_lane_change_unit_cost_vel_lb(value);
  // @@protoc_insertion_point(field_set:planning.eudm.NavigationAssessDetail.lane_change_unit_cost_vel_lb)
}

// required double lane_change_left_recommendation_reward = 4;
inline bool NavigationAssessDetail::_internal_has_lane_change_left_recommendation_reward() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NavigationAssessDetail::has_lane_change_left_recommendation_reward() const {
  return _internal_has_lane_change_left_recommendation_reward();
}
inline void NavigationAssessDetail::clear_lane_change_left_recommendation_reward() {
  lane_change_left_recommendation_reward_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double NavigationAssessDetail::_internal_lane_change_left_recommendation_reward() const {
  return lane_change_left_recommendation_reward_;
}
inline double NavigationAssessDetail::lane_change_left_recommendation_reward() const {
  // @@protoc_insertion_point(field_get:planning.eudm.NavigationAssessDetail.lane_change_left_recommendation_reward)
  return _internal_lane_change_left_recommendation_reward();
}
inline void NavigationAssessDetail::_internal_set_lane_change_left_recommendation_reward(double value) {
  _has_bits_[0] |= 0x00000008u;
  lane_change_left_recommendation_reward_ = value;
}
inline void NavigationAssessDetail::set_lane_change_left_recommendation_reward(double value) {
  _internal_set_lane_change_left_recommendation_reward(value);
  // @@protoc_insertion_point(field_set:planning.eudm.NavigationAssessDetail.lane_change_left_recommendation_reward)
}

// required double lane_change_right_recommendation_reward = 5;
inline bool NavigationAssessDetail::_internal_has_lane_change_right_recommendation_reward() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NavigationAssessDetail::has_lane_change_right_recommendation_reward() const {
  return _internal_has_lane_change_right_recommendation_reward();
}
inline void NavigationAssessDetail::clear_lane_change_right_recommendation_reward() {
  lane_change_right_recommendation_reward_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double NavigationAssessDetail::_internal_lane_change_right_recommendation_reward() const {
  return lane_change_right_recommendation_reward_;
}
inline double NavigationAssessDetail::lane_change_right_recommendation_reward() const {
  // @@protoc_insertion_point(field_get:planning.eudm.NavigationAssessDetail.lane_change_right_recommendation_reward)
  return _internal_lane_change_right_recommendation_reward();
}
inline void NavigationAssessDetail::_internal_set_lane_change_right_recommendation_reward(double value) {
  _has_bits_[0] |= 0x00000010u;
  lane_change_right_recommendation_reward_ = value;
}
inline void NavigationAssessDetail::set_lane_change_right_recommendation_reward(double value) {
  _internal_set_lane_change_right_recommendation_reward(value);
  // @@protoc_insertion_point(field_set:planning.eudm.NavigationAssessDetail.lane_change_right_recommendation_reward)
}

// -------------------------------------------------------------------

// CostAssessCfg

// required .planning.eudm.EfficiencyAssessDetail effciency = 1;
inline bool CostAssessCfg::_internal_has_effciency() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || effciency_ != nullptr);
  return value;
}
inline bool CostAssessCfg::has_effciency() const {
  return _internal_has_effciency();
}
inline void CostAssessCfg::clear_effciency() {
  if (effciency_ != nullptr) effciency_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::EfficiencyAssessDetail& CostAssessCfg::_internal_effciency() const {
  const ::planning::eudm::EfficiencyAssessDetail* p = effciency_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::EfficiencyAssessDetail&>(
      ::planning::eudm::_EfficiencyAssessDetail_default_instance_);
}
inline const ::planning::eudm::EfficiencyAssessDetail& CostAssessCfg::effciency() const {
  // @@protoc_insertion_point(field_get:planning.eudm.CostAssessCfg.effciency)
  return _internal_effciency();
}
inline void CostAssessCfg::unsafe_arena_set_allocated_effciency(
    ::planning::eudm::EfficiencyAssessDetail* effciency) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(effciency_);
  }
  effciency_ = effciency;
  if (effciency) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.CostAssessCfg.effciency)
}
inline ::planning::eudm::EfficiencyAssessDetail* CostAssessCfg::release_effciency() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::EfficiencyAssessDetail* temp = effciency_;
  effciency_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::EfficiencyAssessDetail* CostAssessCfg::unsafe_arena_release_effciency() {
  // @@protoc_insertion_point(field_release:planning.eudm.CostAssessCfg.effciency)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::EfficiencyAssessDetail* temp = effciency_;
  effciency_ = nullptr;
  return temp;
}
inline ::planning::eudm::EfficiencyAssessDetail* CostAssessCfg::_internal_mutable_effciency() {
  _has_bits_[0] |= 0x00000001u;
  if (effciency_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::EfficiencyAssessDetail>(GetArena());
    effciency_ = p;
  }
  return effciency_;
}
inline ::planning::eudm::EfficiencyAssessDetail* CostAssessCfg::mutable_effciency() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.CostAssessCfg.effciency)
  return _internal_mutable_effciency();
}
inline void CostAssessCfg::set_allocated_effciency(::planning::eudm::EfficiencyAssessDetail* effciency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete effciency_;
  }
  if (effciency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(effciency);
    if (message_arena != submessage_arena) {
      effciency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, effciency, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  effciency_ = effciency;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.CostAssessCfg.effciency)
}

// required .planning.eudm.SafetyAssessDetail safety = 2;
inline bool CostAssessCfg::_internal_has_safety() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || safety_ != nullptr);
  return value;
}
inline bool CostAssessCfg::has_safety() const {
  return _internal_has_safety();
}
inline void CostAssessCfg::clear_safety() {
  if (safety_ != nullptr) safety_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::SafetyAssessDetail& CostAssessCfg::_internal_safety() const {
  const ::planning::eudm::SafetyAssessDetail* p = safety_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::SafetyAssessDetail&>(
      ::planning::eudm::_SafetyAssessDetail_default_instance_);
}
inline const ::planning::eudm::SafetyAssessDetail& CostAssessCfg::safety() const {
  // @@protoc_insertion_point(field_get:planning.eudm.CostAssessCfg.safety)
  return _internal_safety();
}
inline void CostAssessCfg::unsafe_arena_set_allocated_safety(
    ::planning::eudm::SafetyAssessDetail* safety) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(safety_);
  }
  safety_ = safety;
  if (safety) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.CostAssessCfg.safety)
}
inline ::planning::eudm::SafetyAssessDetail* CostAssessCfg::release_safety() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::SafetyAssessDetail* temp = safety_;
  safety_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::SafetyAssessDetail* CostAssessCfg::unsafe_arena_release_safety() {
  // @@protoc_insertion_point(field_release:planning.eudm.CostAssessCfg.safety)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::SafetyAssessDetail* temp = safety_;
  safety_ = nullptr;
  return temp;
}
inline ::planning::eudm::SafetyAssessDetail* CostAssessCfg::_internal_mutable_safety() {
  _has_bits_[0] |= 0x00000002u;
  if (safety_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::SafetyAssessDetail>(GetArena());
    safety_ = p;
  }
  return safety_;
}
inline ::planning::eudm::SafetyAssessDetail* CostAssessCfg::mutable_safety() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.CostAssessCfg.safety)
  return _internal_mutable_safety();
}
inline void CostAssessCfg::set_allocated_safety(::planning::eudm::SafetyAssessDetail* safety) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete safety_;
  }
  if (safety) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(safety);
    if (message_arena != submessage_arena) {
      safety = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safety, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  safety_ = safety;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.CostAssessCfg.safety)
}

// required .planning.eudm.UserIntentionAssessDetail user = 3;
inline bool CostAssessCfg::_internal_has_user() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || user_ != nullptr);
  return value;
}
inline bool CostAssessCfg::has_user() const {
  return _internal_has_user();
}
inline void CostAssessCfg::clear_user() {
  if (user_ != nullptr) user_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::planning::eudm::UserIntentionAssessDetail& CostAssessCfg::_internal_user() const {
  const ::planning::eudm::UserIntentionAssessDetail* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::UserIntentionAssessDetail&>(
      ::planning::eudm::_UserIntentionAssessDetail_default_instance_);
}
inline const ::planning::eudm::UserIntentionAssessDetail& CostAssessCfg::user() const {
  // @@protoc_insertion_point(field_get:planning.eudm.CostAssessCfg.user)
  return _internal_user();
}
inline void CostAssessCfg::unsafe_arena_set_allocated_user(
    ::planning::eudm::UserIntentionAssessDetail* user) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.CostAssessCfg.user)
}
inline ::planning::eudm::UserIntentionAssessDetail* CostAssessCfg::release_user() {
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::UserIntentionAssessDetail* temp = user_;
  user_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::UserIntentionAssessDetail* CostAssessCfg::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:planning.eudm.CostAssessCfg.user)
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::UserIntentionAssessDetail* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::planning::eudm::UserIntentionAssessDetail* CostAssessCfg::_internal_mutable_user() {
  _has_bits_[0] |= 0x00000004u;
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::UserIntentionAssessDetail>(GetArena());
    user_ = p;
  }
  return user_;
}
inline ::planning::eudm::UserIntentionAssessDetail* CostAssessCfg::mutable_user() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.CostAssessCfg.user)
  return _internal_mutable_user();
}
inline void CostAssessCfg::set_allocated_user(::planning::eudm::UserIntentionAssessDetail* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.CostAssessCfg.user)
}

// required .planning.eudm.NavigationAssessDetail navigation = 4;
inline bool CostAssessCfg::_internal_has_navigation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || navigation_ != nullptr);
  return value;
}
inline bool CostAssessCfg::has_navigation() const {
  return _internal_has_navigation();
}
inline void CostAssessCfg::clear_navigation() {
  if (navigation_ != nullptr) navigation_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::planning::eudm::NavigationAssessDetail& CostAssessCfg::_internal_navigation() const {
  const ::planning::eudm::NavigationAssessDetail* p = navigation_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::NavigationAssessDetail&>(
      ::planning::eudm::_NavigationAssessDetail_default_instance_);
}
inline const ::planning::eudm::NavigationAssessDetail& CostAssessCfg::navigation() const {
  // @@protoc_insertion_point(field_get:planning.eudm.CostAssessCfg.navigation)
  return _internal_navigation();
}
inline void CostAssessCfg::unsafe_arena_set_allocated_navigation(
    ::planning::eudm::NavigationAssessDetail* navigation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(navigation_);
  }
  navigation_ = navigation;
  if (navigation) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.CostAssessCfg.navigation)
}
inline ::planning::eudm::NavigationAssessDetail* CostAssessCfg::release_navigation() {
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::NavigationAssessDetail* temp = navigation_;
  navigation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::NavigationAssessDetail* CostAssessCfg::unsafe_arena_release_navigation() {
  // @@protoc_insertion_point(field_release:planning.eudm.CostAssessCfg.navigation)
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::NavigationAssessDetail* temp = navigation_;
  navigation_ = nullptr;
  return temp;
}
inline ::planning::eudm::NavigationAssessDetail* CostAssessCfg::_internal_mutable_navigation() {
  _has_bits_[0] |= 0x00000008u;
  if (navigation_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::NavigationAssessDetail>(GetArena());
    navigation_ = p;
  }
  return navigation_;
}
inline ::planning::eudm::NavigationAssessDetail* CostAssessCfg::mutable_navigation() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.CostAssessCfg.navigation)
  return _internal_mutable_navigation();
}
inline void CostAssessCfg::set_allocated_navigation(::planning::eudm::NavigationAssessDetail* navigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete navigation_;
  }
  if (navigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(navigation);
    if (message_arena != submessage_arena) {
      navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  navigation_ = navigation;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.CostAssessCfg.navigation)
}

// required double discount_factor = 5;
inline bool CostAssessCfg::_internal_has_discount_factor() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CostAssessCfg::has_discount_factor() const {
  return _internal_has_discount_factor();
}
inline void CostAssessCfg::clear_discount_factor() {
  discount_factor_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CostAssessCfg::_internal_discount_factor() const {
  return discount_factor_;
}
inline double CostAssessCfg::discount_factor() const {
  // @@protoc_insertion_point(field_get:planning.eudm.CostAssessCfg.discount_factor)
  return _internal_discount_factor();
}
inline void CostAssessCfg::_internal_set_discount_factor(double value) {
  _has_bits_[0] |= 0x00000010u;
  discount_factor_ = value;
}
inline void CostAssessCfg::set_discount_factor(double value) {
  _internal_set_discount_factor(value);
  // @@protoc_insertion_point(field_set:planning.eudm.CostAssessCfg.discount_factor)
}

// -------------------------------------------------------------------

// SimDurationDetail

// required double layer = 1;
inline bool SimDurationDetail::_internal_has_layer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimDurationDetail::has_layer() const {
  return _internal_has_layer();
}
inline void SimDurationDetail::clear_layer() {
  layer_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SimDurationDetail::_internal_layer() const {
  return layer_;
}
inline double SimDurationDetail::layer() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimDurationDetail.layer)
  return _internal_layer();
}
inline void SimDurationDetail::_internal_set_layer(double value) {
  _has_bits_[0] |= 0x00000001u;
  layer_ = value;
}
inline void SimDurationDetail::set_layer(double value) {
  _internal_set_layer(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimDurationDetail.layer)
}

// required double last_layer = 2;
inline bool SimDurationDetail::_internal_has_last_layer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimDurationDetail::has_last_layer() const {
  return _internal_has_last_layer();
}
inline void SimDurationDetail::clear_last_layer() {
  last_layer_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SimDurationDetail::_internal_last_layer() const {
  return last_layer_;
}
inline double SimDurationDetail::last_layer() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimDurationDetail.last_layer)
  return _internal_last_layer();
}
inline void SimDurationDetail::_internal_set_last_layer(double value) {
  _has_bits_[0] |= 0x00000002u;
  last_layer_ = value;
}
inline void SimDurationDetail::set_last_layer(double value) {
  _internal_set_last_layer(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimDurationDetail.last_layer)
}

// required double step = 3;
inline bool SimDurationDetail::_internal_has_step() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimDurationDetail::has_step() const {
  return _internal_has_step();
}
inline void SimDurationDetail::clear_step() {
  step_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SimDurationDetail::_internal_step() const {
  return step_;
}
inline double SimDurationDetail::step() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimDurationDetail.step)
  return _internal_step();
}
inline void SimDurationDetail::_internal_set_step(double value) {
  _has_bits_[0] |= 0x00000004u;
  step_ = value;
}
inline void SimDurationDetail::set_step(double value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimDurationDetail.step)
}

// required int32 tree_height = 4;
inline bool SimDurationDetail::_internal_has_tree_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SimDurationDetail::has_tree_height() const {
  return _internal_has_tree_height();
}
inline void SimDurationDetail::clear_tree_height() {
  tree_height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimDurationDetail::_internal_tree_height() const {
  return tree_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SimDurationDetail::tree_height() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimDurationDetail.tree_height)
  return _internal_tree_height();
}
inline void SimDurationDetail::_internal_set_tree_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  tree_height_ = value;
}
inline void SimDurationDetail::set_tree_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tree_height(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimDurationDetail.tree_height)
}

// -------------------------------------------------------------------

// LonSimLimit

// required double acc = 1;
inline bool LonSimLimit::_internal_has_acc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LonSimLimit::has_acc() const {
  return _internal_has_acc();
}
inline void LonSimLimit::clear_acc() {
  acc_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LonSimLimit::_internal_acc() const {
  return acc_;
}
inline double LonSimLimit::acc() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimLimit.acc)
  return _internal_acc();
}
inline void LonSimLimit::_internal_set_acc(double value) {
  _has_bits_[0] |= 0x00000001u;
  acc_ = value;
}
inline void LonSimLimit::set_acc(double value) {
  _internal_set_acc(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimLimit.acc)
}

// required double acc_jerk = 2;
inline bool LonSimLimit::_internal_has_acc_jerk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LonSimLimit::has_acc_jerk() const {
  return _internal_has_acc_jerk();
}
inline void LonSimLimit::clear_acc_jerk() {
  acc_jerk_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LonSimLimit::_internal_acc_jerk() const {
  return acc_jerk_;
}
inline double LonSimLimit::acc_jerk() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimLimit.acc_jerk)
  return _internal_acc_jerk();
}
inline void LonSimLimit::_internal_set_acc_jerk(double value) {
  _has_bits_[0] |= 0x00000002u;
  acc_jerk_ = value;
}
inline void LonSimLimit::set_acc_jerk(double value) {
  _internal_set_acc_jerk(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimLimit.acc_jerk)
}

// required double soft_brake = 3;
inline bool LonSimLimit::_internal_has_soft_brake() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LonSimLimit::has_soft_brake() const {
  return _internal_has_soft_brake();
}
inline void LonSimLimit::clear_soft_brake() {
  soft_brake_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LonSimLimit::_internal_soft_brake() const {
  return soft_brake_;
}
inline double LonSimLimit::soft_brake() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimLimit.soft_brake)
  return _internal_soft_brake();
}
inline void LonSimLimit::_internal_set_soft_brake(double value) {
  _has_bits_[0] |= 0x00000004u;
  soft_brake_ = value;
}
inline void LonSimLimit::set_soft_brake(double value) {
  _internal_set_soft_brake(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimLimit.soft_brake)
}

// required double hard_brake = 4;
inline bool LonSimLimit::_internal_has_hard_brake() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LonSimLimit::has_hard_brake() const {
  return _internal_has_hard_brake();
}
inline void LonSimLimit::clear_hard_brake() {
  hard_brake_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LonSimLimit::_internal_hard_brake() const {
  return hard_brake_;
}
inline double LonSimLimit::hard_brake() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimLimit.hard_brake)
  return _internal_hard_brake();
}
inline void LonSimLimit::_internal_set_hard_brake(double value) {
  _has_bits_[0] |= 0x00000008u;
  hard_brake_ = value;
}
inline void LonSimLimit::set_hard_brake(double value) {
  _internal_set_hard_brake(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimLimit.hard_brake)
}

// required double brake_jerk = 5;
inline bool LonSimLimit::_internal_has_brake_jerk() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LonSimLimit::has_brake_jerk() const {
  return _internal_has_brake_jerk();
}
inline void LonSimLimit::clear_brake_jerk() {
  brake_jerk_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LonSimLimit::_internal_brake_jerk() const {
  return brake_jerk_;
}
inline double LonSimLimit::brake_jerk() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimLimit.brake_jerk)
  return _internal_brake_jerk();
}
inline void LonSimLimit::_internal_set_brake_jerk(double value) {
  _has_bits_[0] |= 0x00000010u;
  brake_jerk_ = value;
}
inline void LonSimLimit::set_brake_jerk(double value) {
  _internal_set_brake_jerk(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimLimit.brake_jerk)
}

// -------------------------------------------------------------------

// LonSimIdm

// required double min_spacing = 1;
inline bool LonSimIdm::_internal_has_min_spacing() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LonSimIdm::has_min_spacing() const {
  return _internal_has_min_spacing();
}
inline void LonSimIdm::clear_min_spacing() {
  min_spacing_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LonSimIdm::_internal_min_spacing() const {
  return min_spacing_;
}
inline double LonSimIdm::min_spacing() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimIdm.min_spacing)
  return _internal_min_spacing();
}
inline void LonSimIdm::_internal_set_min_spacing(double value) {
  _has_bits_[0] |= 0x00000001u;
  min_spacing_ = value;
}
inline void LonSimIdm::set_min_spacing(double value) {
  _internal_set_min_spacing(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimIdm.min_spacing)
}

// required double head_time = 2;
inline bool LonSimIdm::_internal_has_head_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LonSimIdm::has_head_time() const {
  return _internal_has_head_time();
}
inline void LonSimIdm::clear_head_time() {
  head_time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LonSimIdm::_internal_head_time() const {
  return head_time_;
}
inline double LonSimIdm::head_time() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimIdm.head_time)
  return _internal_head_time();
}
inline void LonSimIdm::_internal_set_head_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  head_time_ = value;
}
inline void LonSimIdm::set_head_time(double value) {
  _internal_set_head_time(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimIdm.head_time)
}

// required int32 exponent = 3;
inline bool LonSimIdm::_internal_has_exponent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LonSimIdm::has_exponent() const {
  return _internal_has_exponent();
}
inline void LonSimIdm::clear_exponent() {
  exponent_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LonSimIdm::_internal_exponent() const {
  return exponent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LonSimIdm::exponent() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimIdm.exponent)
  return _internal_exponent();
}
inline void LonSimIdm::_internal_set_exponent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  exponent_ = value;
}
inline void LonSimIdm::set_exponent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_exponent(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LonSimIdm.exponent)
}

// -------------------------------------------------------------------

// LonSimDetail

// required .planning.eudm.LonSimIdm idm = 1;
inline bool LonSimDetail::_internal_has_idm() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || idm_ != nullptr);
  return value;
}
inline bool LonSimDetail::has_idm() const {
  return _internal_has_idm();
}
inline void LonSimDetail::clear_idm() {
  if (idm_ != nullptr) idm_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::LonSimIdm& LonSimDetail::_internal_idm() const {
  const ::planning::eudm::LonSimIdm* p = idm_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LonSimIdm&>(
      ::planning::eudm::_LonSimIdm_default_instance_);
}
inline const ::planning::eudm::LonSimIdm& LonSimDetail::idm() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimDetail.idm)
  return _internal_idm();
}
inline void LonSimDetail::unsafe_arena_set_allocated_idm(
    ::planning::eudm::LonSimIdm* idm) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(idm_);
  }
  idm_ = idm;
  if (idm) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.LonSimDetail.idm)
}
inline ::planning::eudm::LonSimIdm* LonSimDetail::release_idm() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LonSimIdm* temp = idm_;
  idm_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LonSimIdm* LonSimDetail::unsafe_arena_release_idm() {
  // @@protoc_insertion_point(field_release:planning.eudm.LonSimDetail.idm)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LonSimIdm* temp = idm_;
  idm_ = nullptr;
  return temp;
}
inline ::planning::eudm::LonSimIdm* LonSimDetail::_internal_mutable_idm() {
  _has_bits_[0] |= 0x00000001u;
  if (idm_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LonSimIdm>(GetArena());
    idm_ = p;
  }
  return idm_;
}
inline ::planning::eudm::LonSimIdm* LonSimDetail::mutable_idm() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.LonSimDetail.idm)
  return _internal_mutable_idm();
}
inline void LonSimDetail::set_allocated_idm(::planning::eudm::LonSimIdm* idm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete idm_;
  }
  if (idm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(idm);
    if (message_arena != submessage_arena) {
      idm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, idm, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  idm_ = idm;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.LonSimDetail.idm)
}

// required .planning.eudm.LonSimLimit limit = 2;
inline bool LonSimDetail::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || limit_ != nullptr);
  return value;
}
inline bool LonSimDetail::has_limit() const {
  return _internal_has_limit();
}
inline void LonSimDetail::clear_limit() {
  if (limit_ != nullptr) limit_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::LonSimLimit& LonSimDetail::_internal_limit() const {
  const ::planning::eudm::LonSimLimit* p = limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LonSimLimit&>(
      ::planning::eudm::_LonSimLimit_default_instance_);
}
inline const ::planning::eudm::LonSimLimit& LonSimDetail::limit() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LonSimDetail.limit)
  return _internal_limit();
}
inline void LonSimDetail::unsafe_arena_set_allocated_limit(
    ::planning::eudm::LonSimLimit* limit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_);
  }
  limit_ = limit;
  if (limit) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.LonSimDetail.limit)
}
inline ::planning::eudm::LonSimLimit* LonSimDetail::release_limit() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LonSimLimit* temp = limit_;
  limit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LonSimLimit* LonSimDetail::unsafe_arena_release_limit() {
  // @@protoc_insertion_point(field_release:planning.eudm.LonSimDetail.limit)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LonSimLimit* temp = limit_;
  limit_ = nullptr;
  return temp;
}
inline ::planning::eudm::LonSimLimit* LonSimDetail::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000002u;
  if (limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LonSimLimit>(GetArena());
    limit_ = p;
  }
  return limit_;
}
inline ::planning::eudm::LonSimLimit* LonSimDetail::mutable_limit() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.LonSimDetail.limit)
  return _internal_mutable_limit();
}
inline void LonSimDetail::set_allocated_limit(::planning::eudm::LonSimLimit* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete limit_;
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(limit);
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.LonSimDetail.limit)
}

// -------------------------------------------------------------------

// LatSimLimit

// required double acc = 1;
inline bool LatSimLimit::_internal_has_acc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LatSimLimit::has_acc() const {
  return _internal_has_acc();
}
inline void LatSimLimit::clear_acc() {
  acc_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LatSimLimit::_internal_acc() const {
  return acc_;
}
inline double LatSimLimit::acc() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimLimit.acc)
  return _internal_acc();
}
inline void LatSimLimit::_internal_set_acc(double value) {
  _has_bits_[0] |= 0x00000001u;
  acc_ = value;
}
inline void LatSimLimit::set_acc(double value) {
  _internal_set_acc(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimLimit.acc)
}

// required double jerk = 2;
inline bool LatSimLimit::_internal_has_jerk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LatSimLimit::has_jerk() const {
  return _internal_has_jerk();
}
inline void LatSimLimit::clear_jerk() {
  jerk_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LatSimLimit::_internal_jerk() const {
  return jerk_;
}
inline double LatSimLimit::jerk() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimLimit.jerk)
  return _internal_jerk();
}
inline void LatSimLimit::_internal_set_jerk(double value) {
  _has_bits_[0] |= 0x00000002u;
  jerk_ = value;
}
inline void LatSimLimit::set_jerk(double value) {
  _internal_set_jerk(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimLimit.jerk)
}

// required double curvature = 3;
inline bool LatSimLimit::_internal_has_curvature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LatSimLimit::has_curvature() const {
  return _internal_has_curvature();
}
inline void LatSimLimit::clear_curvature() {
  curvature_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LatSimLimit::_internal_curvature() const {
  return curvature_;
}
inline double LatSimLimit::curvature() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimLimit.curvature)
  return _internal_curvature();
}
inline void LatSimLimit::_internal_set_curvature(double value) {
  _has_bits_[0] |= 0x00000004u;
  curvature_ = value;
}
inline void LatSimLimit::set_curvature(double value) {
  _internal_set_curvature(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimLimit.curvature)
}

// required double steer_angle = 4;
inline bool LatSimLimit::_internal_has_steer_angle() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LatSimLimit::has_steer_angle() const {
  return _internal_has_steer_angle();
}
inline void LatSimLimit::clear_steer_angle() {
  steer_angle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double LatSimLimit::_internal_steer_angle() const {
  return steer_angle_;
}
inline double LatSimLimit::steer_angle() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimLimit.steer_angle)
  return _internal_steer_angle();
}
inline void LatSimLimit::_internal_set_steer_angle(double value) {
  _has_bits_[0] |= 0x00000008u;
  steer_angle_ = value;
}
inline void LatSimLimit::set_steer_angle(double value) {
  _internal_set_steer_angle(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimLimit.steer_angle)
}

// required double steer_rate = 5;
inline bool LatSimLimit::_internal_has_steer_rate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LatSimLimit::has_steer_rate() const {
  return _internal_has_steer_rate();
}
inline void LatSimLimit::clear_steer_rate() {
  steer_rate_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double LatSimLimit::_internal_steer_rate() const {
  return steer_rate_;
}
inline double LatSimLimit::steer_rate() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimLimit.steer_rate)
  return _internal_steer_rate();
}
inline void LatSimLimit::_internal_set_steer_rate(double value) {
  _has_bits_[0] |= 0x00000010u;
  steer_rate_ = value;
}
inline void LatSimLimit::set_steer_rate(double value) {
  _internal_set_steer_rate(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimLimit.steer_rate)
}

// -------------------------------------------------------------------

// LatSimPurePursuit

// required double gain = 1;
inline bool LatSimPurePursuit::_internal_has_gain() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LatSimPurePursuit::has_gain() const {
  return _internal_has_gain();
}
inline void LatSimPurePursuit::clear_gain() {
  gain_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LatSimPurePursuit::_internal_gain() const {
  return gain_;
}
inline double LatSimPurePursuit::gain() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimPurePursuit.gain)
  return _internal_gain();
}
inline void LatSimPurePursuit::_internal_set_gain(double value) {
  _has_bits_[0] |= 0x00000001u;
  gain_ = value;
}
inline void LatSimPurePursuit::set_gain(double value) {
  _internal_set_gain(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimPurePursuit.gain)
}

// required double max_lookahead_dist = 2;
inline bool LatSimPurePursuit::_internal_has_max_lookahead_dist() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LatSimPurePursuit::has_max_lookahead_dist() const {
  return _internal_has_max_lookahead_dist();
}
inline void LatSimPurePursuit::clear_max_lookahead_dist() {
  max_lookahead_dist_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LatSimPurePursuit::_internal_max_lookahead_dist() const {
  return max_lookahead_dist_;
}
inline double LatSimPurePursuit::max_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimPurePursuit.max_lookahead_dist)
  return _internal_max_lookahead_dist();
}
inline void LatSimPurePursuit::_internal_set_max_lookahead_dist(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_lookahead_dist_ = value;
}
inline void LatSimPurePursuit::set_max_lookahead_dist(double value) {
  _internal_set_max_lookahead_dist(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimPurePursuit.max_lookahead_dist)
}

// required double min_lookahead_dist = 3;
inline bool LatSimPurePursuit::_internal_has_min_lookahead_dist() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LatSimPurePursuit::has_min_lookahead_dist() const {
  return _internal_has_min_lookahead_dist();
}
inline void LatSimPurePursuit::clear_min_lookahead_dist() {
  min_lookahead_dist_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LatSimPurePursuit::_internal_min_lookahead_dist() const {
  return min_lookahead_dist_;
}
inline double LatSimPurePursuit::min_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimPurePursuit.min_lookahead_dist)
  return _internal_min_lookahead_dist();
}
inline void LatSimPurePursuit::_internal_set_min_lookahead_dist(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_lookahead_dist_ = value;
}
inline void LatSimPurePursuit::set_min_lookahead_dist(double value) {
  _internal_set_min_lookahead_dist(value);
  // @@protoc_insertion_point(field_set:planning.eudm.LatSimPurePursuit.min_lookahead_dist)
}

// -------------------------------------------------------------------

// LatSimDetail

// required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
inline bool LatSimDetail::_internal_has_pure_pursuit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pure_pursuit_ != nullptr);
  return value;
}
inline bool LatSimDetail::has_pure_pursuit() const {
  return _internal_has_pure_pursuit();
}
inline void LatSimDetail::clear_pure_pursuit() {
  if (pure_pursuit_ != nullptr) pure_pursuit_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::LatSimPurePursuit& LatSimDetail::_internal_pure_pursuit() const {
  const ::planning::eudm::LatSimPurePursuit* p = pure_pursuit_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LatSimPurePursuit&>(
      ::planning::eudm::_LatSimPurePursuit_default_instance_);
}
inline const ::planning::eudm::LatSimPurePursuit& LatSimDetail::pure_pursuit() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimDetail.pure_pursuit)
  return _internal_pure_pursuit();
}
inline void LatSimDetail::unsafe_arena_set_allocated_pure_pursuit(
    ::planning::eudm::LatSimPurePursuit* pure_pursuit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pure_pursuit_);
  }
  pure_pursuit_ = pure_pursuit;
  if (pure_pursuit) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.LatSimDetail.pure_pursuit)
}
inline ::planning::eudm::LatSimPurePursuit* LatSimDetail::release_pure_pursuit() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LatSimPurePursuit* temp = pure_pursuit_;
  pure_pursuit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LatSimPurePursuit* LatSimDetail::unsafe_arena_release_pure_pursuit() {
  // @@protoc_insertion_point(field_release:planning.eudm.LatSimDetail.pure_pursuit)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LatSimPurePursuit* temp = pure_pursuit_;
  pure_pursuit_ = nullptr;
  return temp;
}
inline ::planning::eudm::LatSimPurePursuit* LatSimDetail::_internal_mutable_pure_pursuit() {
  _has_bits_[0] |= 0x00000001u;
  if (pure_pursuit_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LatSimPurePursuit>(GetArena());
    pure_pursuit_ = p;
  }
  return pure_pursuit_;
}
inline ::planning::eudm::LatSimPurePursuit* LatSimDetail::mutable_pure_pursuit() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.LatSimDetail.pure_pursuit)
  return _internal_mutable_pure_pursuit();
}
inline void LatSimDetail::set_allocated_pure_pursuit(::planning::eudm::LatSimPurePursuit* pure_pursuit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pure_pursuit_;
  }
  if (pure_pursuit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pure_pursuit);
    if (message_arena != submessage_arena) {
      pure_pursuit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pure_pursuit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pure_pursuit_ = pure_pursuit;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.LatSimDetail.pure_pursuit)
}

// required .planning.eudm.LatSimLimit limit = 2;
inline bool LatSimDetail::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || limit_ != nullptr);
  return value;
}
inline bool LatSimDetail::has_limit() const {
  return _internal_has_limit();
}
inline void LatSimDetail::clear_limit() {
  if (limit_ != nullptr) limit_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::LatSimLimit& LatSimDetail::_internal_limit() const {
  const ::planning::eudm::LatSimLimit* p = limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LatSimLimit&>(
      ::planning::eudm::_LatSimLimit_default_instance_);
}
inline const ::planning::eudm::LatSimLimit& LatSimDetail::limit() const {
  // @@protoc_insertion_point(field_get:planning.eudm.LatSimDetail.limit)
  return _internal_limit();
}
inline void LatSimDetail::unsafe_arena_set_allocated_limit(
    ::planning::eudm::LatSimLimit* limit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_);
  }
  limit_ = limit;
  if (limit) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.LatSimDetail.limit)
}
inline ::planning::eudm::LatSimLimit* LatSimDetail::release_limit() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LatSimLimit* temp = limit_;
  limit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LatSimLimit* LatSimDetail::unsafe_arena_release_limit() {
  // @@protoc_insertion_point(field_release:planning.eudm.LatSimDetail.limit)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LatSimLimit* temp = limit_;
  limit_ = nullptr;
  return temp;
}
inline ::planning::eudm::LatSimLimit* LatSimDetail::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000002u;
  if (limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LatSimLimit>(GetArena());
    limit_ = p;
  }
  return limit_;
}
inline ::planning::eudm::LatSimLimit* LatSimDetail::mutable_limit() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.LatSimDetail.limit)
  return _internal_mutable_limit();
}
inline void LatSimDetail::set_allocated_limit(::planning::eudm::LatSimLimit* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete limit_;
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(limit);
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.LatSimDetail.limit)
}

// -------------------------------------------------------------------

// EvasiveSimDetail

// required bool evasive_enable = 1;
inline bool EvasiveSimDetail::_internal_has_evasive_enable() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_evasive_enable() const {
  return _internal_has_evasive_enable();
}
inline void EvasiveSimDetail::clear_evasive_enable() {
  evasive_enable_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool EvasiveSimDetail::_internal_evasive_enable() const {
  return evasive_enable_;
}
inline bool EvasiveSimDetail::evasive_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.evasive_enable)
  return _internal_evasive_enable();
}
inline void EvasiveSimDetail::_internal_set_evasive_enable(bool value) {
  _has_bits_[0] |= 0x00000020u;
  evasive_enable_ = value;
}
inline void EvasiveSimDetail::set_evasive_enable(bool value) {
  _internal_set_evasive_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.evasive_enable)
}

// required double lon_acc = 2;
inline bool EvasiveSimDetail::_internal_has_lon_acc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_lon_acc() const {
  return _internal_has_lon_acc();
}
inline void EvasiveSimDetail::clear_lon_acc() {
  lon_acc_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double EvasiveSimDetail::_internal_lon_acc() const {
  return lon_acc_;
}
inline double EvasiveSimDetail::lon_acc() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.lon_acc)
  return _internal_lon_acc();
}
inline void EvasiveSimDetail::_internal_set_lon_acc(double value) {
  _has_bits_[0] |= 0x00000001u;
  lon_acc_ = value;
}
inline void EvasiveSimDetail::set_lon_acc(double value) {
  _internal_set_lon_acc(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.lon_acc)
}

// required double lon_jerk = 3;
inline bool EvasiveSimDetail::_internal_has_lon_jerk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_lon_jerk() const {
  return _internal_has_lon_jerk();
}
inline void EvasiveSimDetail::clear_lon_jerk() {
  lon_jerk_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double EvasiveSimDetail::_internal_lon_jerk() const {
  return lon_jerk_;
}
inline double EvasiveSimDetail::lon_jerk() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.lon_jerk)
  return _internal_lon_jerk();
}
inline void EvasiveSimDetail::_internal_set_lon_jerk(double value) {
  _has_bits_[0] |= 0x00000002u;
  lon_jerk_ = value;
}
inline void EvasiveSimDetail::set_lon_jerk(double value) {
  _internal_set_lon_jerk(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.lon_jerk)
}

// required double lon_extraspeed = 4;
inline bool EvasiveSimDetail::_internal_has_lon_extraspeed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_lon_extraspeed() const {
  return _internal_has_lon_extraspeed();
}
inline void EvasiveSimDetail::clear_lon_extraspeed() {
  lon_extraspeed_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double EvasiveSimDetail::_internal_lon_extraspeed() const {
  return lon_extraspeed_;
}
inline double EvasiveSimDetail::lon_extraspeed() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.lon_extraspeed)
  return _internal_lon_extraspeed();
}
inline void EvasiveSimDetail::_internal_set_lon_extraspeed(double value) {
  _has_bits_[0] |= 0x00000004u;
  lon_extraspeed_ = value;
}
inline void EvasiveSimDetail::set_lon_extraspeed(double value) {
  _internal_set_lon_extraspeed(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.lon_extraspeed)
}

// required double head_time = 5;
inline bool EvasiveSimDetail::_internal_has_head_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_head_time() const {
  return _internal_has_head_time();
}
inline void EvasiveSimDetail::clear_head_time() {
  head_time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double EvasiveSimDetail::_internal_head_time() const {
  return head_time_;
}
inline double EvasiveSimDetail::head_time() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.head_time)
  return _internal_head_time();
}
inline void EvasiveSimDetail::_internal_set_head_time(double value) {
  _has_bits_[0] |= 0x00000008u;
  head_time_ = value;
}
inline void EvasiveSimDetail::set_head_time(double value) {
  _internal_set_head_time(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.head_time)
}

// required bool virtual_barrier_enable = 6;
inline bool EvasiveSimDetail::_internal_has_virtual_barrier_enable() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_virtual_barrier_enable() const {
  return _internal_has_virtual_barrier_enable();
}
inline void EvasiveSimDetail::clear_virtual_barrier_enable() {
  virtual_barrier_enable_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool EvasiveSimDetail::_internal_virtual_barrier_enable() const {
  return virtual_barrier_enable_;
}
inline bool EvasiveSimDetail::virtual_barrier_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.virtual_barrier_enable)
  return _internal_virtual_barrier_enable();
}
inline void EvasiveSimDetail::_internal_set_virtual_barrier_enable(bool value) {
  _has_bits_[0] |= 0x00000040u;
  virtual_barrier_enable_ = value;
}
inline void EvasiveSimDetail::set_virtual_barrier_enable(bool value) {
  _internal_set_virtual_barrier_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.virtual_barrier_enable)
}

// required double virtual_barrier_tic = 7;
inline bool EvasiveSimDetail::_internal_has_virtual_barrier_tic() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EvasiveSimDetail::has_virtual_barrier_tic() const {
  return _internal_has_virtual_barrier_tic();
}
inline void EvasiveSimDetail::clear_virtual_barrier_tic() {
  virtual_barrier_tic_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double EvasiveSimDetail::_internal_virtual_barrier_tic() const {
  return virtual_barrier_tic_;
}
inline double EvasiveSimDetail::virtual_barrier_tic() const {
  // @@protoc_insertion_point(field_get:planning.eudm.EvasiveSimDetail.virtual_barrier_tic)
  return _internal_virtual_barrier_tic();
}
inline void EvasiveSimDetail::_internal_set_virtual_barrier_tic(double value) {
  _has_bits_[0] |= 0x00000010u;
  virtual_barrier_tic_ = value;
}
inline void EvasiveSimDetail::set_virtual_barrier_tic(double value) {
  _internal_set_virtual_barrier_tic(value);
  // @@protoc_insertion_point(field_set:planning.eudm.EvasiveSimDetail.virtual_barrier_tic)
}

// -------------------------------------------------------------------

// ForwardSimDetail

// required .planning.eudm.LonSimDetail lon = 1;
inline bool ForwardSimDetail::_internal_has_lon() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || lon_ != nullptr);
  return value;
}
inline bool ForwardSimDetail::has_lon() const {
  return _internal_has_lon();
}
inline void ForwardSimDetail::clear_lon() {
  if (lon_ != nullptr) lon_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::LonSimDetail& ForwardSimDetail::_internal_lon() const {
  const ::planning::eudm::LonSimDetail* p = lon_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LonSimDetail&>(
      ::planning::eudm::_LonSimDetail_default_instance_);
}
inline const ::planning::eudm::LonSimDetail& ForwardSimDetail::lon() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.lon)
  return _internal_lon();
}
inline void ForwardSimDetail::unsafe_arena_set_allocated_lon(
    ::planning::eudm::LonSimDetail* lon) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lon_);
  }
  lon_ = lon;
  if (lon) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.ForwardSimDetail.lon)
}
inline ::planning::eudm::LonSimDetail* ForwardSimDetail::release_lon() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LonSimDetail* temp = lon_;
  lon_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LonSimDetail* ForwardSimDetail::unsafe_arena_release_lon() {
  // @@protoc_insertion_point(field_release:planning.eudm.ForwardSimDetail.lon)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::LonSimDetail* temp = lon_;
  lon_ = nullptr;
  return temp;
}
inline ::planning::eudm::LonSimDetail* ForwardSimDetail::_internal_mutable_lon() {
  _has_bits_[0] |= 0x00000001u;
  if (lon_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LonSimDetail>(GetArena());
    lon_ = p;
  }
  return lon_;
}
inline ::planning::eudm::LonSimDetail* ForwardSimDetail::mutable_lon() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.ForwardSimDetail.lon)
  return _internal_mutable_lon();
}
inline void ForwardSimDetail::set_allocated_lon(::planning::eudm::LonSimDetail* lon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lon_;
  }
  if (lon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lon);
    if (message_arena != submessage_arena) {
      lon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lon, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lon_ = lon;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.ForwardSimDetail.lon)
}

// required .planning.eudm.LatSimDetail lat = 2;
inline bool ForwardSimDetail::_internal_has_lat() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || lat_ != nullptr);
  return value;
}
inline bool ForwardSimDetail::has_lat() const {
  return _internal_has_lat();
}
inline void ForwardSimDetail::clear_lat() {
  if (lat_ != nullptr) lat_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::LatSimDetail& ForwardSimDetail::_internal_lat() const {
  const ::planning::eudm::LatSimDetail* p = lat_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::LatSimDetail&>(
      ::planning::eudm::_LatSimDetail_default_instance_);
}
inline const ::planning::eudm::LatSimDetail& ForwardSimDetail::lat() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.lat)
  return _internal_lat();
}
inline void ForwardSimDetail::unsafe_arena_set_allocated_lat(
    ::planning::eudm::LatSimDetail* lat) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lat_);
  }
  lat_ = lat;
  if (lat) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.ForwardSimDetail.lat)
}
inline ::planning::eudm::LatSimDetail* ForwardSimDetail::release_lat() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LatSimDetail* temp = lat_;
  lat_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::LatSimDetail* ForwardSimDetail::unsafe_arena_release_lat() {
  // @@protoc_insertion_point(field_release:planning.eudm.ForwardSimDetail.lat)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::LatSimDetail* temp = lat_;
  lat_ = nullptr;
  return temp;
}
inline ::planning::eudm::LatSimDetail* ForwardSimDetail::_internal_mutable_lat() {
  _has_bits_[0] |= 0x00000002u;
  if (lat_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::LatSimDetail>(GetArena());
    lat_ = p;
  }
  return lat_;
}
inline ::planning::eudm::LatSimDetail* ForwardSimDetail::mutable_lat() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.ForwardSimDetail.lat)
  return _internal_mutable_lat();
}
inline void ForwardSimDetail::set_allocated_lat(::planning::eudm::LatSimDetail* lat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lat_;
  }
  if (lat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lat);
    if (message_arena != submessage_arena) {
      lat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lat_ = lat;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.ForwardSimDetail.lat)
}

// required .planning.eudm.EvasiveSimDetail evasive = 3;
inline bool ForwardSimDetail::_internal_has_evasive() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || evasive_ != nullptr);
  return value;
}
inline bool ForwardSimDetail::has_evasive() const {
  return _internal_has_evasive();
}
inline void ForwardSimDetail::clear_evasive() {
  if (evasive_ != nullptr) evasive_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::planning::eudm::EvasiveSimDetail& ForwardSimDetail::_internal_evasive() const {
  const ::planning::eudm::EvasiveSimDetail* p = evasive_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::EvasiveSimDetail&>(
      ::planning::eudm::_EvasiveSimDetail_default_instance_);
}
inline const ::planning::eudm::EvasiveSimDetail& ForwardSimDetail::evasive() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.evasive)
  return _internal_evasive();
}
inline void ForwardSimDetail::unsafe_arena_set_allocated_evasive(
    ::planning::eudm::EvasiveSimDetail* evasive) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(evasive_);
  }
  evasive_ = evasive;
  if (evasive) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.ForwardSimDetail.evasive)
}
inline ::planning::eudm::EvasiveSimDetail* ForwardSimDetail::release_evasive() {
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::EvasiveSimDetail* temp = evasive_;
  evasive_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::EvasiveSimDetail* ForwardSimDetail::unsafe_arena_release_evasive() {
  // @@protoc_insertion_point(field_release:planning.eudm.ForwardSimDetail.evasive)
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::EvasiveSimDetail* temp = evasive_;
  evasive_ = nullptr;
  return temp;
}
inline ::planning::eudm::EvasiveSimDetail* ForwardSimDetail::_internal_mutable_evasive() {
  _has_bits_[0] |= 0x00000004u;
  if (evasive_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::EvasiveSimDetail>(GetArena());
    evasive_ = p;
  }
  return evasive_;
}
inline ::planning::eudm::EvasiveSimDetail* ForwardSimDetail::mutable_evasive() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.ForwardSimDetail.evasive)
  return _internal_mutable_evasive();
}
inline void ForwardSimDetail::set_allocated_evasive(::planning::eudm::EvasiveSimDetail* evasive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete evasive_;
  }
  if (evasive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(evasive);
    if (message_arena != submessage_arena) {
      evasive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, evasive, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  evasive_ = evasive;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.ForwardSimDetail.evasive)
}

// required bool auto_dec_if_lat_failed = 4;
inline bool ForwardSimDetail::_internal_has_auto_dec_if_lat_failed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ForwardSimDetail::has_auto_dec_if_lat_failed() const {
  return _internal_has_auto_dec_if_lat_failed();
}
inline void ForwardSimDetail::clear_auto_dec_if_lat_failed() {
  auto_dec_if_lat_failed_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ForwardSimDetail::_internal_auto_dec_if_lat_failed() const {
  return auto_dec_if_lat_failed_;
}
inline bool ForwardSimDetail::auto_dec_if_lat_failed() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.auto_dec_if_lat_failed)
  return _internal_auto_dec_if_lat_failed();
}
inline void ForwardSimDetail::_internal_set_auto_dec_if_lat_failed(bool value) {
  _has_bits_[0] |= 0x00000020u;
  auto_dec_if_lat_failed_ = value;
}
inline void ForwardSimDetail::set_auto_dec_if_lat_failed(bool value) {
  _internal_set_auto_dec_if_lat_failed(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ForwardSimDetail.auto_dec_if_lat_failed)
}

// required double cooperative_lat_range = 5;
inline bool ForwardSimDetail::_internal_has_cooperative_lat_range() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ForwardSimDetail::has_cooperative_lat_range() const {
  return _internal_has_cooperative_lat_range();
}
inline void ForwardSimDetail::clear_cooperative_lat_range() {
  cooperative_lat_range_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ForwardSimDetail::_internal_cooperative_lat_range() const {
  return cooperative_lat_range_;
}
inline double ForwardSimDetail::cooperative_lat_range() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.cooperative_lat_range)
  return _internal_cooperative_lat_range();
}
inline void ForwardSimDetail::_internal_set_cooperative_lat_range(double value) {
  _has_bits_[0] |= 0x00000008u;
  cooperative_lat_range_ = value;
}
inline void ForwardSimDetail::set_cooperative_lat_range(double value) {
  _internal_set_cooperative_lat_range(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ForwardSimDetail.cooperative_lat_range)
}

// required double lon_aggressive_ratio = 6;
inline bool ForwardSimDetail::_internal_has_lon_aggressive_ratio() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ForwardSimDetail::has_lon_aggressive_ratio() const {
  return _internal_has_lon_aggressive_ratio();
}
inline void ForwardSimDetail::clear_lon_aggressive_ratio() {
  lon_aggressive_ratio_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ForwardSimDetail::_internal_lon_aggressive_ratio() const {
  return lon_aggressive_ratio_;
}
inline double ForwardSimDetail::lon_aggressive_ratio() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ForwardSimDetail.lon_aggressive_ratio)
  return _internal_lon_aggressive_ratio();
}
inline void ForwardSimDetail::_internal_set_lon_aggressive_ratio(double value) {
  _has_bits_[0] |= 0x00000010u;
  lon_aggressive_ratio_ = value;
}
inline void ForwardSimDetail::set_lon_aggressive_ratio(double value) {
  _internal_set_lon_aggressive_ratio(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ForwardSimDetail.lon_aggressive_ratio)
}

// -------------------------------------------------------------------

// SimRefLine

// required double len_vel_coeff = 1;
inline bool SimRefLine::_internal_has_len_vel_coeff() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimRefLine::has_len_vel_coeff() const {
  return _internal_has_len_vel_coeff();
}
inline void SimRefLine::clear_len_vel_coeff() {
  len_vel_coeff_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SimRefLine::_internal_len_vel_coeff() const {
  return len_vel_coeff_;
}
inline double SimRefLine::len_vel_coeff() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimRefLine.len_vel_coeff)
  return _internal_len_vel_coeff();
}
inline void SimRefLine::_internal_set_len_vel_coeff(double value) {
  _has_bits_[0] |= 0x00000001u;
  len_vel_coeff_ = value;
}
inline void SimRefLine::set_len_vel_coeff(double value) {
  _internal_set_len_vel_coeff(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimRefLine.len_vel_coeff)
}

// required double forward_len_max = 2;
inline bool SimRefLine::_internal_has_forward_len_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimRefLine::has_forward_len_max() const {
  return _internal_has_forward_len_max();
}
inline void SimRefLine::clear_forward_len_max() {
  forward_len_max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SimRefLine::_internal_forward_len_max() const {
  return forward_len_max_;
}
inline double SimRefLine::forward_len_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimRefLine.forward_len_max)
  return _internal_forward_len_max();
}
inline void SimRefLine::_internal_set_forward_len_max(double value) {
  _has_bits_[0] |= 0x00000002u;
  forward_len_max_ = value;
}
inline void SimRefLine::set_forward_len_max(double value) {
  _internal_set_forward_len_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimRefLine.forward_len_max)
}

// required double forward_len_min = 3;
inline bool SimRefLine::_internal_has_forward_len_min() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimRefLine::has_forward_len_min() const {
  return _internal_has_forward_len_min();
}
inline void SimRefLine::clear_forward_len_min() {
  forward_len_min_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SimRefLine::_internal_forward_len_min() const {
  return forward_len_min_;
}
inline double SimRefLine::forward_len_min() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimRefLine.forward_len_min)
  return _internal_forward_len_min();
}
inline void SimRefLine::_internal_set_forward_len_min(double value) {
  _has_bits_[0] |= 0x00000004u;
  forward_len_min_ = value;
}
inline void SimRefLine::set_forward_len_min(double value) {
  _internal_set_forward_len_min(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimRefLine.forward_len_min)
}

// required double backward_len_max = 4;
inline bool SimRefLine::_internal_has_backward_len_max() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SimRefLine::has_backward_len_max() const {
  return _internal_has_backward_len_max();
}
inline void SimRefLine::clear_backward_len_max() {
  backward_len_max_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SimRefLine::_internal_backward_len_max() const {
  return backward_len_max_;
}
inline double SimRefLine::backward_len_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimRefLine.backward_len_max)
  return _internal_backward_len_max();
}
inline void SimRefLine::_internal_set_backward_len_max(double value) {
  _has_bits_[0] |= 0x00000008u;
  backward_len_max_ = value;
}
inline void SimRefLine::set_backward_len_max(double value) {
  _internal_set_backward_len_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimRefLine.backward_len_max)
}

// -------------------------------------------------------------------

// SimCfg

// required .planning.eudm.SimDurationDetail duration = 1;
inline bool SimCfg::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || duration_ != nullptr);
  return value;
}
inline bool SimCfg::has_duration() const {
  return _internal_has_duration();
}
inline void SimCfg::clear_duration() {
  if (duration_ != nullptr) duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::SimDurationDetail& SimCfg::_internal_duration() const {
  const ::planning::eudm::SimDurationDetail* p = duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::SimDurationDetail&>(
      ::planning::eudm::_SimDurationDetail_default_instance_);
}
inline const ::planning::eudm::SimDurationDetail& SimCfg::duration() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.duration)
  return _internal_duration();
}
inline void SimCfg::unsafe_arena_set_allocated_duration(
    ::planning::eudm::SimDurationDetail* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SimCfg.duration)
}
inline ::planning::eudm::SimDurationDetail* SimCfg::release_duration() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::SimDurationDetail* temp = duration_;
  duration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::SimDurationDetail* SimCfg::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:planning.eudm.SimCfg.duration)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::SimDurationDetail* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline ::planning::eudm::SimDurationDetail* SimCfg::_internal_mutable_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::SimDurationDetail>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline ::planning::eudm::SimDurationDetail* SimCfg::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SimCfg.duration)
  return _internal_mutable_duration();
}
inline void SimCfg::set_allocated_duration(::planning::eudm::SimDurationDetail* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SimCfg.duration)
}

// required .planning.eudm.ForwardSimDetail ego = 2;
inline bool SimCfg::_internal_has_ego() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ego_ != nullptr);
  return value;
}
inline bool SimCfg::has_ego() const {
  return _internal_has_ego();
}
inline void SimCfg::clear_ego() {
  if (ego_ != nullptr) ego_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::ForwardSimDetail& SimCfg::_internal_ego() const {
  const ::planning::eudm::ForwardSimDetail* p = ego_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::ForwardSimDetail&>(
      ::planning::eudm::_ForwardSimDetail_default_instance_);
}
inline const ::planning::eudm::ForwardSimDetail& SimCfg::ego() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.ego)
  return _internal_ego();
}
inline void SimCfg::unsafe_arena_set_allocated_ego(
    ::planning::eudm::ForwardSimDetail* ego) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ego_);
  }
  ego_ = ego;
  if (ego) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SimCfg.ego)
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::release_ego() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::ForwardSimDetail* temp = ego_;
  ego_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::unsafe_arena_release_ego() {
  // @@protoc_insertion_point(field_release:planning.eudm.SimCfg.ego)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::ForwardSimDetail* temp = ego_;
  ego_ = nullptr;
  return temp;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::_internal_mutable_ego() {
  _has_bits_[0] |= 0x00000002u;
  if (ego_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::ForwardSimDetail>(GetArena());
    ego_ = p;
  }
  return ego_;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::mutable_ego() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SimCfg.ego)
  return _internal_mutable_ego();
}
inline void SimCfg::set_allocated_ego(::planning::eudm::ForwardSimDetail* ego) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ego_;
  }
  if (ego) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ego);
    if (message_arena != submessage_arena) {
      ego = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ego, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ego_ = ego;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SimCfg.ego)
}

// required .planning.eudm.ForwardSimDetail agent = 3;
inline bool SimCfg::_internal_has_agent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || agent_ != nullptr);
  return value;
}
inline bool SimCfg::has_agent() const {
  return _internal_has_agent();
}
inline void SimCfg::clear_agent() {
  if (agent_ != nullptr) agent_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::planning::eudm::ForwardSimDetail& SimCfg::_internal_agent() const {
  const ::planning::eudm::ForwardSimDetail* p = agent_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::ForwardSimDetail&>(
      ::planning::eudm::_ForwardSimDetail_default_instance_);
}
inline const ::planning::eudm::ForwardSimDetail& SimCfg::agent() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.agent)
  return _internal_agent();
}
inline void SimCfg::unsafe_arena_set_allocated_agent(
    ::planning::eudm::ForwardSimDetail* agent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(agent_);
  }
  agent_ = agent;
  if (agent) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SimCfg.agent)
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::release_agent() {
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::ForwardSimDetail* temp = agent_;
  agent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::unsafe_arena_release_agent() {
  // @@protoc_insertion_point(field_release:planning.eudm.SimCfg.agent)
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::ForwardSimDetail* temp = agent_;
  agent_ = nullptr;
  return temp;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::_internal_mutable_agent() {
  _has_bits_[0] |= 0x00000004u;
  if (agent_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::ForwardSimDetail>(GetArena());
    agent_ = p;
  }
  return agent_;
}
inline ::planning::eudm::ForwardSimDetail* SimCfg::mutable_agent() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SimCfg.agent)
  return _internal_mutable_agent();
}
inline void SimCfg::set_allocated_agent(::planning::eudm::ForwardSimDetail* agent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete agent_;
  }
  if (agent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(agent);
    if (message_arena != submessage_arena) {
      agent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  agent_ = agent;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SimCfg.agent)
}

// required double acc_cmd_vel_gap = 4;
inline bool SimCfg::_internal_has_acc_cmd_vel_gap() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SimCfg::has_acc_cmd_vel_gap() const {
  return _internal_has_acc_cmd_vel_gap();
}
inline void SimCfg::clear_acc_cmd_vel_gap() {
  acc_cmd_vel_gap_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SimCfg::_internal_acc_cmd_vel_gap() const {
  return acc_cmd_vel_gap_;
}
inline double SimCfg::acc_cmd_vel_gap() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.acc_cmd_vel_gap)
  return _internal_acc_cmd_vel_gap();
}
inline void SimCfg::_internal_set_acc_cmd_vel_gap(double value) {
  _has_bits_[0] |= 0x00000010u;
  acc_cmd_vel_gap_ = value;
}
inline void SimCfg::set_acc_cmd_vel_gap(double value) {
  _internal_set_acc_cmd_vel_gap(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimCfg.acc_cmd_vel_gap)
}

// required double dec_cmd_vel_gap = 5;
inline bool SimCfg::_internal_has_dec_cmd_vel_gap() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SimCfg::has_dec_cmd_vel_gap() const {
  return _internal_has_dec_cmd_vel_gap();
}
inline void SimCfg::clear_dec_cmd_vel_gap() {
  dec_cmd_vel_gap_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double SimCfg::_internal_dec_cmd_vel_gap() const {
  return dec_cmd_vel_gap_;
}
inline double SimCfg::dec_cmd_vel_gap() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.dec_cmd_vel_gap)
  return _internal_dec_cmd_vel_gap();
}
inline void SimCfg::_internal_set_dec_cmd_vel_gap(double value) {
  _has_bits_[0] |= 0x00000020u;
  dec_cmd_vel_gap_ = value;
}
inline void SimCfg::set_dec_cmd_vel_gap(double value) {
  _internal_set_dec_cmd_vel_gap(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SimCfg.dec_cmd_vel_gap)
}

// required .planning.eudm.SimRefLine ref_line = 6;
inline bool SimCfg::_internal_has_ref_line() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ref_line_ != nullptr);
  return value;
}
inline bool SimCfg::has_ref_line() const {
  return _internal_has_ref_line();
}
inline void SimCfg::clear_ref_line() {
  if (ref_line_ != nullptr) ref_line_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::planning::eudm::SimRefLine& SimCfg::_internal_ref_line() const {
  const ::planning::eudm::SimRefLine* p = ref_line_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::SimRefLine&>(
      ::planning::eudm::_SimRefLine_default_instance_);
}
inline const ::planning::eudm::SimRefLine& SimCfg::ref_line() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SimCfg.ref_line)
  return _internal_ref_line();
}
inline void SimCfg::unsafe_arena_set_allocated_ref_line(
    ::planning::eudm::SimRefLine* ref_line) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ref_line_);
  }
  ref_line_ = ref_line;
  if (ref_line) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SimCfg.ref_line)
}
inline ::planning::eudm::SimRefLine* SimCfg::release_ref_line() {
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::SimRefLine* temp = ref_line_;
  ref_line_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::SimRefLine* SimCfg::unsafe_arena_release_ref_line() {
  // @@protoc_insertion_point(field_release:planning.eudm.SimCfg.ref_line)
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::SimRefLine* temp = ref_line_;
  ref_line_ = nullptr;
  return temp;
}
inline ::planning::eudm::SimRefLine* SimCfg::_internal_mutable_ref_line() {
  _has_bits_[0] |= 0x00000008u;
  if (ref_line_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::SimRefLine>(GetArena());
    ref_line_ = p;
  }
  return ref_line_;
}
inline ::planning::eudm::SimRefLine* SimCfg::mutable_ref_line() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SimCfg.ref_line)
  return _internal_mutable_ref_line();
}
inline void SimCfg::set_allocated_ref_line(::planning::eudm::SimRefLine* ref_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ref_line_;
  }
  if (ref_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ref_line);
    if (message_arena != submessage_arena) {
      ref_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ref_line, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ref_line_ = ref_line;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SimCfg.ref_line)
}

// -------------------------------------------------------------------

// ActiveLaneChangeCfg

// required double cold_duration = 1;
inline bool ActiveLaneChangeCfg::_internal_has_cold_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_cold_duration() const {
  return _internal_has_cold_duration();
}
inline void ActiveLaneChangeCfg::clear_cold_duration() {
  cold_duration_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ActiveLaneChangeCfg::_internal_cold_duration() const {
  return cold_duration_;
}
inline double ActiveLaneChangeCfg::cold_duration() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.cold_duration)
  return _internal_cold_duration();
}
inline void ActiveLaneChangeCfg::_internal_set_cold_duration(double value) {
  _has_bits_[0] |= 0x00000001u;
  cold_duration_ = value;
}
inline void ActiveLaneChangeCfg::set_cold_duration(double value) {
  _internal_set_cold_duration(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.cold_duration)
}

// required double activate_speed_lower_bound = 2;
inline bool ActiveLaneChangeCfg::_internal_has_activate_speed_lower_bound() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_activate_speed_lower_bound() const {
  return _internal_has_activate_speed_lower_bound();
}
inline void ActiveLaneChangeCfg::clear_activate_speed_lower_bound() {
  activate_speed_lower_bound_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ActiveLaneChangeCfg::_internal_activate_speed_lower_bound() const {
  return activate_speed_lower_bound_;
}
inline double ActiveLaneChangeCfg::activate_speed_lower_bound() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.activate_speed_lower_bound)
  return _internal_activate_speed_lower_bound();
}
inline void ActiveLaneChangeCfg::_internal_set_activate_speed_lower_bound(double value) {
  _has_bits_[0] |= 0x00000002u;
  activate_speed_lower_bound_ = value;
}
inline void ActiveLaneChangeCfg::set_activate_speed_lower_bound(double value) {
  _internal_set_activate_speed_lower_bound(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.activate_speed_lower_bound)
}

// required double activate_speed_upper_bound = 3;
inline bool ActiveLaneChangeCfg::_internal_has_activate_speed_upper_bound() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_activate_speed_upper_bound() const {
  return _internal_has_activate_speed_upper_bound();
}
inline void ActiveLaneChangeCfg::clear_activate_speed_upper_bound() {
  activate_speed_upper_bound_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ActiveLaneChangeCfg::_internal_activate_speed_upper_bound() const {
  return activate_speed_upper_bound_;
}
inline double ActiveLaneChangeCfg::activate_speed_upper_bound() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.activate_speed_upper_bound)
  return _internal_activate_speed_upper_bound();
}
inline void ActiveLaneChangeCfg::_internal_set_activate_speed_upper_bound(double value) {
  _has_bits_[0] |= 0x00000004u;
  activate_speed_upper_bound_ = value;
}
inline void ActiveLaneChangeCfg::set_activate_speed_upper_bound(double value) {
  _internal_set_activate_speed_upper_bound(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.activate_speed_upper_bound)
}

// required double activate_max_duration_in_seconds = 4;
inline bool ActiveLaneChangeCfg::_internal_has_activate_max_duration_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_activate_max_duration_in_seconds() const {
  return _internal_has_activate_max_duration_in_seconds();
}
inline void ActiveLaneChangeCfg::clear_activate_max_duration_in_seconds() {
  activate_max_duration_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ActiveLaneChangeCfg::_internal_activate_max_duration_in_seconds() const {
  return activate_max_duration_in_seconds_;
}
inline double ActiveLaneChangeCfg::activate_max_duration_in_seconds() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.activate_max_duration_in_seconds)
  return _internal_activate_max_duration_in_seconds();
}
inline void ActiveLaneChangeCfg::_internal_set_activate_max_duration_in_seconds(double value) {
  _has_bits_[0] |= 0x00000008u;
  activate_max_duration_in_seconds_ = value;
}
inline void ActiveLaneChangeCfg::set_activate_max_duration_in_seconds(double value) {
  _internal_set_activate_max_duration_in_seconds(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.activate_max_duration_in_seconds)
}

// required double active_min_operation_in_seconds = 5;
inline bool ActiveLaneChangeCfg::_internal_has_active_min_operation_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_active_min_operation_in_seconds() const {
  return _internal_has_active_min_operation_in_seconds();
}
inline void ActiveLaneChangeCfg::clear_active_min_operation_in_seconds() {
  active_min_operation_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ActiveLaneChangeCfg::_internal_active_min_operation_in_seconds() const {
  return active_min_operation_in_seconds_;
}
inline double ActiveLaneChangeCfg::active_min_operation_in_seconds() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.active_min_operation_in_seconds)
  return _internal_active_min_operation_in_seconds();
}
inline void ActiveLaneChangeCfg::_internal_set_active_min_operation_in_seconds(double value) {
  _has_bits_[0] |= 0x00000010u;
  active_min_operation_in_seconds_ = value;
}
inline void ActiveLaneChangeCfg::set_active_min_operation_in_seconds(double value) {
  _internal_set_active_min_operation_in_seconds(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.active_min_operation_in_seconds)
}

// required double consistent_operate_time_min_gap = 6;
inline bool ActiveLaneChangeCfg::_internal_has_consistent_operate_time_min_gap() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_consistent_operate_time_min_gap() const {
  return _internal_has_consistent_operate_time_min_gap();
}
inline void ActiveLaneChangeCfg::clear_consistent_operate_time_min_gap() {
  consistent_operate_time_min_gap_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ActiveLaneChangeCfg::_internal_consistent_operate_time_min_gap() const {
  return consistent_operate_time_min_gap_;
}
inline double ActiveLaneChangeCfg::consistent_operate_time_min_gap() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.consistent_operate_time_min_gap)
  return _internal_consistent_operate_time_min_gap();
}
inline void ActiveLaneChangeCfg::_internal_set_consistent_operate_time_min_gap(double value) {
  _has_bits_[0] |= 0x00000020u;
  consistent_operate_time_min_gap_ = value;
}
inline void ActiveLaneChangeCfg::set_consistent_operate_time_min_gap(double value) {
  _internal_set_consistent_operate_time_min_gap(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.consistent_operate_time_min_gap)
}

// required double consistent_min_num_frame = 7;
inline bool ActiveLaneChangeCfg::_internal_has_consistent_min_num_frame() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_consistent_min_num_frame() const {
  return _internal_has_consistent_min_num_frame();
}
inline void ActiveLaneChangeCfg::clear_consistent_min_num_frame() {
  consistent_min_num_frame_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ActiveLaneChangeCfg::_internal_consistent_min_num_frame() const {
  return consistent_min_num_frame_;
}
inline double ActiveLaneChangeCfg::consistent_min_num_frame() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.consistent_min_num_frame)
  return _internal_consistent_min_num_frame();
}
inline void ActiveLaneChangeCfg::_internal_set_consistent_min_num_frame(double value) {
  _has_bits_[0] |= 0x00000040u;
  consistent_min_num_frame_ = value;
}
inline void ActiveLaneChangeCfg::set_consistent_min_num_frame(double value) {
  _internal_set_consistent_min_num_frame(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.consistent_min_num_frame)
}

// required bool enable_clear_accumulation_by_forbid_signal = 8;
inline bool ActiveLaneChangeCfg::_internal_has_enable_clear_accumulation_by_forbid_signal() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_enable_clear_accumulation_by_forbid_signal() const {
  return _internal_has_enable_clear_accumulation_by_forbid_signal();
}
inline void ActiveLaneChangeCfg::clear_enable_clear_accumulation_by_forbid_signal() {
  enable_clear_accumulation_by_forbid_signal_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ActiveLaneChangeCfg::_internal_enable_clear_accumulation_by_forbid_signal() const {
  return enable_clear_accumulation_by_forbid_signal_;
}
inline bool ActiveLaneChangeCfg::enable_clear_accumulation_by_forbid_signal() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.enable_clear_accumulation_by_forbid_signal)
  return _internal_enable_clear_accumulation_by_forbid_signal();
}
inline void ActiveLaneChangeCfg::_internal_set_enable_clear_accumulation_by_forbid_signal(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enable_clear_accumulation_by_forbid_signal_ = value;
}
inline void ActiveLaneChangeCfg::set_enable_clear_accumulation_by_forbid_signal(bool value) {
  _internal_set_enable_clear_accumulation_by_forbid_signal(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.enable_clear_accumulation_by_forbid_signal)
}

// required bool enable_auto_cancel_by_forbid_signal = 9;
inline bool ActiveLaneChangeCfg::_internal_has_enable_auto_cancel_by_forbid_signal() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_enable_auto_cancel_by_forbid_signal() const {
  return _internal_has_enable_auto_cancel_by_forbid_signal();
}
inline void ActiveLaneChangeCfg::clear_enable_auto_cancel_by_forbid_signal() {
  enable_auto_cancel_by_forbid_signal_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ActiveLaneChangeCfg::_internal_enable_auto_cancel_by_forbid_signal() const {
  return enable_auto_cancel_by_forbid_signal_;
}
inline bool ActiveLaneChangeCfg::enable_auto_cancel_by_forbid_signal() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.enable_auto_cancel_by_forbid_signal)
  return _internal_enable_auto_cancel_by_forbid_signal();
}
inline void ActiveLaneChangeCfg::_internal_set_enable_auto_cancel_by_forbid_signal(bool value) {
  _has_bits_[0] |= 0x00000200u;
  enable_auto_cancel_by_forbid_signal_ = value;
}
inline void ActiveLaneChangeCfg::set_enable_auto_cancel_by_forbid_signal(bool value) {
  _internal_set_enable_auto_cancel_by_forbid_signal(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.enable_auto_cancel_by_forbid_signal)
}

// required bool enable_auto_cancel_by_outdate_time = 10;
inline bool ActiveLaneChangeCfg::_internal_has_enable_auto_cancel_by_outdate_time() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_enable_auto_cancel_by_outdate_time() const {
  return _internal_has_enable_auto_cancel_by_outdate_time();
}
inline void ActiveLaneChangeCfg::clear_enable_auto_cancel_by_outdate_time() {
  enable_auto_cancel_by_outdate_time_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ActiveLaneChangeCfg::_internal_enable_auto_cancel_by_outdate_time() const {
  return enable_auto_cancel_by_outdate_time_;
}
inline bool ActiveLaneChangeCfg::enable_auto_cancel_by_outdate_time() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.enable_auto_cancel_by_outdate_time)
  return _internal_enable_auto_cancel_by_outdate_time();
}
inline void ActiveLaneChangeCfg::_internal_set_enable_auto_cancel_by_outdate_time(bool value) {
  _has_bits_[0] |= 0x00000400u;
  enable_auto_cancel_by_outdate_time_ = value;
}
inline void ActiveLaneChangeCfg::set_enable_auto_cancel_by_outdate_time(bool value) {
  _internal_set_enable_auto_cancel_by_outdate_time(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.enable_auto_cancel_by_outdate_time)
}

// required bool enable_auto_canbel_by_stick_signal = 11;
inline bool ActiveLaneChangeCfg::_internal_has_enable_auto_canbel_by_stick_signal() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_enable_auto_canbel_by_stick_signal() const {
  return _internal_has_enable_auto_canbel_by_stick_signal();
}
inline void ActiveLaneChangeCfg::clear_enable_auto_canbel_by_stick_signal() {
  enable_auto_canbel_by_stick_signal_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ActiveLaneChangeCfg::_internal_enable_auto_canbel_by_stick_signal() const {
  return enable_auto_canbel_by_stick_signal_;
}
inline bool ActiveLaneChangeCfg::enable_auto_canbel_by_stick_signal() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.enable_auto_canbel_by_stick_signal)
  return _internal_enable_auto_canbel_by_stick_signal();
}
inline void ActiveLaneChangeCfg::_internal_set_enable_auto_canbel_by_stick_signal(bool value) {
  _has_bits_[0] |= 0x00000800u;
  enable_auto_canbel_by_stick_signal_ = value;
}
inline void ActiveLaneChangeCfg::set_enable_auto_canbel_by_stick_signal(bool value) {
  _internal_set_enable_auto_canbel_by_stick_signal(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.enable_auto_canbel_by_stick_signal)
}

// required double auto_cancel_if_late_for_seconds = 12;
inline bool ActiveLaneChangeCfg::_internal_has_auto_cancel_if_late_for_seconds() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ActiveLaneChangeCfg::has_auto_cancel_if_late_for_seconds() const {
  return _internal_has_auto_cancel_if_late_for_seconds();
}
inline void ActiveLaneChangeCfg::clear_auto_cancel_if_late_for_seconds() {
  auto_cancel_if_late_for_seconds_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ActiveLaneChangeCfg::_internal_auto_cancel_if_late_for_seconds() const {
  return auto_cancel_if_late_for_seconds_;
}
inline double ActiveLaneChangeCfg::auto_cancel_if_late_for_seconds() const {
  // @@protoc_insertion_point(field_get:planning.eudm.ActiveLaneChangeCfg.auto_cancel_if_late_for_seconds)
  return _internal_auto_cancel_if_late_for_seconds();
}
inline void ActiveLaneChangeCfg::_internal_set_auto_cancel_if_late_for_seconds(double value) {
  _has_bits_[0] |= 0x00000080u;
  auto_cancel_if_late_for_seconds_ = value;
}
inline void ActiveLaneChangeCfg::set_auto_cancel_if_late_for_seconds(double value) {
  _internal_set_auto_cancel_if_late_for_seconds(value);
  // @@protoc_insertion_point(field_set:planning.eudm.ActiveLaneChangeCfg.auto_cancel_if_late_for_seconds)
}

// -------------------------------------------------------------------

// FunctionCfg

// required bool mobil_enable = 1;
inline bool FunctionCfg::_internal_has_mobil_enable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FunctionCfg::has_mobil_enable() const {
  return _internal_has_mobil_enable();
}
inline void FunctionCfg::clear_mobil_enable() {
  mobil_enable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool FunctionCfg::_internal_mobil_enable() const {
  return mobil_enable_;
}
inline bool FunctionCfg::mobil_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.FunctionCfg.mobil_enable)
  return _internal_mobil_enable();
}
inline void FunctionCfg::_internal_set_mobil_enable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  mobil_enable_ = value;
}
inline void FunctionCfg::set_mobil_enable(bool value) {
  _internal_set_mobil_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.FunctionCfg.mobil_enable)
}

// required bool active_lc_enable = 2;
inline bool FunctionCfg::_internal_has_active_lc_enable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FunctionCfg::has_active_lc_enable() const {
  return _internal_has_active_lc_enable();
}
inline void FunctionCfg::clear_active_lc_enable() {
  active_lc_enable_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool FunctionCfg::_internal_active_lc_enable() const {
  return active_lc_enable_;
}
inline bool FunctionCfg::active_lc_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.FunctionCfg.active_lc_enable)
  return _internal_active_lc_enable();
}
inline void FunctionCfg::_internal_set_active_lc_enable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  active_lc_enable_ = value;
}
inline void FunctionCfg::set_active_lc_enable(bool value) {
  _internal_set_active_lc_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.FunctionCfg.active_lc_enable)
}

// required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
inline bool FunctionCfg::_internal_has_active_lc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || active_lc_ != nullptr);
  return value;
}
inline bool FunctionCfg::has_active_lc() const {
  return _internal_has_active_lc();
}
inline void FunctionCfg::clear_active_lc() {
  if (active_lc_ != nullptr) active_lc_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::ActiveLaneChangeCfg& FunctionCfg::_internal_active_lc() const {
  const ::planning::eudm::ActiveLaneChangeCfg* p = active_lc_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::ActiveLaneChangeCfg&>(
      ::planning::eudm::_ActiveLaneChangeCfg_default_instance_);
}
inline const ::planning::eudm::ActiveLaneChangeCfg& FunctionCfg::active_lc() const {
  // @@protoc_insertion_point(field_get:planning.eudm.FunctionCfg.active_lc)
  return _internal_active_lc();
}
inline void FunctionCfg::unsafe_arena_set_allocated_active_lc(
    ::planning::eudm::ActiveLaneChangeCfg* active_lc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_lc_);
  }
  active_lc_ = active_lc;
  if (active_lc) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.FunctionCfg.active_lc)
}
inline ::planning::eudm::ActiveLaneChangeCfg* FunctionCfg::release_active_lc() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::ActiveLaneChangeCfg* temp = active_lc_;
  active_lc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::ActiveLaneChangeCfg* FunctionCfg::unsafe_arena_release_active_lc() {
  // @@protoc_insertion_point(field_release:planning.eudm.FunctionCfg.active_lc)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::ActiveLaneChangeCfg* temp = active_lc_;
  active_lc_ = nullptr;
  return temp;
}
inline ::planning::eudm::ActiveLaneChangeCfg* FunctionCfg::_internal_mutable_active_lc() {
  _has_bits_[0] |= 0x00000001u;
  if (active_lc_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::ActiveLaneChangeCfg>(GetArena());
    active_lc_ = p;
  }
  return active_lc_;
}
inline ::planning::eudm::ActiveLaneChangeCfg* FunctionCfg::mutable_active_lc() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.FunctionCfg.active_lc)
  return _internal_mutable_active_lc();
}
inline void FunctionCfg::set_allocated_active_lc(::planning::eudm::ActiveLaneChangeCfg* active_lc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete active_lc_;
  }
  if (active_lc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(active_lc);
    if (message_arena != submessage_arena) {
      active_lc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_lc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  active_lc_ = active_lc;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.FunctionCfg.active_lc)
}

// required double stick_lane_change_in_seconds = 4;
inline bool FunctionCfg::_internal_has_stick_lane_change_in_seconds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FunctionCfg::has_stick_lane_change_in_seconds() const {
  return _internal_has_stick_lane_change_in_seconds();
}
inline void FunctionCfg::clear_stick_lane_change_in_seconds() {
  stick_lane_change_in_seconds_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double FunctionCfg::_internal_stick_lane_change_in_seconds() const {
  return stick_lane_change_in_seconds_;
}
inline double FunctionCfg::stick_lane_change_in_seconds() const {
  // @@protoc_insertion_point(field_get:planning.eudm.FunctionCfg.stick_lane_change_in_seconds)
  return _internal_stick_lane_change_in_seconds();
}
inline void FunctionCfg::_internal_set_stick_lane_change_in_seconds(double value) {
  _has_bits_[0] |= 0x00000002u;
  stick_lane_change_in_seconds_ = value;
}
inline void FunctionCfg::set_stick_lane_change_in_seconds(double value) {
  _internal_set_stick_lane_change_in_seconds(value);
  // @@protoc_insertion_point(field_set:planning.eudm.FunctionCfg.stick_lane_change_in_seconds)
}

// -------------------------------------------------------------------

// RssCfg

// required double response_time = 1;
inline bool RssCfg::_internal_has_response_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RssCfg::has_response_time() const {
  return _internal_has_response_time();
}
inline void RssCfg::clear_response_time() {
  response_time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double RssCfg::_internal_response_time() const {
  return response_time_;
}
inline double RssCfg::response_time() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.response_time)
  return _internal_response_time();
}
inline void RssCfg::_internal_set_response_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  response_time_ = value;
}
inline void RssCfg::set_response_time(double value) {
  _internal_set_response_time(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.response_time)
}

// required double longitudinal_acc_max = 2;
inline bool RssCfg::_internal_has_longitudinal_acc_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RssCfg::has_longitudinal_acc_max() const {
  return _internal_has_longitudinal_acc_max();
}
inline void RssCfg::clear_longitudinal_acc_max() {
  longitudinal_acc_max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RssCfg::_internal_longitudinal_acc_max() const {
  return longitudinal_acc_max_;
}
inline double RssCfg::longitudinal_acc_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.longitudinal_acc_max)
  return _internal_longitudinal_acc_max();
}
inline void RssCfg::_internal_set_longitudinal_acc_max(double value) {
  _has_bits_[0] |= 0x00000002u;
  longitudinal_acc_max_ = value;
}
inline void RssCfg::set_longitudinal_acc_max(double value) {
  _internal_set_longitudinal_acc_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.longitudinal_acc_max)
}

// required double longitudinal_brake_min = 3;
inline bool RssCfg::_internal_has_longitudinal_brake_min() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RssCfg::has_longitudinal_brake_min() const {
  return _internal_has_longitudinal_brake_min();
}
inline void RssCfg::clear_longitudinal_brake_min() {
  longitudinal_brake_min_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double RssCfg::_internal_longitudinal_brake_min() const {
  return longitudinal_brake_min_;
}
inline double RssCfg::longitudinal_brake_min() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.longitudinal_brake_min)
  return _internal_longitudinal_brake_min();
}
inline void RssCfg::_internal_set_longitudinal_brake_min(double value) {
  _has_bits_[0] |= 0x00000004u;
  longitudinal_brake_min_ = value;
}
inline void RssCfg::set_longitudinal_brake_min(double value) {
  _internal_set_longitudinal_brake_min(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.longitudinal_brake_min)
}

// required double longitudinal_brake_max = 4;
inline bool RssCfg::_internal_has_longitudinal_brake_max() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RssCfg::has_longitudinal_brake_max() const {
  return _internal_has_longitudinal_brake_max();
}
inline void RssCfg::clear_longitudinal_brake_max() {
  longitudinal_brake_max_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double RssCfg::_internal_longitudinal_brake_max() const {
  return longitudinal_brake_max_;
}
inline double RssCfg::longitudinal_brake_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.longitudinal_brake_max)
  return _internal_longitudinal_brake_max();
}
inline void RssCfg::_internal_set_longitudinal_brake_max(double value) {
  _has_bits_[0] |= 0x00000008u;
  longitudinal_brake_max_ = value;
}
inline void RssCfg::set_longitudinal_brake_max(double value) {
  _internal_set_longitudinal_brake_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.longitudinal_brake_max)
}

// required double lateral_acc_max = 5;
inline bool RssCfg::_internal_has_lateral_acc_max() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RssCfg::has_lateral_acc_max() const {
  return _internal_has_lateral_acc_max();
}
inline void RssCfg::clear_lateral_acc_max() {
  lateral_acc_max_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double RssCfg::_internal_lateral_acc_max() const {
  return lateral_acc_max_;
}
inline double RssCfg::lateral_acc_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.lateral_acc_max)
  return _internal_lateral_acc_max();
}
inline void RssCfg::_internal_set_lateral_acc_max(double value) {
  _has_bits_[0] |= 0x00000010u;
  lateral_acc_max_ = value;
}
inline void RssCfg::set_lateral_acc_max(double value) {
  _internal_set_lateral_acc_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.lateral_acc_max)
}

// required double lateral_brake_min = 6;
inline bool RssCfg::_internal_has_lateral_brake_min() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RssCfg::has_lateral_brake_min() const {
  return _internal_has_lateral_brake_min();
}
inline void RssCfg::clear_lateral_brake_min() {
  lateral_brake_min_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double RssCfg::_internal_lateral_brake_min() const {
  return lateral_brake_min_;
}
inline double RssCfg::lateral_brake_min() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.lateral_brake_min)
  return _internal_lateral_brake_min();
}
inline void RssCfg::_internal_set_lateral_brake_min(double value) {
  _has_bits_[0] |= 0x00000020u;
  lateral_brake_min_ = value;
}
inline void RssCfg::set_lateral_brake_min(double value) {
  _internal_set_lateral_brake_min(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.lateral_brake_min)
}

// required double lateral_brake_max = 7;
inline bool RssCfg::_internal_has_lateral_brake_max() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RssCfg::has_lateral_brake_max() const {
  return _internal_has_lateral_brake_max();
}
inline void RssCfg::clear_lateral_brake_max() {
  lateral_brake_max_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double RssCfg::_internal_lateral_brake_max() const {
  return lateral_brake_max_;
}
inline double RssCfg::lateral_brake_max() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.lateral_brake_max)
  return _internal_lateral_brake_max();
}
inline void RssCfg::_internal_set_lateral_brake_max(double value) {
  _has_bits_[0] |= 0x00000040u;
  lateral_brake_max_ = value;
}
inline void RssCfg::set_lateral_brake_max(double value) {
  _internal_set_lateral_brake_max(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.lateral_brake_max)
}

// required double lateral_miu = 8;
inline bool RssCfg::_internal_has_lateral_miu() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RssCfg::has_lateral_miu() const {
  return _internal_has_lateral_miu();
}
inline void RssCfg::clear_lateral_miu() {
  lateral_miu_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double RssCfg::_internal_lateral_miu() const {
  return lateral_miu_;
}
inline double RssCfg::lateral_miu() const {
  // @@protoc_insertion_point(field_get:planning.eudm.RssCfg.lateral_miu)
  return _internal_lateral_miu();
}
inline void RssCfg::_internal_set_lateral_miu(double value) {
  _has_bits_[0] |= 0x00000080u;
  lateral_miu_ = value;
}
inline void RssCfg::set_lateral_miu(double value) {
  _internal_set_lateral_miu(value);
  // @@protoc_insertion_point(field_set:planning.eudm.RssCfg.lateral_miu)
}

// -------------------------------------------------------------------

// StrictCheckCfg

// required double inflation_w = 1;
inline bool StrictCheckCfg::_internal_has_inflation_w() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrictCheckCfg::has_inflation_w() const {
  return _internal_has_inflation_w();
}
inline void StrictCheckCfg::clear_inflation_w() {
  inflation_w_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double StrictCheckCfg::_internal_inflation_w() const {
  return inflation_w_;
}
inline double StrictCheckCfg::inflation_w() const {
  // @@protoc_insertion_point(field_get:planning.eudm.StrictCheckCfg.inflation_w)
  return _internal_inflation_w();
}
inline void StrictCheckCfg::_internal_set_inflation_w(double value) {
  _has_bits_[0] |= 0x00000001u;
  inflation_w_ = value;
}
inline void StrictCheckCfg::set_inflation_w(double value) {
  _internal_set_inflation_w(value);
  // @@protoc_insertion_point(field_set:planning.eudm.StrictCheckCfg.inflation_w)
}

// required double inflation_h = 2;
inline bool StrictCheckCfg::_internal_has_inflation_h() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrictCheckCfg::has_inflation_h() const {
  return _internal_has_inflation_h();
}
inline void StrictCheckCfg::clear_inflation_h() {
  inflation_h_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double StrictCheckCfg::_internal_inflation_h() const {
  return inflation_h_;
}
inline double StrictCheckCfg::inflation_h() const {
  // @@protoc_insertion_point(field_get:planning.eudm.StrictCheckCfg.inflation_h)
  return _internal_inflation_h();
}
inline void StrictCheckCfg::_internal_set_inflation_h(double value) {
  _has_bits_[0] |= 0x00000002u;
  inflation_h_ = value;
}
inline void StrictCheckCfg::set_inflation_h(double value) {
  _internal_set_inflation_h(value);
  // @@protoc_insertion_point(field_set:planning.eudm.StrictCheckCfg.inflation_h)
}

// -------------------------------------------------------------------

// SafetyCfg

// required .planning.eudm.StrictCheckCfg strict = 1;
inline bool SafetyCfg::_internal_has_strict() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || strict_ != nullptr);
  return value;
}
inline bool SafetyCfg::has_strict() const {
  return _internal_has_strict();
}
inline void SafetyCfg::clear_strict() {
  if (strict_ != nullptr) strict_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::eudm::StrictCheckCfg& SafetyCfg::_internal_strict() const {
  const ::planning::eudm::StrictCheckCfg* p = strict_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::StrictCheckCfg&>(
      ::planning::eudm::_StrictCheckCfg_default_instance_);
}
inline const ::planning::eudm::StrictCheckCfg& SafetyCfg::strict() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.strict)
  return _internal_strict();
}
inline void SafetyCfg::unsafe_arena_set_allocated_strict(
    ::planning::eudm::StrictCheckCfg* strict) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strict_);
  }
  strict_ = strict;
  if (strict) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SafetyCfg.strict)
}
inline ::planning::eudm::StrictCheckCfg* SafetyCfg::release_strict() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::StrictCheckCfg* temp = strict_;
  strict_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::StrictCheckCfg* SafetyCfg::unsafe_arena_release_strict() {
  // @@protoc_insertion_point(field_release:planning.eudm.SafetyCfg.strict)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::eudm::StrictCheckCfg* temp = strict_;
  strict_ = nullptr;
  return temp;
}
inline ::planning::eudm::StrictCheckCfg* SafetyCfg::_internal_mutable_strict() {
  _has_bits_[0] |= 0x00000001u;
  if (strict_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::StrictCheckCfg>(GetArena());
    strict_ = p;
  }
  return strict_;
}
inline ::planning::eudm::StrictCheckCfg* SafetyCfg::mutable_strict() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SafetyCfg.strict)
  return _internal_mutable_strict();
}
inline void SafetyCfg::set_allocated_strict(::planning::eudm::StrictCheckCfg* strict) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strict_;
  }
  if (strict) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strict);
    if (message_arena != submessage_arena) {
      strict = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strict, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  strict_ = strict;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SafetyCfg.strict)
}

// required bool strict_check_enable = 2;
inline bool SafetyCfg::_internal_has_strict_check_enable() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SafetyCfg::has_strict_check_enable() const {
  return _internal_has_strict_check_enable();
}
inline void SafetyCfg::clear_strict_check_enable() {
  strict_check_enable_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SafetyCfg::_internal_strict_check_enable() const {
  return strict_check_enable_;
}
inline bool SafetyCfg::strict_check_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.strict_check_enable)
  return _internal_strict_check_enable();
}
inline void SafetyCfg::_internal_set_strict_check_enable(bool value) {
  _has_bits_[0] |= 0x00000010u;
  strict_check_enable_ = value;
}
inline void SafetyCfg::set_strict_check_enable(bool value) {
  _internal_set_strict_check_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyCfg.strict_check_enable)
}

// required .planning.eudm.RssCfg rss = 3;
inline bool SafetyCfg::_internal_has_rss() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || rss_ != nullptr);
  return value;
}
inline bool SafetyCfg::has_rss() const {
  return _internal_has_rss();
}
inline void SafetyCfg::clear_rss() {
  if (rss_ != nullptr) rss_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::eudm::RssCfg& SafetyCfg::_internal_rss() const {
  const ::planning::eudm::RssCfg* p = rss_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::RssCfg&>(
      ::planning::eudm::_RssCfg_default_instance_);
}
inline const ::planning::eudm::RssCfg& SafetyCfg::rss() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.rss)
  return _internal_rss();
}
inline void SafetyCfg::unsafe_arena_set_allocated_rss(
    ::planning::eudm::RssCfg* rss) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rss_);
  }
  rss_ = rss;
  if (rss) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SafetyCfg.rss)
}
inline ::planning::eudm::RssCfg* SafetyCfg::release_rss() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::RssCfg* temp = rss_;
  rss_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::unsafe_arena_release_rss() {
  // @@protoc_insertion_point(field_release:planning.eudm.SafetyCfg.rss)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::eudm::RssCfg* temp = rss_;
  rss_ = nullptr;
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::_internal_mutable_rss() {
  _has_bits_[0] |= 0x00000002u;
  if (rss_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::RssCfg>(GetArena());
    rss_ = p;
  }
  return rss_;
}
inline ::planning::eudm::RssCfg* SafetyCfg::mutable_rss() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SafetyCfg.rss)
  return _internal_mutable_rss();
}
inline void SafetyCfg::set_allocated_rss(::planning::eudm::RssCfg* rss) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rss_;
  }
  if (rss) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rss);
    if (message_arena != submessage_arena) {
      rss = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rss, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rss_ = rss;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SafetyCfg.rss)
}

// required bool rss_check_enable = 4;
inline bool SafetyCfg::_internal_has_rss_check_enable() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SafetyCfg::has_rss_check_enable() const {
  return _internal_has_rss_check_enable();
}
inline void SafetyCfg::clear_rss_check_enable() {
  rss_check_enable_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SafetyCfg::_internal_rss_check_enable() const {
  return rss_check_enable_;
}
inline bool SafetyCfg::rss_check_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.rss_check_enable)
  return _internal_rss_check_enable();
}
inline void SafetyCfg::_internal_set_rss_check_enable(bool value) {
  _has_bits_[0] |= 0x00000020u;
  rss_check_enable_ = value;
}
inline void SafetyCfg::set_rss_check_enable(bool value) {
  _internal_set_rss_check_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyCfg.rss_check_enable)
}

// required .planning.eudm.RssCfg rss_strict_as_front = 5;
inline bool SafetyCfg::_internal_has_rss_strict_as_front() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rss_strict_as_front_ != nullptr);
  return value;
}
inline bool SafetyCfg::has_rss_strict_as_front() const {
  return _internal_has_rss_strict_as_front();
}
inline void SafetyCfg::clear_rss_strict_as_front() {
  if (rss_strict_as_front_ != nullptr) rss_strict_as_front_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::planning::eudm::RssCfg& SafetyCfg::_internal_rss_strict_as_front() const {
  const ::planning::eudm::RssCfg* p = rss_strict_as_front_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::RssCfg&>(
      ::planning::eudm::_RssCfg_default_instance_);
}
inline const ::planning::eudm::RssCfg& SafetyCfg::rss_strict_as_front() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.rss_strict_as_front)
  return _internal_rss_strict_as_front();
}
inline void SafetyCfg::unsafe_arena_set_allocated_rss_strict_as_front(
    ::planning::eudm::RssCfg* rss_strict_as_front) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rss_strict_as_front_);
  }
  rss_strict_as_front_ = rss_strict_as_front;
  if (rss_strict_as_front) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SafetyCfg.rss_strict_as_front)
}
inline ::planning::eudm::RssCfg* SafetyCfg::release_rss_strict_as_front() {
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::RssCfg* temp = rss_strict_as_front_;
  rss_strict_as_front_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::unsafe_arena_release_rss_strict_as_front() {
  // @@protoc_insertion_point(field_release:planning.eudm.SafetyCfg.rss_strict_as_front)
  _has_bits_[0] &= ~0x00000004u;
  ::planning::eudm::RssCfg* temp = rss_strict_as_front_;
  rss_strict_as_front_ = nullptr;
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::_internal_mutable_rss_strict_as_front() {
  _has_bits_[0] |= 0x00000004u;
  if (rss_strict_as_front_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::RssCfg>(GetArena());
    rss_strict_as_front_ = p;
  }
  return rss_strict_as_front_;
}
inline ::planning::eudm::RssCfg* SafetyCfg::mutable_rss_strict_as_front() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SafetyCfg.rss_strict_as_front)
  return _internal_mutable_rss_strict_as_front();
}
inline void SafetyCfg::set_allocated_rss_strict_as_front(::planning::eudm::RssCfg* rss_strict_as_front) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rss_strict_as_front_;
  }
  if (rss_strict_as_front) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rss_strict_as_front);
    if (message_arena != submessage_arena) {
      rss_strict_as_front = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rss_strict_as_front, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rss_strict_as_front_ = rss_strict_as_front;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SafetyCfg.rss_strict_as_front)
}

// required .planning.eudm.RssCfg rss_strict_as_rear = 6;
inline bool SafetyCfg::_internal_has_rss_strict_as_rear() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rss_strict_as_rear_ != nullptr);
  return value;
}
inline bool SafetyCfg::has_rss_strict_as_rear() const {
  return _internal_has_rss_strict_as_rear();
}
inline void SafetyCfg::clear_rss_strict_as_rear() {
  if (rss_strict_as_rear_ != nullptr) rss_strict_as_rear_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::planning::eudm::RssCfg& SafetyCfg::_internal_rss_strict_as_rear() const {
  const ::planning::eudm::RssCfg* p = rss_strict_as_rear_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::RssCfg&>(
      ::planning::eudm::_RssCfg_default_instance_);
}
inline const ::planning::eudm::RssCfg& SafetyCfg::rss_strict_as_rear() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.rss_strict_as_rear)
  return _internal_rss_strict_as_rear();
}
inline void SafetyCfg::unsafe_arena_set_allocated_rss_strict_as_rear(
    ::planning::eudm::RssCfg* rss_strict_as_rear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rss_strict_as_rear_);
  }
  rss_strict_as_rear_ = rss_strict_as_rear;
  if (rss_strict_as_rear) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.SafetyCfg.rss_strict_as_rear)
}
inline ::planning::eudm::RssCfg* SafetyCfg::release_rss_strict_as_rear() {
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::RssCfg* temp = rss_strict_as_rear_;
  rss_strict_as_rear_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::unsafe_arena_release_rss_strict_as_rear() {
  // @@protoc_insertion_point(field_release:planning.eudm.SafetyCfg.rss_strict_as_rear)
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::RssCfg* temp = rss_strict_as_rear_;
  rss_strict_as_rear_ = nullptr;
  return temp;
}
inline ::planning::eudm::RssCfg* SafetyCfg::_internal_mutable_rss_strict_as_rear() {
  _has_bits_[0] |= 0x00000008u;
  if (rss_strict_as_rear_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::RssCfg>(GetArena());
    rss_strict_as_rear_ = p;
  }
  return rss_strict_as_rear_;
}
inline ::planning::eudm::RssCfg* SafetyCfg::mutable_rss_strict_as_rear() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.SafetyCfg.rss_strict_as_rear)
  return _internal_mutable_rss_strict_as_rear();
}
inline void SafetyCfg::set_allocated_rss_strict_as_rear(::planning::eudm::RssCfg* rss_strict_as_rear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rss_strict_as_rear_;
  }
  if (rss_strict_as_rear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rss_strict_as_rear);
    if (message_arena != submessage_arena) {
      rss_strict_as_rear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rss_strict_as_rear, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rss_strict_as_rear_ = rss_strict_as_rear;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.SafetyCfg.rss_strict_as_rear)
}

// required bool rss_for_layers_enable = 7;
inline bool SafetyCfg::_internal_has_rss_for_layers_enable() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SafetyCfg::has_rss_for_layers_enable() const {
  return _internal_has_rss_for_layers_enable();
}
inline void SafetyCfg::clear_rss_for_layers_enable() {
  rss_for_layers_enable_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool SafetyCfg::_internal_rss_for_layers_enable() const {
  return rss_for_layers_enable_;
}
inline bool SafetyCfg::rss_for_layers_enable() const {
  // @@protoc_insertion_point(field_get:planning.eudm.SafetyCfg.rss_for_layers_enable)
  return _internal_rss_for_layers_enable();
}
inline void SafetyCfg::_internal_set_rss_for_layers_enable(bool value) {
  _has_bits_[0] |= 0x00000040u;
  rss_for_layers_enable_ = value;
}
inline void SafetyCfg::set_rss_for_layers_enable(bool value) {
  _internal_set_rss_for_layers_enable(value);
  // @@protoc_insertion_point(field_set:planning.eudm.SafetyCfg.rss_for_layers_enable)
}

// -------------------------------------------------------------------

// Config

// required string name = 1;
inline bool Config::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_name() const {
  return _internal_has_name();
}
inline void Config::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.name)
  return _internal_name();
}
inline void Config::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:planning.eudm.Config.name)
}
inline std::string* Config::mutable_name() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.name)
  return _internal_mutable_name();
}
inline const std::string& Config::_internal_name() const {
  return name_.Get();
}
inline void Config::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.eudm.Config.name)
}
inline void Config::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.eudm.Config.name)
}
inline void Config::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.eudm.Config.name)
}
inline std::string* Config::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_name() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.name)
}

// required string version = 2;
inline bool Config::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_version() const {
  return _internal_has_version();
}
inline void Config::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Config::version() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.version)
  return _internal_version();
}
inline void Config::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:planning.eudm.Config.version)
}
inline std::string* Config::mutable_version() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.version)
  return _internal_mutable_version();
}
inline const std::string& Config::_internal_version() const {
  return version_.Get();
}
inline void Config::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.eudm.Config.version)
}
inline void Config::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.eudm.Config.version)
}
inline void Config::set_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.eudm.Config.version)
}
inline std::string* Config::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_version() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.version)
}

// required string status = 3;
inline bool Config::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Config::has_status() const {
  return _internal_has_status();
}
inline void Config::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Config::status() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.status)
  return _internal_status();
}
inline void Config::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:planning.eudm.Config.status)
}
inline std::string* Config::mutable_status() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.status)
  return _internal_mutable_status();
}
inline const std::string& Config::_internal_status() const {
  return status_.Get();
}
inline void Config::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.eudm.Config.status)
}
inline void Config::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.eudm.Config.status)
}
inline void Config::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.eudm.Config.status)
}
inline std::string* Config::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_status() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.status)
}

// required .planning.eudm.CostAssessCfg cost = 4;
inline bool Config::_internal_has_cost() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || cost_ != nullptr);
  return value;
}
inline bool Config::has_cost() const {
  return _internal_has_cost();
}
inline void Config::clear_cost() {
  if (cost_ != nullptr) cost_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::planning::eudm::CostAssessCfg& Config::_internal_cost() const {
  const ::planning::eudm::CostAssessCfg* p = cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::CostAssessCfg&>(
      ::planning::eudm::_CostAssessCfg_default_instance_);
}
inline const ::planning::eudm::CostAssessCfg& Config::cost() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.cost)
  return _internal_cost();
}
inline void Config::unsafe_arena_set_allocated_cost(
    ::planning::eudm::CostAssessCfg* cost) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cost_);
  }
  cost_ = cost;
  if (cost) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.Config.cost)
}
inline ::planning::eudm::CostAssessCfg* Config::release_cost() {
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::CostAssessCfg* temp = cost_;
  cost_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::CostAssessCfg* Config::unsafe_arena_release_cost() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.cost)
  _has_bits_[0] &= ~0x00000008u;
  ::planning::eudm::CostAssessCfg* temp = cost_;
  cost_ = nullptr;
  return temp;
}
inline ::planning::eudm::CostAssessCfg* Config::_internal_mutable_cost() {
  _has_bits_[0] |= 0x00000008u;
  if (cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::CostAssessCfg>(GetArena());
    cost_ = p;
  }
  return cost_;
}
inline ::planning::eudm::CostAssessCfg* Config::mutable_cost() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.cost)
  return _internal_mutable_cost();
}
inline void Config::set_allocated_cost(::planning::eudm::CostAssessCfg* cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cost_;
  }
  if (cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cost);
    if (message_arena != submessage_arena) {
      cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cost, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cost_ = cost;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.cost)
}

// required .planning.eudm.SimCfg sim = 5;
inline bool Config::_internal_has_sim() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || sim_ != nullptr);
  return value;
}
inline bool Config::has_sim() const {
  return _internal_has_sim();
}
inline void Config::clear_sim() {
  if (sim_ != nullptr) sim_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::planning::eudm::SimCfg& Config::_internal_sim() const {
  const ::planning::eudm::SimCfg* p = sim_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::SimCfg&>(
      ::planning::eudm::_SimCfg_default_instance_);
}
inline const ::planning::eudm::SimCfg& Config::sim() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.sim)
  return _internal_sim();
}
inline void Config::unsafe_arena_set_allocated_sim(
    ::planning::eudm::SimCfg* sim) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sim_);
  }
  sim_ = sim;
  if (sim) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.Config.sim)
}
inline ::planning::eudm::SimCfg* Config::release_sim() {
  _has_bits_[0] &= ~0x00000010u;
  ::planning::eudm::SimCfg* temp = sim_;
  sim_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::SimCfg* Config::unsafe_arena_release_sim() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.sim)
  _has_bits_[0] &= ~0x00000010u;
  ::planning::eudm::SimCfg* temp = sim_;
  sim_ = nullptr;
  return temp;
}
inline ::planning::eudm::SimCfg* Config::_internal_mutable_sim() {
  _has_bits_[0] |= 0x00000010u;
  if (sim_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::SimCfg>(GetArena());
    sim_ = p;
  }
  return sim_;
}
inline ::planning::eudm::SimCfg* Config::mutable_sim() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.sim)
  return _internal_mutable_sim();
}
inline void Config::set_allocated_sim(::planning::eudm::SimCfg* sim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sim_;
  }
  if (sim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sim);
    if (message_arena != submessage_arena) {
      sim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sim, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sim_ = sim;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.sim)
}

// required .planning.eudm.FunctionCfg function = 6;
inline bool Config::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || function_ != nullptr);
  return value;
}
inline bool Config::has_function() const {
  return _internal_has_function();
}
inline void Config::clear_function() {
  if (function_ != nullptr) function_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::planning::eudm::FunctionCfg& Config::_internal_function() const {
  const ::planning::eudm::FunctionCfg* p = function_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::FunctionCfg&>(
      ::planning::eudm::_FunctionCfg_default_instance_);
}
inline const ::planning::eudm::FunctionCfg& Config::function() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.function)
  return _internal_function();
}
inline void Config::unsafe_arena_set_allocated_function(
    ::planning::eudm::FunctionCfg* function) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_);
  }
  function_ = function;
  if (function) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.Config.function)
}
inline ::planning::eudm::FunctionCfg* Config::release_function() {
  _has_bits_[0] &= ~0x00000020u;
  ::planning::eudm::FunctionCfg* temp = function_;
  function_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::FunctionCfg* Config::unsafe_arena_release_function() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.function)
  _has_bits_[0] &= ~0x00000020u;
  ::planning::eudm::FunctionCfg* temp = function_;
  function_ = nullptr;
  return temp;
}
inline ::planning::eudm::FunctionCfg* Config::_internal_mutable_function() {
  _has_bits_[0] |= 0x00000020u;
  if (function_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::FunctionCfg>(GetArena());
    function_ = p;
  }
  return function_;
}
inline ::planning::eudm::FunctionCfg* Config::mutable_function() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.function)
  return _internal_mutable_function();
}
inline void Config::set_allocated_function(::planning::eudm::FunctionCfg* function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete function_;
  }
  if (function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(function);
    if (message_arena != submessage_arena) {
      function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  function_ = function;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.function)
}

// required .planning.eudm.SafetyCfg safety = 7;
inline bool Config::_internal_has_safety() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || safety_ != nullptr);
  return value;
}
inline bool Config::has_safety() const {
  return _internal_has_safety();
}
inline void Config::clear_safety() {
  if (safety_ != nullptr) safety_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::planning::eudm::SafetyCfg& Config::_internal_safety() const {
  const ::planning::eudm::SafetyCfg* p = safety_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::eudm::SafetyCfg&>(
      ::planning::eudm::_SafetyCfg_default_instance_);
}
inline const ::planning::eudm::SafetyCfg& Config::safety() const {
  // @@protoc_insertion_point(field_get:planning.eudm.Config.safety)
  return _internal_safety();
}
inline void Config::unsafe_arena_set_allocated_safety(
    ::planning::eudm::SafetyCfg* safety) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(safety_);
  }
  safety_ = safety;
  if (safety) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.eudm.Config.safety)
}
inline ::planning::eudm::SafetyCfg* Config::release_safety() {
  _has_bits_[0] &= ~0x00000040u;
  ::planning::eudm::SafetyCfg* temp = safety_;
  safety_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::eudm::SafetyCfg* Config::unsafe_arena_release_safety() {
  // @@protoc_insertion_point(field_release:planning.eudm.Config.safety)
  _has_bits_[0] &= ~0x00000040u;
  ::planning::eudm::SafetyCfg* temp = safety_;
  safety_ = nullptr;
  return temp;
}
inline ::planning::eudm::SafetyCfg* Config::_internal_mutable_safety() {
  _has_bits_[0] |= 0x00000040u;
  if (safety_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::eudm::SafetyCfg>(GetArena());
    safety_ = p;
  }
  return safety_;
}
inline ::planning::eudm::SafetyCfg* Config::mutable_safety() {
  // @@protoc_insertion_point(field_mutable:planning.eudm.Config.safety)
  return _internal_mutable_safety();
}
inline void Config::set_allocated_safety(::planning::eudm::SafetyCfg* safety) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete safety_;
  }
  if (safety) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(safety);
    if (message_arena != submessage_arena) {
      safety = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, safety, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  safety_ = safety;
  // @@protoc_insertion_point(field_set_allocated:planning.eudm.Config.safety)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace eudm
}  // namespace planning

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_eudm_5fconfig_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eudm_config.proto

#include "eudm_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace planning {
namespace eudm {
constexpr EfficiencyAssessDetail::EfficiencyAssessDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ego_lack_speed_to_desired_unit_cost_(0)
  , ego_over_speed_to_desired_unit_cost_(0)
  , ego_desired_speed_tolerate_gap_(0)
  , leading_distance_th_(0)
  , min_distance_ratio_(0)
  , ego_speed_blocked_by_leading_unit_cost_(0)
  , leading_speed_blocked_desired_vel_unit_cost_(0){}
struct EfficiencyAssessDetailDefaultTypeInternal {
  constexpr EfficiencyAssessDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EfficiencyAssessDetailDefaultTypeInternal() {}
  union {
    EfficiencyAssessDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EfficiencyAssessDetailDefaultTypeInternal _EfficiencyAssessDetail_default_instance_;
constexpr SafetyAssessDetail::SafetyAssessDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : rss_over_speed_power_coeff_(0)
  , rss_over_speed_linear_coeff_(0)
  , rss_lack_speed_power_coeff_(0)
  , rss_lack_speed_linear_coeff_(0)
  , occu_lane_unit_cost_(0)
  , rss_cost_enable_(false)
  , occu_lane_enable_(false){}
struct SafetyAssessDetailDefaultTypeInternal {
  constexpr SafetyAssessDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SafetyAssessDetailDefaultTypeInternal() {}
  union {
    SafetyAssessDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SafetyAssessDetailDefaultTypeInternal _SafetyAssessDetail_default_instance_;
constexpr UserIntentionAssessDetail::UserIntentionAssessDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : late_operate_unit_cost_(0)
  , cancel_operation_unit_cost_(0){}
struct UserIntentionAssessDetailDefaultTypeInternal {
  constexpr UserIntentionAssessDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserIntentionAssessDetailDefaultTypeInternal() {}
  union {
    UserIntentionAssessDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserIntentionAssessDetailDefaultTypeInternal _UserIntentionAssessDetail_default_instance_;
constexpr NavigationAssessDetail::NavigationAssessDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lane_change_left_unit_cost_(0)
  , lane_change_right_unit_cost_(0)
  , lane_change_unit_cost_vel_lb_(0)
  , lane_change_left_recommendation_reward_(0)
  , lane_change_right_recommendation_reward_(0){}
struct NavigationAssessDetailDefaultTypeInternal {
  constexpr NavigationAssessDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NavigationAssessDetailDefaultTypeInternal() {}
  union {
    NavigationAssessDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NavigationAssessDetailDefaultTypeInternal _NavigationAssessDetail_default_instance_;
constexpr CostAssessCfg::CostAssessCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : effciency_(nullptr)
  , safety_(nullptr)
  , user_(nullptr)
  , navigation_(nullptr)
  , discount_factor_(0){}
struct CostAssessCfgDefaultTypeInternal {
  constexpr CostAssessCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CostAssessCfgDefaultTypeInternal() {}
  union {
    CostAssessCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CostAssessCfgDefaultTypeInternal _CostAssessCfg_default_instance_;
constexpr SimDurationDetail::SimDurationDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layer_(0)
  , last_layer_(0)
  , step_(0)
  , tree_height_(0){}
struct SimDurationDetailDefaultTypeInternal {
  constexpr SimDurationDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimDurationDetailDefaultTypeInternal() {}
  union {
    SimDurationDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimDurationDetailDefaultTypeInternal _SimDurationDetail_default_instance_;
constexpr LonSimLimit::LonSimLimit(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_(0)
  , acc_jerk_(0)
  , soft_brake_(0)
  , hard_brake_(0)
  , brake_jerk_(0){}
struct LonSimLimitDefaultTypeInternal {
  constexpr LonSimLimitDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LonSimLimitDefaultTypeInternal() {}
  union {
    LonSimLimit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LonSimLimitDefaultTypeInternal _LonSimLimit_default_instance_;
constexpr LonSimIdm::LonSimIdm(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : min_spacing_(0)
  , head_time_(0)
  , exponent_(0){}
struct LonSimIdmDefaultTypeInternal {
  constexpr LonSimIdmDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LonSimIdmDefaultTypeInternal() {}
  union {
    LonSimIdm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LonSimIdmDefaultTypeInternal _LonSimIdm_default_instance_;
constexpr LonSimDetail::LonSimDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : idm_(nullptr)
  , limit_(nullptr){}
struct LonSimDetailDefaultTypeInternal {
  constexpr LonSimDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LonSimDetailDefaultTypeInternal() {}
  union {
    LonSimDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LonSimDetailDefaultTypeInternal _LonSimDetail_default_instance_;
constexpr LatSimLimit::LatSimLimit(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_(0)
  , jerk_(0)
  , curvature_(0)
  , steer_angle_(0)
  , steer_rate_(0){}
struct LatSimLimitDefaultTypeInternal {
  constexpr LatSimLimitDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LatSimLimitDefaultTypeInternal() {}
  union {
    LatSimLimit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LatSimLimitDefaultTypeInternal _LatSimLimit_default_instance_;
constexpr LatSimPurePursuit::LatSimPurePursuit(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gain_(0)
  , max_lookahead_dist_(0)
  , min_lookahead_dist_(0){}
struct LatSimPurePursuitDefaultTypeInternal {
  constexpr LatSimPurePursuitDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LatSimPurePursuitDefaultTypeInternal() {}
  union {
    LatSimPurePursuit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LatSimPurePursuitDefaultTypeInternal _LatSimPurePursuit_default_instance_;
constexpr LatSimDetail::LatSimDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pure_pursuit_(nullptr)
  , limit_(nullptr){}
struct LatSimDetailDefaultTypeInternal {
  constexpr LatSimDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LatSimDetailDefaultTypeInternal() {}
  union {
    LatSimDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LatSimDetailDefaultTypeInternal _LatSimDetail_default_instance_;
constexpr EvasiveSimDetail::EvasiveSimDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lon_acc_(0)
  , lon_jerk_(0)
  , lon_extraspeed_(0)
  , head_time_(0)
  , virtual_barrier_tic_(0)
  , evasive_enable_(false)
  , virtual_barrier_enable_(false){}
struct EvasiveSimDetailDefaultTypeInternal {
  constexpr EvasiveSimDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EvasiveSimDetailDefaultTypeInternal() {}
  union {
    EvasiveSimDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EvasiveSimDetailDefaultTypeInternal _EvasiveSimDetail_default_instance_;
constexpr ForwardSimDetail::ForwardSimDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lon_(nullptr)
  , lat_(nullptr)
  , evasive_(nullptr)
  , cooperative_lat_range_(0)
  , lon_aggressive_ratio_(0)
  , auto_dec_if_lat_failed_(false){}
struct ForwardSimDetailDefaultTypeInternal {
  constexpr ForwardSimDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ForwardSimDetailDefaultTypeInternal() {}
  union {
    ForwardSimDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ForwardSimDetailDefaultTypeInternal _ForwardSimDetail_default_instance_;
constexpr SimRefLine::SimRefLine(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : len_vel_coeff_(0)
  , forward_len_max_(0)
  , forward_len_min_(0)
  , backward_len_max_(0){}
struct SimRefLineDefaultTypeInternal {
  constexpr SimRefLineDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimRefLineDefaultTypeInternal() {}
  union {
    SimRefLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimRefLineDefaultTypeInternal _SimRefLine_default_instance_;
constexpr SimCfg::SimCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : duration_(nullptr)
  , ego_(nullptr)
  , agent_(nullptr)
  , ref_line_(nullptr)
  , acc_cmd_vel_gap_(0)
  , dec_cmd_vel_gap_(0){}
struct SimCfgDefaultTypeInternal {
  constexpr SimCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimCfgDefaultTypeInternal() {}
  union {
    SimCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimCfgDefaultTypeInternal _SimCfg_default_instance_;
constexpr ActiveLaneChangeCfg::ActiveLaneChangeCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cold_duration_(0)
  , activate_speed_lower_bound_(0)
  , activate_speed_upper_bound_(0)
  , activate_max_duration_in_seconds_(0)
  , active_min_operation_in_seconds_(0)
  , consistent_operate_time_min_gap_(0)
  , consistent_min_num_frame_(0)
  , auto_cancel_if_late_for_seconds_(0)
  , enable_clear_accumulation_by_forbid_signal_(false)
  , enable_auto_cancel_by_forbid_signal_(false)
  , enable_auto_cancel_by_outdate_time_(false)
  , enable_auto_canbel_by_stick_signal_(false){}
struct ActiveLaneChangeCfgDefaultTypeInternal {
  constexpr ActiveLaneChangeCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActiveLaneChangeCfgDefaultTypeInternal() {}
  union {
    ActiveLaneChangeCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActiveLaneChangeCfgDefaultTypeInternal _ActiveLaneChangeCfg_default_instance_;
constexpr FunctionCfg::FunctionCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : active_lc_(nullptr)
  , stick_lane_change_in_seconds_(0)
  , mobil_enable_(false)
  , active_lc_enable_(false){}
struct FunctionCfgDefaultTypeInternal {
  constexpr FunctionCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FunctionCfgDefaultTypeInternal() {}
  union {
    FunctionCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FunctionCfgDefaultTypeInternal _FunctionCfg_default_instance_;
constexpr RssCfg::RssCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : response_time_(0)
  , longitudinal_acc_max_(0)
  , longitudinal_brake_min_(0)
  , longitudinal_brake_max_(0)
  , lateral_acc_max_(0)
  , lateral_brake_min_(0)
  , lateral_brake_max_(0)
  , lateral_miu_(0){}
struct RssCfgDefaultTypeInternal {
  constexpr RssCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RssCfgDefaultTypeInternal() {}
  union {
    RssCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RssCfgDefaultTypeInternal _RssCfg_default_instance_;
constexpr StrictCheckCfg::StrictCheckCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : inflation_w_(0)
  , inflation_h_(0){}
struct StrictCheckCfgDefaultTypeInternal {
  constexpr StrictCheckCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StrictCheckCfgDefaultTypeInternal() {}
  union {
    StrictCheckCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StrictCheckCfgDefaultTypeInternal _StrictCheckCfg_default_instance_;
constexpr SafetyCfg::SafetyCfg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : strict_(nullptr)
  , rss_(nullptr)
  , rss_strict_as_front_(nullptr)
  , rss_strict_as_rear_(nullptr)
  , strict_check_enable_(false)
  , rss_check_enable_(false)
  , rss_for_layers_enable_(false){}
struct SafetyCfgDefaultTypeInternal {
  constexpr SafetyCfgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SafetyCfgDefaultTypeInternal() {}
  union {
    SafetyCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SafetyCfgDefaultTypeInternal _SafetyCfg_default_instance_;
constexpr Config::Config(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cost_(nullptr)
  , sim_(nullptr)
  , function_(nullptr)
  , safety_(nullptr){}
struct ConfigDefaultTypeInternal {
  constexpr ConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigDefaultTypeInternal() {}
  union {
    Config _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigDefaultTypeInternal _Config_default_instance_;
}  // namespace eudm
}  // namespace planning
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_eudm_5fconfig_2eproto[22];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_eudm_5fconfig_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_eudm_5fconfig_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_eudm_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, ego_lack_speed_to_desired_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, ego_over_speed_to_desired_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, ego_desired_speed_tolerate_gap_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, leading_distance_th_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, min_distance_ratio_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, ego_speed_blocked_by_leading_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EfficiencyAssessDetail, leading_speed_blocked_desired_vel_unit_cost_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, rss_cost_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, rss_over_speed_power_coeff_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, rss_over_speed_linear_coeff_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, rss_lack_speed_power_coeff_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, rss_lack_speed_linear_coeff_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, occu_lane_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyAssessDetail, occu_lane_unit_cost_),
  5,
  0,
  1,
  2,
  3,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::UserIntentionAssessDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::UserIntentionAssessDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::UserIntentionAssessDetail, late_operate_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::UserIntentionAssessDetail, cancel_operation_unit_cost_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, lane_change_left_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, lane_change_right_unit_cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, lane_change_unit_cost_vel_lb_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, lane_change_left_recommendation_reward_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::NavigationAssessDetail, lane_change_right_recommendation_reward_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, effciency_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, safety_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, user_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, navigation_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::CostAssessCfg, discount_factor_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, layer_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, last_layer_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, step_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimDurationDetail, tree_height_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, acc_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, acc_jerk_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, soft_brake_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, hard_brake_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimLimit, brake_jerk_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimIdm, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimIdm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimIdm, min_spacing_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimIdm, head_time_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimIdm, exponent_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimDetail, idm_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LonSimDetail, limit_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, acc_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, jerk_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, curvature_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, steer_angle_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimLimit, steer_rate_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimPurePursuit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimPurePursuit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimPurePursuit, gain_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimPurePursuit, max_lookahead_dist_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimPurePursuit, min_lookahead_dist_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimDetail, pure_pursuit_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::LatSimDetail, limit_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, evasive_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, lon_acc_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, lon_jerk_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, lon_extraspeed_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, head_time_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, virtual_barrier_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::EvasiveSimDetail, virtual_barrier_tic_),
  5,
  0,
  1,
  2,
  3,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, lon_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, lat_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, evasive_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, auto_dec_if_lat_failed_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, cooperative_lat_range_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ForwardSimDetail, lon_aggressive_ratio_),
  0,
  1,
  2,
  5,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, len_vel_coeff_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, forward_len_max_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, forward_len_min_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimRefLine, backward_len_max_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, duration_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, ego_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, agent_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, acc_cmd_vel_gap_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, dec_cmd_vel_gap_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SimCfg, ref_line_),
  0,
  1,
  2,
  4,
  5,
  3,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, cold_duration_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, activate_speed_lower_bound_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, activate_speed_upper_bound_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, activate_max_duration_in_seconds_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, active_min_operation_in_seconds_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, consistent_operate_time_min_gap_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, consistent_min_num_frame_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, enable_clear_accumulation_by_forbid_signal_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, enable_auto_cancel_by_forbid_signal_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, enable_auto_cancel_by_outdate_time_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, enable_auto_canbel_by_stick_signal_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::ActiveLaneChangeCfg, auto_cancel_if_late_for_seconds_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  8,
  9,
  10,
  11,
  7,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, mobil_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, active_lc_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, active_lc_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::FunctionCfg, stick_lane_change_in_seconds_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, response_time_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, longitudinal_acc_max_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, longitudinal_brake_min_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, longitudinal_brake_max_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, lateral_acc_max_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, lateral_brake_min_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, lateral_brake_max_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::RssCfg, lateral_miu_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::StrictCheckCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::StrictCheckCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::StrictCheckCfg, inflation_w_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::StrictCheckCfg, inflation_h_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, strict_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, strict_check_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, rss_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, rss_check_enable_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, rss_strict_as_front_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, rss_strict_as_rear_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::SafetyCfg, rss_for_layers_enable_),
  0,
  4,
  1,
  5,
  2,
  3,
  6,
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, name_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, version_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, status_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, cost_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, sim_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, function_),
  PROTOBUF_FIELD_OFFSET(::planning::eudm::Config, safety_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, sizeof(::planning::eudm::EfficiencyAssessDetail)},
  { 19, 31, sizeof(::planning::eudm::SafetyAssessDetail)},
  { 38, 45, sizeof(::planning::eudm::UserIntentionAssessDetail)},
  { 47, 57, sizeof(::planning::eudm::NavigationAssessDetail)},
  { 62, 72, sizeof(::planning::eudm::CostAssessCfg)},
  { 77, 86, sizeof(::planning::eudm::SimDurationDetail)},
  { 90, 100, sizeof(::planning::eudm::LonSimLimit)},
  { 105, 113, sizeof(::planning::eudm::LonSimIdm)},
  { 116, 123, sizeof(::planning::eudm::LonSimDetail)},
  { 125, 135, sizeof(::planning::eudm::LatSimLimit)},
  { 140, 148, sizeof(::planning::eudm::LatSimPurePursuit)},
  { 151, 158, sizeof(::planning::eudm::LatSimDetail)},
  { 160, 172, sizeof(::planning::eudm::EvasiveSimDetail)},
  { 179, 190, sizeof(::planning::eudm::ForwardSimDetail)},
  { 196, 205, sizeof(::planning::eudm::SimRefLine)},
  { 209, 220, sizeof(::planning::eudm::SimCfg)},
  { 226, 243, sizeof(::planning::eudm::ActiveLaneChangeCfg)},
  { 255, 264, sizeof(::planning::eudm::FunctionCfg)},
  { 268, 281, sizeof(::planning::eudm::RssCfg)},
  { 289, 296, sizeof(::planning::eudm::StrictCheckCfg)},
  { 298, 310, sizeof(::planning::eudm::SafetyCfg)},
  { 317, 329, sizeof(::planning::eudm::Config)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_EfficiencyAssessDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_SafetyAssessDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_UserIntentionAssessDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_NavigationAssessDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_CostAssessCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_SimDurationDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LonSimLimit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LonSimIdm_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LonSimDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LatSimLimit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LatSimPurePursuit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_LatSimDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_EvasiveSimDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_ForwardSimDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_SimRefLine_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_SimCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_ActiveLaneChangeCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_FunctionCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_RssCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_StrictCheckCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_SafetyCfg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::planning::eudm::_Config_default_instance_),
};

const char descriptor_table_protodef_eudm_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021eudm_config.proto\022\rplanning.eudm\"\270\002\n\026E"
  "fficiencyAssessDetail\022+\n#ego_lack_speed_"
  "to_desired_unit_cost\030\001 \002(\001\022+\n#ego_over_s"
  "peed_to_desired_unit_cost\030\002 \002(\001\022&\n\036ego_d"
  "esired_speed_tolerate_gap\030\003 \002(\001\022\033\n\023leadi"
  "ng_distance_th\030\004 \002(\001\022\032\n\022min_distance_rat"
  "io\030\005 \002(\001\022.\n&ego_speed_blocked_by_leading"
  "_unit_cost\030\006 \002(\001\0223\n+leading_speed_blocke"
  "d_desired_vel_unit_cost\030\007 \002(\001\"\366\001\n\022Safety"
  "AssessDetail\022\027\n\017rss_cost_enable\030\001 \002(\010\022\"\n"
  "\032rss_over_speed_power_coeff\030\002 \002(\001\022#\n\033rss"
  "_over_speed_linear_coeff\030\003 \002(\001\022\"\n\032rss_la"
  "ck_speed_power_coeff\030\004 \002(\001\022#\n\033rss_lack_s"
  "peed_linear_coeff\030\005 \002(\001\022\030\n\020occu_lane_ena"
  "ble\030\006 \002(\010\022\033\n\023occu_lane_unit_cost\030\007 \002(\001\"_"
  "\n\031UserIntentionAssessDetail\022\036\n\026late_oper"
  "ate_unit_cost\030\001 \002(\001\022\"\n\032cancel_operation_"
  "unit_cost\030\002 \002(\001\"\350\001\n\026NavigationAssessDeta"
  "il\022\"\n\032lane_change_left_unit_cost\030\001 \002(\001\022#"
  "\n\033lane_change_right_unit_cost\030\002 \002(\001\022$\n\034l"
  "ane_change_unit_cost_vel_lb\030\003 \002(\001\022.\n&lan"
  "e_change_left_recommendation_reward\030\004 \002("
  "\001\022/\n\'lane_change_right_recommendation_re"
  "ward\030\005 \002(\001\"\210\002\n\rCostAssessCfg\0228\n\teffcienc"
  "y\030\001 \002(\0132%.planning.eudm.EfficiencyAssess"
  "Detail\0221\n\006safety\030\002 \002(\0132!.planning.eudm.S"
  "afetyAssessDetail\0226\n\004user\030\003 \002(\0132(.planni"
  "ng.eudm.UserIntentionAssessDetail\0229\n\nnav"
  "igation\030\004 \002(\0132%.planning.eudm.Navigation"
  "AssessDetail\022\027\n\017discount_factor\030\005 \002(\001\"Y\n"
  "\021SimDurationDetail\022\r\n\005layer\030\001 \002(\001\022\022\n\nlas"
  "t_layer\030\002 \002(\001\022\014\n\004step\030\003 \002(\001\022\023\n\013tree_heig"
  "ht\030\004 \002(\005\"h\n\013LonSimLimit\022\013\n\003acc\030\001 \002(\001\022\020\n\010"
  "acc_jerk\030\002 \002(\001\022\022\n\nsoft_brake\030\003 \002(\001\022\022\n\nha"
  "rd_brake\030\004 \002(\001\022\022\n\nbrake_jerk\030\005 \002(\001\"E\n\tLo"
  "nSimIdm\022\023\n\013min_spacing\030\001 \002(\001\022\021\n\thead_tim"
  "e\030\002 \002(\001\022\020\n\010exponent\030\003 \002(\005\"`\n\014LonSimDetai"
  "l\022%\n\003idm\030\001 \002(\0132\030.planning.eudm.LonSimIdm"
  "\022)\n\005limit\030\002 \002(\0132\032.planning.eudm.LonSimLi"
  "mit\"d\n\013LatSimLimit\022\013\n\003acc\030\001 \002(\001\022\014\n\004jerk\030"
  "\002 \002(\001\022\021\n\tcurvature\030\003 \002(\001\022\023\n\013steer_angle\030"
  "\004 \002(\001\022\022\n\nsteer_rate\030\005 \002(\001\"Y\n\021LatSimPureP"
  "ursuit\022\014\n\004gain\030\001 \002(\001\022\032\n\022max_lookahead_di"
  "st\030\002 \002(\001\022\032\n\022min_lookahead_dist\030\003 \002(\001\"q\n\014"
  "LatSimDetail\0226\n\014pure_pursuit\030\001 \002(\0132 .pla"
  "nning.eudm.LatSimPurePursuit\022)\n\005limit\030\002 "
  "\002(\0132\032.planning.eudm.LatSimLimit\"\265\001\n\020Evas"
  "iveSimDetail\022\026\n\016evasive_enable\030\001 \002(\010\022\017\n\007"
  "lon_acc\030\002 \002(\001\022\020\n\010lon_jerk\030\003 \002(\001\022\026\n\016lon_e"
  "xtraspeed\030\004 \002(\001\022\021\n\thead_time\030\005 \002(\001\022\036\n\026vi"
  "rtual_barrier_enable\030\006 \002(\010\022\033\n\023virtual_ba"
  "rrier_tic\030\007 \002(\001\"\365\001\n\020ForwardSimDetail\022(\n\003"
  "lon\030\001 \002(\0132\033.planning.eudm.LonSimDetail\022("
  "\n\003lat\030\002 \002(\0132\033.planning.eudm.LatSimDetail"
  "\0220\n\007evasive\030\003 \002(\0132\037.planning.eudm.Evasiv"
  "eSimDetail\022\036\n\026auto_dec_if_lat_failed\030\004 \002"
  "(\010\022\035\n\025cooperative_lat_range\030\005 \002(\001\022\034\n\024lon"
  "_aggressive_ratio\030\006 \002(\001\"o\n\nSimRefLine\022\025\n"
  "\rlen_vel_coeff\030\001 \002(\001\022\027\n\017forward_len_max\030"
  "\002 \002(\001\022\027\n\017forward_len_min\030\003 \002(\001\022\030\n\020backwa"
  "rd_len_max\030\004 \002(\001\"\371\001\n\006SimCfg\0222\n\010duration\030"
  "\001 \002(\0132 .planning.eudm.SimDurationDetail\022"
  ",\n\003ego\030\002 \002(\0132\037.planning.eudm.ForwardSimD"
  "etail\022.\n\005agent\030\003 \002(\0132\037.planning.eudm.For"
  "wardSimDetail\022\027\n\017acc_cmd_vel_gap\030\004 \002(\001\022\027"
  "\n\017dec_cmd_vel_gap\030\005 \002(\001\022+\n\010ref_line\030\006 \002("
  "\0132\031.planning.eudm.SimRefLine\"\364\003\n\023ActiveL"
  "aneChangeCfg\022\025\n\rcold_duration\030\001 \002(\001\022\"\n\032a"
  "ctivate_speed_lower_bound\030\002 \002(\001\022\"\n\032activ"
  "ate_speed_upper_bound\030\003 \002(\001\022(\n activate_"
  "max_duration_in_seconds\030\004 \002(\001\022\'\n\037active_"
  "min_operation_in_seconds\030\005 \002(\001\022\'\n\037consis"
  "tent_operate_time_min_gap\030\006 \002(\001\022 \n\030consi"
  "stent_min_num_frame\030\007 \002(\001\0222\n*enable_clea"
  "r_accumulation_by_forbid_signal\030\010 \002(\010\022+\n"
  "#enable_auto_cancel_by_forbid_signal\030\t \002"
  "(\010\022*\n\"enable_auto_cancel_by_outdate_time"
  "\030\n \002(\010\022*\n\"enable_auto_canbel_by_stick_si"
  "gnal\030\013 \002(\010\022\'\n\037auto_cancel_if_late_for_se"
  "conds\030\014 \002(\001\"\232\001\n\013FunctionCfg\022\024\n\014mobil_ena"
  "ble\030\001 \002(\010\022\030\n\020active_lc_enable\030\002 \002(\010\0225\n\ta"
  "ctive_lc\030\003 \002(\0132\".planning.eudm.ActiveLan"
  "eChangeCfg\022$\n\034stick_lane_change_in_secon"
  "ds\030\004 \002(\001\"\341\001\n\006RssCfg\022\025\n\rresponse_time\030\001 \002"
  "(\001\022\034\n\024longitudinal_acc_max\030\002 \002(\001\022\036\n\026long"
  "itudinal_brake_min\030\003 \002(\001\022\036\n\026longitudinal"
  "_brake_max\030\004 \002(\001\022\027\n\017lateral_acc_max\030\005 \002("
  "\001\022\031\n\021lateral_brake_min\030\006 \002(\001\022\031\n\021lateral_"
  "brake_max\030\007 \002(\001\022\023\n\013lateral_miu\030\010 \002(\001\":\n\016"
  "StrictCheckCfg\022\023\n\013inflation_w\030\001 \002(\001\022\023\n\013i"
  "nflation_h\030\002 \002(\001\"\233\002\n\tSafetyCfg\022-\n\006strict"
  "\030\001 \002(\0132\035.planning.eudm.StrictCheckCfg\022\033\n"
  "\023strict_check_enable\030\002 \002(\010\022\"\n\003rss\030\003 \002(\0132"
  "\025.planning.eudm.RssCfg\022\030\n\020rss_check_enab"
  "le\030\004 \002(\010\0222\n\023rss_strict_as_front\030\005 \002(\0132\025."
  "planning.eudm.RssCfg\0221\n\022rss_strict_as_re"
  "ar\030\006 \002(\0132\025.planning.eudm.RssCfg\022\035\n\025rss_f"
  "or_layers_enable\030\007 \002(\010\"\337\001\n\006Config\022\014\n\004nam"
  "e\030\001 \002(\t\022\017\n\007version\030\002 \002(\t\022\016\n\006status\030\003 \002(\t"
  "\022*\n\004cost\030\004 \002(\0132\034.planning.eudm.CostAsses"
  "sCfg\022\"\n\003sim\030\005 \002(\0132\025.planning.eudm.SimCfg"
  "\022,\n\010function\030\006 \002(\0132\032.planning.eudm.Funct"
  "ionCfg\022(\n\006safety\030\007 \002(\0132\030.planning.eudm.S"
  "afetyCfg"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_eudm_5fconfig_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_eudm_5fconfig_2eproto = {
  false, false, 4128, descriptor_table_protodef_eudm_5fconfig_2eproto, "eudm_config.proto", 
  &descriptor_table_eudm_5fconfig_2eproto_once, nullptr, 0, 22,
  schemas, file_default_instances, TableStruct_eudm_5fconfig_2eproto::offsets,
  file_level_metadata_eudm_5fconfig_2eproto, file_level_enum_descriptors_eudm_5fconfig_2eproto, file_level_service_descriptors_eudm_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK ::PROTOBUF_NAMESPACE_ID::Metadata
descriptor_table_eudm_5fconfig_2eproto_metadata_getter(int index) {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_eudm_5fconfig_2eproto);
  return descriptor_table_eudm_5fconfig_2eproto.file_level_metadata[index];
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_eudm_5fconfig_2eproto(&descriptor_table_eudm_5fconfig_2eproto);
namespace planning {
namespace eudm {

// ===================================================================

class EfficiencyAssessDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<EfficiencyAssessDetail>()._has_bits_);
  static void set_has_ego_lack_speed_to_desired_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ego_over_speed_to_desired_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ego_desired_speed_tolerate_gap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_leading_distance_th(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_distance_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ego_speed_blocked_by_leading_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leading_speed_blocked_desired_vel_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

EfficiencyAssessDetail::EfficiencyAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.EfficiencyAssessDetail)
}
EfficiencyAssessDetail::EfficiencyAssessDetail(const EfficiencyAssessDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ego_lack_speed_to_desired_unit_cost_, &from.ego_lack_speed_to_desired_unit_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&leading_speed_blocked_desired_vel_unit_cost_) -
    reinterpret_cast<char*>(&ego_lack_speed_to_desired_unit_cost_)) + sizeof(leading_speed_blocked_desired_vel_unit_cost_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.EfficiencyAssessDetail)
}

void EfficiencyAssessDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ego_lack_speed_to_desired_unit_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&leading_speed_blocked_desired_vel_unit_cost_) -
    reinterpret_cast<char*>(&ego_lack_speed_to_desired_unit_cost_)) + sizeof(leading_speed_blocked_desired_vel_unit_cost_));
}

EfficiencyAssessDetail::~EfficiencyAssessDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.EfficiencyAssessDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EfficiencyAssessDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EfficiencyAssessDetail::ArenaDtor(void* object) {
  EfficiencyAssessDetail* _this = reinterpret_cast< EfficiencyAssessDetail* >(object);
  (void)_this;
}
void EfficiencyAssessDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EfficiencyAssessDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EfficiencyAssessDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.EfficiencyAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&ego_lack_speed_to_desired_unit_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&leading_speed_blocked_desired_vel_unit_cost_) -
        reinterpret_cast<char*>(&ego_lack_speed_to_desired_unit_cost_)) + sizeof(leading_speed_blocked_desired_vel_unit_cost_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EfficiencyAssessDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double ego_lack_speed_to_desired_unit_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_ego_lack_speed_to_desired_unit_cost(&has_bits);
          ego_lack_speed_to_desired_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double ego_over_speed_to_desired_unit_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_ego_over_speed_to_desired_unit_cost(&has_bits);
          ego_over_speed_to_desired_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double ego_desired_speed_tolerate_gap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_ego_desired_speed_tolerate_gap(&has_bits);
          ego_desired_speed_tolerate_gap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double leading_distance_th = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_leading_distance_th(&has_bits);
          leading_distance_th_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double min_distance_ratio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_min_distance_ratio(&has_bits);
          min_distance_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double ego_speed_blocked_by_leading_unit_cost = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_ego_speed_blocked_by_leading_unit_cost(&has_bits);
          ego_speed_blocked_by_leading_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double leading_speed_blocked_desired_vel_unit_cost = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_leading_speed_blocked_desired_vel_unit_cost(&has_bits);
          leading_speed_blocked_desired_vel_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EfficiencyAssessDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.EfficiencyAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double ego_lack_speed_to_desired_unit_cost = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_ego_lack_speed_to_desired_unit_cost(), target);
  }

  // required double ego_over_speed_to_desired_unit_cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_ego_over_speed_to_desired_unit_cost(), target);
  }

  // required double ego_desired_speed_tolerate_gap = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_ego_desired_speed_tolerate_gap(), target);
  }

  // required double leading_distance_th = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_leading_distance_th(), target);
  }

  // required double min_distance_ratio = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_min_distance_ratio(), target);
  }

  // required double ego_speed_blocked_by_leading_unit_cost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_ego_speed_blocked_by_leading_unit_cost(), target);
  }

  // required double leading_speed_blocked_desired_vel_unit_cost = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_leading_speed_blocked_desired_vel_unit_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.EfficiencyAssessDetail)
  return target;
}

size_t EfficiencyAssessDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.EfficiencyAssessDetail)
  size_t total_size = 0;

  if (_internal_has_ego_lack_speed_to_desired_unit_cost()) {
    // required double ego_lack_speed_to_desired_unit_cost = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_ego_over_speed_to_desired_unit_cost()) {
    // required double ego_over_speed_to_desired_unit_cost = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_ego_desired_speed_tolerate_gap()) {
    // required double ego_desired_speed_tolerate_gap = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_leading_distance_th()) {
    // required double leading_distance_th = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_min_distance_ratio()) {
    // required double min_distance_ratio = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_ego_speed_blocked_by_leading_unit_cost()) {
    // required double ego_speed_blocked_by_leading_unit_cost = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_leading_speed_blocked_desired_vel_unit_cost()) {
    // required double leading_speed_blocked_desired_vel_unit_cost = 7;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EfficiencyAssessDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.EfficiencyAssessDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required double ego_lack_speed_to_desired_unit_cost = 1;
    total_size += 1 + 8;

    // required double ego_over_speed_to_desired_unit_cost = 2;
    total_size += 1 + 8;

    // required double ego_desired_speed_tolerate_gap = 3;
    total_size += 1 + 8;

    // required double leading_distance_th = 4;
    total_size += 1 + 8;

    // required double min_distance_ratio = 5;
    total_size += 1 + 8;

    // required double ego_speed_blocked_by_leading_unit_cost = 6;
    total_size += 1 + 8;

    // required double leading_speed_blocked_desired_vel_unit_cost = 7;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EfficiencyAssessDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.EfficiencyAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const EfficiencyAssessDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EfficiencyAssessDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.EfficiencyAssessDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.EfficiencyAssessDetail)
    MergeFrom(*source);
  }
}

void EfficiencyAssessDetail::MergeFrom(const EfficiencyAssessDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.EfficiencyAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ego_lack_speed_to_desired_unit_cost_ = from.ego_lack_speed_to_desired_unit_cost_;
    }
    if (cached_has_bits & 0x00000002u) {
      ego_over_speed_to_desired_unit_cost_ = from.ego_over_speed_to_desired_unit_cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      ego_desired_speed_tolerate_gap_ = from.ego_desired_speed_tolerate_gap_;
    }
    if (cached_has_bits & 0x00000008u) {
      leading_distance_th_ = from.leading_distance_th_;
    }
    if (cached_has_bits & 0x00000010u) {
      min_distance_ratio_ = from.min_distance_ratio_;
    }
    if (cached_has_bits & 0x00000020u) {
      ego_speed_blocked_by_leading_unit_cost_ = from.ego_speed_blocked_by_leading_unit_cost_;
    }
    if (cached_has_bits & 0x00000040u) {
      leading_speed_blocked_desired_vel_unit_cost_ = from.leading_speed_blocked_desired_vel_unit_cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EfficiencyAssessDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.EfficiencyAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EfficiencyAssessDetail::CopyFrom(const EfficiencyAssessDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.EfficiencyAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EfficiencyAssessDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EfficiencyAssessDetail::InternalSwap(EfficiencyAssessDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EfficiencyAssessDetail, leading_speed_blocked_desired_vel_unit_cost_)
      + sizeof(EfficiencyAssessDetail::leading_speed_blocked_desired_vel_unit_cost_)
      - PROTOBUF_FIELD_OFFSET(EfficiencyAssessDetail, ego_lack_speed_to_desired_unit_cost_)>(
          reinterpret_cast<char*>(&ego_lack_speed_to_desired_unit_cost_),
          reinterpret_cast<char*>(&other->ego_lack_speed_to_desired_unit_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EfficiencyAssessDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class SafetyAssessDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<SafetyAssessDetail>()._has_bits_);
  static void set_has_rss_cost_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_rss_over_speed_power_coeff(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rss_over_speed_linear_coeff(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rss_lack_speed_power_coeff(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rss_lack_speed_linear_coeff(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_occu_lane_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_occu_lane_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

SafetyAssessDetail::SafetyAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.SafetyAssessDetail)
}
SafetyAssessDetail::SafetyAssessDetail(const SafetyAssessDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rss_over_speed_power_coeff_, &from.rss_over_speed_power_coeff_,
    static_cast<size_t>(reinterpret_cast<char*>(&occu_lane_enable_) -
    reinterpret_cast<char*>(&rss_over_speed_power_coeff_)) + sizeof(occu_lane_enable_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.SafetyAssessDetail)
}

void SafetyAssessDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rss_over_speed_power_coeff_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&occu_lane_enable_) -
    reinterpret_cast<char*>(&rss_over_speed_power_coeff_)) + sizeof(occu_lane_enable_));
}

SafetyAssessDetail::~SafetyAssessDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.SafetyAssessDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SafetyAssessDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SafetyAssessDetail::ArenaDtor(void* object) {
  SafetyAssessDetail* _this = reinterpret_cast< SafetyAssessDetail* >(object);
  (void)_this;
}
void SafetyAssessDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SafetyAssessDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SafetyAssessDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.SafetyAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&rss_over_speed_power_coeff_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&occu_lane_enable_) -
        reinterpret_cast<char*>(&rss_over_speed_power_coeff_)) + sizeof(occu_lane_enable_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SafetyAssessDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool rss_cost_enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_rss_cost_enable(&has_bits);
          rss_cost_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double rss_over_speed_power_coeff = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_rss_over_speed_power_coeff(&has_bits);
          rss_over_speed_power_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double rss_over_speed_linear_coeff = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_rss_over_speed_linear_coeff(&has_bits);
          rss_over_speed_linear_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double rss_lack_speed_power_coeff = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_rss_lack_speed_power_coeff(&has_bits);
          rss_lack_speed_power_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double rss_lack_speed_linear_coeff = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_rss_lack_speed_linear_coeff(&has_bits);
          rss_lack_speed_linear_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required bool occu_lane_enable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_occu_lane_enable(&has_bits);
          occu_lane_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double occu_lane_unit_cost = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_occu_lane_unit_cost(&has_bits);
          occu_lane_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SafetyAssessDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.SafetyAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool rss_cost_enable = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_rss_cost_enable(), target);
  }

  // required double rss_over_speed_power_coeff = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_rss_over_speed_power_coeff(), target);
  }

  // required double rss_over_speed_linear_coeff = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_rss_over_speed_linear_coeff(), target);
  }

  // required double rss_lack_speed_power_coeff = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_rss_lack_speed_power_coeff(), target);
  }

  // required double rss_lack_speed_linear_coeff = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_rss_lack_speed_linear_coeff(), target);
  }

  // required bool occu_lane_enable = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_occu_lane_enable(), target);
  }

  // required double occu_lane_unit_cost = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_occu_lane_unit_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.SafetyAssessDetail)
  return target;
}

size_t SafetyAssessDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.SafetyAssessDetail)
  size_t total_size = 0;

  if (_internal_has_rss_over_speed_power_coeff()) {
    // required double rss_over_speed_power_coeff = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_rss_over_speed_linear_coeff()) {
    // required double rss_over_speed_linear_coeff = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_rss_lack_speed_power_coeff()) {
    // required double rss_lack_speed_power_coeff = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_rss_lack_speed_linear_coeff()) {
    // required double rss_lack_speed_linear_coeff = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_occu_lane_unit_cost()) {
    // required double occu_lane_unit_cost = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_rss_cost_enable()) {
    // required bool rss_cost_enable = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_occu_lane_enable()) {
    // required bool occu_lane_enable = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t SafetyAssessDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.SafetyAssessDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required double rss_over_speed_power_coeff = 2;
    total_size += 1 + 8;

    // required double rss_over_speed_linear_coeff = 3;
    total_size += 1 + 8;

    // required double rss_lack_speed_power_coeff = 4;
    total_size += 1 + 8;

    // required double rss_lack_speed_linear_coeff = 5;
    total_size += 1 + 8;

    // required double occu_lane_unit_cost = 7;
    total_size += 1 + 8;

    // required bool rss_cost_enable = 1;
    total_size += 1 + 1;

    // required bool occu_lane_enable = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SafetyAssessDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.SafetyAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const SafetyAssessDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SafetyAssessDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.SafetyAssessDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.SafetyAssessDetail)
    MergeFrom(*source);
  }
}

void SafetyAssessDetail::MergeFrom(const SafetyAssessDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.SafetyAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      rss_over_speed_power_coeff_ = from.rss_over_speed_power_coeff_;
    }
    if (cached_has_bits & 0x00000002u) {
      rss_over_speed_linear_coeff_ = from.rss_over_speed_linear_coeff_;
    }
    if (cached_has_bits & 0x00000004u) {
      rss_lack_speed_power_coeff_ = from.rss_lack_speed_power_coeff_;
    }
    if (cached_has_bits & 0x00000008u) {
      rss_lack_speed_linear_coeff_ = from.rss_lack_speed_linear_coeff_;
    }
    if (cached_has_bits & 0x00000010u) {
      occu_lane_unit_cost_ = from.occu_lane_unit_cost_;
    }
    if (cached_has_bits & 0x00000020u) {
      rss_cost_enable_ = from.rss_cost_enable_;
    }
    if (cached_has_bits & 0x00000040u) {
      occu_lane_enable_ = from.occu_lane_enable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SafetyAssessDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.SafetyAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SafetyAssessDetail::CopyFrom(const SafetyAssessDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.SafetyAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SafetyAssessDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SafetyAssessDetail::InternalSwap(SafetyAssessDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SafetyAssessDetail, occu_lane_enable_)
      + sizeof(SafetyAssessDetail::occu_lane_enable_)
      - PROTOBUF_FIELD_OFFSET(SafetyAssessDetail, rss_over_speed_power_coeff_)>(
          reinterpret_cast<char*>(&rss_over_speed_power_coeff_),
          reinterpret_cast<char*>(&other->rss_over_speed_power_coeff_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SafetyAssessDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class UserIntentionAssessDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<UserIntentionAssessDetail>()._has_bits_);
  static void set_has_late_operate_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cancel_operation_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserIntentionAssessDetail::UserIntentionAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.UserIntentionAssessDetail)
}
UserIntentionAssessDetail::UserIntentionAssessDetail(const UserIntentionAssessDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&late_operate_unit_cost_, &from.late_operate_unit_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&cancel_operation_unit_cost_) -
    reinterpret_cast<char*>(&late_operate_unit_cost_)) + sizeof(cancel_operation_unit_cost_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.UserIntentionAssessDetail)
}

void UserIntentionAssessDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&late_operate_unit_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cancel_operation_unit_cost_) -
    reinterpret_cast<char*>(&late_operate_unit_cost_)) + sizeof(cancel_operation_unit_cost_));
}

UserIntentionAssessDetail::~UserIntentionAssessDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.UserIntentionAssessDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void UserIntentionAssessDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void UserIntentionAssessDetail::ArenaDtor(void* object) {
  UserIntentionAssessDetail* _this = reinterpret_cast< UserIntentionAssessDetail* >(object);
  (void)_this;
}
void UserIntentionAssessDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserIntentionAssessDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserIntentionAssessDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.UserIntentionAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&late_operate_unit_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cancel_operation_unit_cost_) -
        reinterpret_cast<char*>(&late_operate_unit_cost_)) + sizeof(cancel_operation_unit_cost_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserIntentionAssessDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double late_operate_unit_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_late_operate_unit_cost(&has_bits);
          late_operate_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double cancel_operation_unit_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_cancel_operation_unit_cost(&has_bits);
          cancel_operation_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UserIntentionAssessDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.UserIntentionAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double late_operate_unit_cost = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_late_operate_unit_cost(), target);
  }

  // required double cancel_operation_unit_cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_cancel_operation_unit_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.UserIntentionAssessDetail)
  return target;
}

size_t UserIntentionAssessDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.UserIntentionAssessDetail)
  size_t total_size = 0;

  if (_internal_has_late_operate_unit_cost()) {
    // required double late_operate_unit_cost = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_cancel_operation_unit_cost()) {
    // required double cancel_operation_unit_cost = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t UserIntentionAssessDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.UserIntentionAssessDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double late_operate_unit_cost = 1;
    total_size += 1 + 8;

    // required double cancel_operation_unit_cost = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserIntentionAssessDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.UserIntentionAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const UserIntentionAssessDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UserIntentionAssessDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.UserIntentionAssessDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.UserIntentionAssessDetail)
    MergeFrom(*source);
  }
}

void UserIntentionAssessDetail::MergeFrom(const UserIntentionAssessDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.UserIntentionAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      late_operate_unit_cost_ = from.late_operate_unit_cost_;
    }
    if (cached_has_bits & 0x00000002u) {
      cancel_operation_unit_cost_ = from.cancel_operation_unit_cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UserIntentionAssessDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.UserIntentionAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserIntentionAssessDetail::CopyFrom(const UserIntentionAssessDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.UserIntentionAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserIntentionAssessDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UserIntentionAssessDetail::InternalSwap(UserIntentionAssessDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserIntentionAssessDetail, cancel_operation_unit_cost_)
      + sizeof(UserIntentionAssessDetail::cancel_operation_unit_cost_)
      - PROTOBUF_FIELD_OFFSET(UserIntentionAssessDetail, late_operate_unit_cost_)>(
          reinterpret_cast<char*>(&late_operate_unit_cost_),
          reinterpret_cast<char*>(&other->late_operate_unit_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserIntentionAssessDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class NavigationAssessDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<NavigationAssessDetail>()._has_bits_);
  static void set_has_lane_change_left_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lane_change_right_unit_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lane_change_unit_cost_vel_lb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lane_change_left_recommendation_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lane_change_right_recommendation_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

NavigationAssessDetail::NavigationAssessDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.NavigationAssessDetail)
}
NavigationAssessDetail::NavigationAssessDetail(const NavigationAssessDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&lane_change_left_unit_cost_, &from.lane_change_left_unit_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_change_right_recommendation_reward_) -
    reinterpret_cast<char*>(&lane_change_left_unit_cost_)) + sizeof(lane_change_right_recommendation_reward_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.NavigationAssessDetail)
}

void NavigationAssessDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lane_change_left_unit_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lane_change_right_recommendation_reward_) -
    reinterpret_cast<char*>(&lane_change_left_unit_cost_)) + sizeof(lane_change_right_recommendation_reward_));
}

NavigationAssessDetail::~NavigationAssessDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.NavigationAssessDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void NavigationAssessDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void NavigationAssessDetail::ArenaDtor(void* object) {
  NavigationAssessDetail* _this = reinterpret_cast< NavigationAssessDetail* >(object);
  (void)_this;
}
void NavigationAssessDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NavigationAssessDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NavigationAssessDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.NavigationAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&lane_change_left_unit_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_change_right_recommendation_reward_) -
        reinterpret_cast<char*>(&lane_change_left_unit_cost_)) + sizeof(lane_change_right_recommendation_reward_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NavigationAssessDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double lane_change_left_unit_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_lane_change_left_unit_cost(&has_bits);
          lane_change_left_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lane_change_right_unit_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_lane_change_right_unit_cost(&has_bits);
          lane_change_right_unit_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lane_change_unit_cost_vel_lb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_lane_change_unit_cost_vel_lb(&has_bits);
          lane_change_unit_cost_vel_lb_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lane_change_left_recommendation_reward = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_lane_change_left_recommendation_reward(&has_bits);
          lane_change_left_recommendation_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lane_change_right_recommendation_reward = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_lane_change_right_recommendation_reward(&has_bits);
          lane_change_right_recommendation_reward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NavigationAssessDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.NavigationAssessDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double lane_change_left_unit_cost = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_lane_change_left_unit_cost(), target);
  }

  // required double lane_change_right_unit_cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_lane_change_right_unit_cost(), target);
  }

  // required double lane_change_unit_cost_vel_lb = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_lane_change_unit_cost_vel_lb(), target);
  }

  // required double lane_change_left_recommendation_reward = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_lane_change_left_recommendation_reward(), target);
  }

  // required double lane_change_right_recommendation_reward = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_lane_change_right_recommendation_reward(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.NavigationAssessDetail)
  return target;
}

size_t NavigationAssessDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.NavigationAssessDetail)
  size_t total_size = 0;

  if (_internal_has_lane_change_left_unit_cost()) {
    // required double lane_change_left_unit_cost = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_lane_change_right_unit_cost()) {
    // required double lane_change_right_unit_cost = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_lane_change_unit_cost_vel_lb()) {
    // required double lane_change_unit_cost_vel_lb = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_lane_change_left_recommendation_reward()) {
    // required double lane_change_left_recommendation_reward = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_lane_change_right_recommendation_reward()) {
    // required double lane_change_right_recommendation_reward = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t NavigationAssessDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.NavigationAssessDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required double lane_change_left_unit_cost = 1;
    total_size += 1 + 8;

    // required double lane_change_right_unit_cost = 2;
    total_size += 1 + 8;

    // required double lane_change_unit_cost_vel_lb = 3;
    total_size += 1 + 8;

    // required double lane_change_left_recommendation_reward = 4;
    total_size += 1 + 8;

    // required double lane_change_right_recommendation_reward = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NavigationAssessDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.NavigationAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const NavigationAssessDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NavigationAssessDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.NavigationAssessDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.NavigationAssessDetail)
    MergeFrom(*source);
  }
}

void NavigationAssessDetail::MergeFrom(const NavigationAssessDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.NavigationAssessDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      lane_change_left_unit_cost_ = from.lane_change_left_unit_cost_;
    }
    if (cached_has_bits & 0x00000002u) {
      lane_change_right_unit_cost_ = from.lane_change_right_unit_cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      lane_change_unit_cost_vel_lb_ = from.lane_change_unit_cost_vel_lb_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_change_left_recommendation_reward_ = from.lane_change_left_recommendation_reward_;
    }
    if (cached_has_bits & 0x00000010u) {
      lane_change_right_recommendation_reward_ = from.lane_change_right_recommendation_reward_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NavigationAssessDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.NavigationAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NavigationAssessDetail::CopyFrom(const NavigationAssessDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.NavigationAssessDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavigationAssessDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void NavigationAssessDetail::InternalSwap(NavigationAssessDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NavigationAssessDetail, lane_change_right_recommendation_reward_)
      + sizeof(NavigationAssessDetail::lane_change_right_recommendation_reward_)
      - PROTOBUF_FIELD_OFFSET(NavigationAssessDetail, lane_change_left_unit_cost_)>(
          reinterpret_cast<char*>(&lane_change_left_unit_cost_),
          reinterpret_cast<char*>(&other->lane_change_left_unit_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NavigationAssessDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CostAssessCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<CostAssessCfg>()._has_bits_);
  static const ::planning::eudm::EfficiencyAssessDetail& effciency(const CostAssessCfg* msg);
  static void set_has_effciency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::planning::eudm::SafetyAssessDetail& safety(const CostAssessCfg* msg);
  static void set_has_safety(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::planning::eudm::UserIntentionAssessDetail& user(const CostAssessCfg* msg);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::planning::eudm::NavigationAssessDetail& navigation(const CostAssessCfg* msg);
  static void set_has_navigation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_discount_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::planning::eudm::EfficiencyAssessDetail&
CostAssessCfg::_Internal::effciency(const CostAssessCfg* msg) {
  return *msg->effciency_;
}
const ::planning::eudm::SafetyAssessDetail&
CostAssessCfg::_Internal::safety(const CostAssessCfg* msg) {
  return *msg->safety_;
}
const ::planning::eudm::UserIntentionAssessDetail&
CostAssessCfg::_Internal::user(const CostAssessCfg* msg) {
  return *msg->user_;
}
const ::planning::eudm::NavigationAssessDetail&
CostAssessCfg::_Internal::navigation(const CostAssessCfg* msg) {
  return *msg->navigation_;
}
CostAssessCfg::CostAssessCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.CostAssessCfg)
}
CostAssessCfg::CostAssessCfg(const CostAssessCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_effciency()) {
    effciency_ = new ::planning::eudm::EfficiencyAssessDetail(*from.effciency_);
  } else {
    effciency_ = nullptr;
  }
  if (from._internal_has_safety()) {
    safety_ = new ::planning::eudm::SafetyAssessDetail(*from.safety_);
  } else {
    safety_ = nullptr;
  }
  if (from._internal_has_user()) {
    user_ = new ::planning::eudm::UserIntentionAssessDetail(*from.user_);
  } else {
    user_ = nullptr;
  }
  if (from._internal_has_navigation()) {
    navigation_ = new ::planning::eudm::NavigationAssessDetail(*from.navigation_);
  } else {
    navigation_ = nullptr;
  }
  discount_factor_ = from.discount_factor_;
  // @@protoc_insertion_point(copy_constructor:planning.eudm.CostAssessCfg)
}

void CostAssessCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&effciency_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&discount_factor_) -
    reinterpret_cast<char*>(&effciency_)) + sizeof(discount_factor_));
}

CostAssessCfg::~CostAssessCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.CostAssessCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CostAssessCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete effciency_;
  if (this != internal_default_instance()) delete safety_;
  if (this != internal_default_instance()) delete user_;
  if (this != internal_default_instance()) delete navigation_;
}

void CostAssessCfg::ArenaDtor(void* object) {
  CostAssessCfg* _this = reinterpret_cast< CostAssessCfg* >(object);
  (void)_this;
}
void CostAssessCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CostAssessCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CostAssessCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.CostAssessCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(effciency_ != nullptr);
      effciency_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(safety_ != nullptr);
      safety_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(user_ != nullptr);
      user_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(navigation_ != nullptr);
      navigation_->Clear();
    }
  }
  discount_factor_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CostAssessCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.EfficiencyAssessDetail effciency = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_effciency(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.SafetyAssessDetail safety = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_safety(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.UserIntentionAssessDetail user = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.NavigationAssessDetail navigation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_navigation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double discount_factor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_discount_factor(&has_bits);
          discount_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CostAssessCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.CostAssessCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.EfficiencyAssessDetail effciency = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::effciency(this), target, stream);
  }

  // required .planning.eudm.SafetyAssessDetail safety = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::safety(this), target, stream);
  }

  // required .planning.eudm.UserIntentionAssessDetail user = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::user(this), target, stream);
  }

  // required .planning.eudm.NavigationAssessDetail navigation = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::navigation(this), target, stream);
  }

  // required double discount_factor = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_discount_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.CostAssessCfg)
  return target;
}

size_t CostAssessCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.CostAssessCfg)
  size_t total_size = 0;

  if (_internal_has_effciency()) {
    // required .planning.eudm.EfficiencyAssessDetail effciency = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *effciency_);
  }

  if (_internal_has_safety()) {
    // required .planning.eudm.SafetyAssessDetail safety = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *safety_);
  }

  if (_internal_has_user()) {
    // required .planning.eudm.UserIntentionAssessDetail user = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  if (_internal_has_navigation()) {
    // required .planning.eudm.NavigationAssessDetail navigation = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *navigation_);
  }

  if (_internal_has_discount_factor()) {
    // required double discount_factor = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t CostAssessCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.CostAssessCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .planning.eudm.EfficiencyAssessDetail effciency = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *effciency_);

    // required .planning.eudm.SafetyAssessDetail safety = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *safety_);

    // required .planning.eudm.UserIntentionAssessDetail user = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);

    // required .planning.eudm.NavigationAssessDetail navigation = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *navigation_);

    // required double discount_factor = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CostAssessCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.CostAssessCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const CostAssessCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CostAssessCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.CostAssessCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.CostAssessCfg)
    MergeFrom(*source);
  }
}

void CostAssessCfg::MergeFrom(const CostAssessCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.CostAssessCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_effciency()->::planning::eudm::EfficiencyAssessDetail::MergeFrom(from._internal_effciency());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_safety()->::planning::eudm::SafetyAssessDetail::MergeFrom(from._internal_safety());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_user()->::planning::eudm::UserIntentionAssessDetail::MergeFrom(from._internal_user());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_navigation()->::planning::eudm::NavigationAssessDetail::MergeFrom(from._internal_navigation());
    }
    if (cached_has_bits & 0x00000010u) {
      discount_factor_ = from.discount_factor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CostAssessCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.CostAssessCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CostAssessCfg::CopyFrom(const CostAssessCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.CostAssessCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CostAssessCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_effciency()) {
    if (!effciency_->IsInitialized()) return false;
  }
  if (_internal_has_safety()) {
    if (!safety_->IsInitialized()) return false;
  }
  if (_internal_has_user()) {
    if (!user_->IsInitialized()) return false;
  }
  if (_internal_has_navigation()) {
    if (!navigation_->IsInitialized()) return false;
  }
  return true;
}

void CostAssessCfg::InternalSwap(CostAssessCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CostAssessCfg, discount_factor_)
      + sizeof(CostAssessCfg::discount_factor_)
      - PROTOBUF_FIELD_OFFSET(CostAssessCfg, effciency_)>(
          reinterpret_cast<char*>(&effciency_),
          reinterpret_cast<char*>(&other->effciency_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CostAssessCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class SimDurationDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<SimDurationDetail>()._has_bits_);
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_step(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tree_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

SimDurationDetail::SimDurationDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.SimDurationDetail)
}
SimDurationDetail::SimDurationDetail(const SimDurationDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&layer_, &from.layer_,
    static_cast<size_t>(reinterpret_cast<char*>(&tree_height_) -
    reinterpret_cast<char*>(&layer_)) + sizeof(tree_height_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.SimDurationDetail)
}

void SimDurationDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&layer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tree_height_) -
    reinterpret_cast<char*>(&layer_)) + sizeof(tree_height_));
}

SimDurationDetail::~SimDurationDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.SimDurationDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SimDurationDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SimDurationDetail::ArenaDtor(void* object) {
  SimDurationDetail* _this = reinterpret_cast< SimDurationDetail* >(object);
  (void)_this;
}
void SimDurationDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimDurationDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimDurationDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.SimDurationDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&layer_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tree_height_) -
        reinterpret_cast<char*>(&layer_)) + sizeof(tree_height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimDurationDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_layer(&has_bits);
          layer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double last_layer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_last_layer(&has_bits);
          last_layer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_step(&has_bits);
          step_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required int32 tree_height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_tree_height(&has_bits);
          tree_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimDurationDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.SimDurationDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double layer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_layer(), target);
  }

  // required double last_layer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_last_layer(), target);
  }

  // required double step = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_step(), target);
  }

  // required int32 tree_height = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_tree_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.SimDurationDetail)
  return target;
}

size_t SimDurationDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.SimDurationDetail)
  size_t total_size = 0;

  if (_internal_has_layer()) {
    // required double layer = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_last_layer()) {
    // required double last_layer = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_step()) {
    // required double step = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_tree_height()) {
    // required int32 tree_height = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_tree_height());
  }

  return total_size;
}
size_t SimDurationDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.SimDurationDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double layer = 1;
    total_size += 1 + 8;

    // required double last_layer = 2;
    total_size += 1 + 8;

    // required double step = 3;
    total_size += 1 + 8;

    // required int32 tree_height = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_tree_height());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimDurationDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.SimDurationDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const SimDurationDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SimDurationDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.SimDurationDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.SimDurationDetail)
    MergeFrom(*source);
  }
}

void SimDurationDetail::MergeFrom(const SimDurationDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.SimDurationDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      layer_ = from.layer_;
    }
    if (cached_has_bits & 0x00000002u) {
      last_layer_ = from.last_layer_;
    }
    if (cached_has_bits & 0x00000004u) {
      step_ = from.step_;
    }
    if (cached_has_bits & 0x00000008u) {
      tree_height_ = from.tree_height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimDurationDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.SimDurationDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimDurationDetail::CopyFrom(const SimDurationDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.SimDurationDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimDurationDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SimDurationDetail::InternalSwap(SimDurationDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimDurationDetail, tree_height_)
      + sizeof(SimDurationDetail::tree_height_)
      - PROTOBUF_FIELD_OFFSET(SimDurationDetail, layer_)>(
          reinterpret_cast<char*>(&layer_),
          reinterpret_cast<char*>(&other->layer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimDurationDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LonSimLimit::_Internal {
 public:
  using HasBits = decltype(std::declval<LonSimLimit>()._has_bits_);
  static void set_has_acc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_acc_jerk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_soft_brake(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hard_brake(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brake_jerk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

LonSimLimit::LonSimLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LonSimLimit)
}
LonSimLimit::LonSimLimit(const LonSimLimit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&acc_, &from.acc_,
    static_cast<size_t>(reinterpret_cast<char*>(&brake_jerk_) -
    reinterpret_cast<char*>(&acc_)) + sizeof(brake_jerk_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LonSimLimit)
}

void LonSimLimit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&brake_jerk_) -
    reinterpret_cast<char*>(&acc_)) + sizeof(brake_jerk_));
}

LonSimLimit::~LonSimLimit() {
  // @@protoc_insertion_point(destructor:planning.eudm.LonSimLimit)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LonSimLimit::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LonSimLimit::ArenaDtor(void* object) {
  LonSimLimit* _this = reinterpret_cast< LonSimLimit* >(object);
  (void)_this;
}
void LonSimLimit::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LonSimLimit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LonSimLimit::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LonSimLimit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&acc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&brake_jerk_) -
        reinterpret_cast<char*>(&acc_)) + sizeof(brake_jerk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LonSimLimit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double acc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_acc(&has_bits);
          acc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double acc_jerk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_acc_jerk(&has_bits);
          acc_jerk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double soft_brake = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_soft_brake(&has_bits);
          soft_brake_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double hard_brake = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_hard_brake(&has_bits);
          hard_brake_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double brake_jerk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_brake_jerk(&has_bits);
          brake_jerk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LonSimLimit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LonSimLimit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double acc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_acc(), target);
  }

  // required double acc_jerk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_acc_jerk(), target);
  }

  // required double soft_brake = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_soft_brake(), target);
  }

  // required double hard_brake = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_hard_brake(), target);
  }

  // required double brake_jerk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_brake_jerk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LonSimLimit)
  return target;
}

size_t LonSimLimit::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LonSimLimit)
  size_t total_size = 0;

  if (_internal_has_acc()) {
    // required double acc = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_acc_jerk()) {
    // required double acc_jerk = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_soft_brake()) {
    // required double soft_brake = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_hard_brake()) {
    // required double hard_brake = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_brake_jerk()) {
    // required double brake_jerk = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t LonSimLimit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LonSimLimit)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required double acc = 1;
    total_size += 1 + 8;

    // required double acc_jerk = 2;
    total_size += 1 + 8;

    // required double soft_brake = 3;
    total_size += 1 + 8;

    // required double hard_brake = 4;
    total_size += 1 + 8;

    // required double brake_jerk = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LonSimLimit::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LonSimLimit)
  GOOGLE_DCHECK_NE(&from, this);
  const LonSimLimit* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LonSimLimit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LonSimLimit)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LonSimLimit)
    MergeFrom(*source);
  }
}

void LonSimLimit::MergeFrom(const LonSimLimit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LonSimLimit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      acc_ = from.acc_;
    }
    if (cached_has_bits & 0x00000002u) {
      acc_jerk_ = from.acc_jerk_;
    }
    if (cached_has_bits & 0x00000004u) {
      soft_brake_ = from.soft_brake_;
    }
    if (cached_has_bits & 0x00000008u) {
      hard_brake_ = from.hard_brake_;
    }
    if (cached_has_bits & 0x00000010u) {
      brake_jerk_ = from.brake_jerk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LonSimLimit::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LonSimLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LonSimLimit::CopyFrom(const LonSimLimit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LonSimLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LonSimLimit::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LonSimLimit::InternalSwap(LonSimLimit* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LonSimLimit, brake_jerk_)
      + sizeof(LonSimLimit::brake_jerk_)
      - PROTOBUF_FIELD_OFFSET(LonSimLimit, acc_)>(
          reinterpret_cast<char*>(&acc_),
          reinterpret_cast<char*>(&other->acc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LonSimLimit::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LonSimIdm::_Internal {
 public:
  using HasBits = decltype(std::declval<LonSimIdm>()._has_bits_);
  static void set_has_min_spacing(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_head_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_exponent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LonSimIdm::LonSimIdm(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LonSimIdm)
}
LonSimIdm::LonSimIdm(const LonSimIdm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&min_spacing_, &from.min_spacing_,
    static_cast<size_t>(reinterpret_cast<char*>(&exponent_) -
    reinterpret_cast<char*>(&min_spacing_)) + sizeof(exponent_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LonSimIdm)
}

void LonSimIdm::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_spacing_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&exponent_) -
    reinterpret_cast<char*>(&min_spacing_)) + sizeof(exponent_));
}

LonSimIdm::~LonSimIdm() {
  // @@protoc_insertion_point(destructor:planning.eudm.LonSimIdm)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LonSimIdm::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LonSimIdm::ArenaDtor(void* object) {
  LonSimIdm* _this = reinterpret_cast< LonSimIdm* >(object);
  (void)_this;
}
void LonSimIdm::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LonSimIdm::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LonSimIdm::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LonSimIdm)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&min_spacing_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&exponent_) -
        reinterpret_cast<char*>(&min_spacing_)) + sizeof(exponent_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LonSimIdm::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double min_spacing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_min_spacing(&has_bits);
          min_spacing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double head_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_head_time(&has_bits);
          head_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required int32 exponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_exponent(&has_bits);
          exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LonSimIdm::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LonSimIdm)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double min_spacing = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_min_spacing(), target);
  }

  // required double head_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_head_time(), target);
  }

  // required int32 exponent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_exponent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LonSimIdm)
  return target;
}

size_t LonSimIdm::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LonSimIdm)
  size_t total_size = 0;

  if (_internal_has_min_spacing()) {
    // required double min_spacing = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_head_time()) {
    // required double head_time = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_exponent()) {
    // required int32 exponent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_exponent());
  }

  return total_size;
}
size_t LonSimIdm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LonSimIdm)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double min_spacing = 1;
    total_size += 1 + 8;

    // required double head_time = 2;
    total_size += 1 + 8;

    // required int32 exponent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_exponent());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LonSimIdm::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LonSimIdm)
  GOOGLE_DCHECK_NE(&from, this);
  const LonSimIdm* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LonSimIdm>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LonSimIdm)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LonSimIdm)
    MergeFrom(*source);
  }
}

void LonSimIdm::MergeFrom(const LonSimIdm& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LonSimIdm)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      min_spacing_ = from.min_spacing_;
    }
    if (cached_has_bits & 0x00000002u) {
      head_time_ = from.head_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      exponent_ = from.exponent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LonSimIdm::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LonSimIdm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LonSimIdm::CopyFrom(const LonSimIdm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LonSimIdm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LonSimIdm::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LonSimIdm::InternalSwap(LonSimIdm* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LonSimIdm, exponent_)
      + sizeof(LonSimIdm::exponent_)
      - PROTOBUF_FIELD_OFFSET(LonSimIdm, min_spacing_)>(
          reinterpret_cast<char*>(&min_spacing_),
          reinterpret_cast<char*>(&other->min_spacing_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LonSimIdm::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LonSimDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<LonSimDetail>()._has_bits_);
  static const ::planning::eudm::LonSimIdm& idm(const LonSimDetail* msg);
  static void set_has_idm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::planning::eudm::LonSimLimit& limit(const LonSimDetail* msg);
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::planning::eudm::LonSimIdm&
LonSimDetail::_Internal::idm(const LonSimDetail* msg) {
  return *msg->idm_;
}
const ::planning::eudm::LonSimLimit&
LonSimDetail::_Internal::limit(const LonSimDetail* msg) {
  return *msg->limit_;
}
LonSimDetail::LonSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LonSimDetail)
}
LonSimDetail::LonSimDetail(const LonSimDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_idm()) {
    idm_ = new ::planning::eudm::LonSimIdm(*from.idm_);
  } else {
    idm_ = nullptr;
  }
  if (from._internal_has_limit()) {
    limit_ = new ::planning::eudm::LonSimLimit(*from.limit_);
  } else {
    limit_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LonSimDetail)
}

void LonSimDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&idm_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&idm_)) + sizeof(limit_));
}

LonSimDetail::~LonSimDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.LonSimDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LonSimDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete idm_;
  if (this != internal_default_instance()) delete limit_;
}

void LonSimDetail::ArenaDtor(void* object) {
  LonSimDetail* _this = reinterpret_cast< LonSimDetail* >(object);
  (void)_this;
}
void LonSimDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LonSimDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LonSimDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LonSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(idm_ != nullptr);
      idm_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(limit_ != nullptr);
      limit_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LonSimDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.LonSimIdm idm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_idm(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.LonSimLimit limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LonSimDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LonSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.LonSimIdm idm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::idm(this), target, stream);
  }

  // required .planning.eudm.LonSimLimit limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::limit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LonSimDetail)
  return target;
}

size_t LonSimDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LonSimDetail)
  size_t total_size = 0;

  if (_internal_has_idm()) {
    // required .planning.eudm.LonSimIdm idm = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *idm_);
  }

  if (_internal_has_limit()) {
    // required .planning.eudm.LonSimLimit limit = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *limit_);
  }

  return total_size;
}
size_t LonSimDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LonSimDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .planning.eudm.LonSimIdm idm = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *idm_);

    // required .planning.eudm.LonSimLimit limit = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *limit_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LonSimDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LonSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const LonSimDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LonSimDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LonSimDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LonSimDetail)
    MergeFrom(*source);
  }
}

void LonSimDetail::MergeFrom(const LonSimDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LonSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_idm()->::planning::eudm::LonSimIdm::MergeFrom(from._internal_idm());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_limit()->::planning::eudm::LonSimLimit::MergeFrom(from._internal_limit());
    }
  }
}

void LonSimDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LonSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LonSimDetail::CopyFrom(const LonSimDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LonSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LonSimDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_idm()) {
    if (!idm_->IsInitialized()) return false;
  }
  if (_internal_has_limit()) {
    if (!limit_->IsInitialized()) return false;
  }
  return true;
}

void LonSimDetail::InternalSwap(LonSimDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LonSimDetail, limit_)
      + sizeof(LonSimDetail::limit_)
      - PROTOBUF_FIELD_OFFSET(LonSimDetail, idm_)>(
          reinterpret_cast<char*>(&idm_),
          reinterpret_cast<char*>(&other->idm_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LonSimDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LatSimLimit::_Internal {
 public:
  using HasBits = decltype(std::declval<LatSimLimit>()._has_bits_);
  static void set_has_acc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_jerk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_curvature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steer_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_steer_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

LatSimLimit::LatSimLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LatSimLimit)
}
LatSimLimit::LatSimLimit(const LatSimLimit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&acc_, &from.acc_,
    static_cast<size_t>(reinterpret_cast<char*>(&steer_rate_) -
    reinterpret_cast<char*>(&acc_)) + sizeof(steer_rate_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LatSimLimit)
}

void LatSimLimit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steer_rate_) -
    reinterpret_cast<char*>(&acc_)) + sizeof(steer_rate_));
}

LatSimLimit::~LatSimLimit() {
  // @@protoc_insertion_point(destructor:planning.eudm.LatSimLimit)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LatSimLimit::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LatSimLimit::ArenaDtor(void* object) {
  LatSimLimit* _this = reinterpret_cast< LatSimLimit* >(object);
  (void)_this;
}
void LatSimLimit::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LatSimLimit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LatSimLimit::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LatSimLimit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&acc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steer_rate_) -
        reinterpret_cast<char*>(&acc_)) + sizeof(steer_rate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LatSimLimit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double acc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_acc(&has_bits);
          acc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double jerk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_jerk(&has_bits);
          jerk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double curvature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_curvature(&has_bits);
          curvature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double steer_angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_steer_angle(&has_bits);
          steer_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double steer_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_steer_rate(&has_bits);
          steer_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LatSimLimit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LatSimLimit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double acc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_acc(), target);
  }

  // required double jerk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_jerk(), target);
  }

  // required double curvature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_curvature(), target);
  }

  // required double steer_angle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_steer_angle(), target);
  }

  // required double steer_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_steer_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LatSimLimit)
  return target;
}

size_t LatSimLimit::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LatSimLimit)
  size_t total_size = 0;

  if (_internal_has_acc()) {
    // required double acc = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_jerk()) {
    // required double jerk = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_curvature()) {
    // required double curvature = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_steer_angle()) {
    // required double steer_angle = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_steer_rate()) {
    // required double steer_rate = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t LatSimLimit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LatSimLimit)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required double acc = 1;
    total_size += 1 + 8;

    // required double jerk = 2;
    total_size += 1 + 8;

    // required double curvature = 3;
    total_size += 1 + 8;

    // required double steer_angle = 4;
    total_size += 1 + 8;

    // required double steer_rate = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LatSimLimit::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LatSimLimit)
  GOOGLE_DCHECK_NE(&from, this);
  const LatSimLimit* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LatSimLimit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LatSimLimit)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LatSimLimit)
    MergeFrom(*source);
  }
}

void LatSimLimit::MergeFrom(const LatSimLimit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LatSimLimit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      acc_ = from.acc_;
    }
    if (cached_has_bits & 0x00000002u) {
      jerk_ = from.jerk_;
    }
    if (cached_has_bits & 0x00000004u) {
      curvature_ = from.curvature_;
    }
    if (cached_has_bits & 0x00000008u) {
      steer_angle_ = from.steer_angle_;
    }
    if (cached_has_bits & 0x00000010u) {
      steer_rate_ = from.steer_rate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LatSimLimit::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LatSimLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LatSimLimit::CopyFrom(const LatSimLimit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LatSimLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LatSimLimit::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LatSimLimit::InternalSwap(LatSimLimit* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LatSimLimit, steer_rate_)
      + sizeof(LatSimLimit::steer_rate_)
      - PROTOBUF_FIELD_OFFSET(LatSimLimit, acc_)>(
          reinterpret_cast<char*>(&acc_),
          reinterpret_cast<char*>(&other->acc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LatSimLimit::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LatSimPurePursuit::_Internal {
 public:
  using HasBits = decltype(std::declval<LatSimPurePursuit>()._has_bits_);
  static void set_has_gain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_lookahead_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_lookahead_dist(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LatSimPurePursuit::LatSimPurePursuit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LatSimPurePursuit)
}
LatSimPurePursuit::LatSimPurePursuit(const LatSimPurePursuit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&gain_, &from.gain_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_lookahead_dist_) -
    reinterpret_cast<char*>(&gain_)) + sizeof(min_lookahead_dist_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LatSimPurePursuit)
}

void LatSimPurePursuit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gain_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&min_lookahead_dist_) -
    reinterpret_cast<char*>(&gain_)) + sizeof(min_lookahead_dist_));
}

LatSimPurePursuit::~LatSimPurePursuit() {
  // @@protoc_insertion_point(destructor:planning.eudm.LatSimPurePursuit)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LatSimPurePursuit::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LatSimPurePursuit::ArenaDtor(void* object) {
  LatSimPurePursuit* _this = reinterpret_cast< LatSimPurePursuit* >(object);
  (void)_this;
}
void LatSimPurePursuit::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LatSimPurePursuit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LatSimPurePursuit::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LatSimPurePursuit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gain_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_lookahead_dist_) -
        reinterpret_cast<char*>(&gain_)) + sizeof(min_lookahead_dist_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LatSimPurePursuit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double gain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_gain(&has_bits);
          gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double max_lookahead_dist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_max_lookahead_dist(&has_bits);
          max_lookahead_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double min_lookahead_dist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_min_lookahead_dist(&has_bits);
          min_lookahead_dist_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LatSimPurePursuit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LatSimPurePursuit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double gain = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_gain(), target);
  }

  // required double max_lookahead_dist = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_max_lookahead_dist(), target);
  }

  // required double min_lookahead_dist = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_min_lookahead_dist(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LatSimPurePursuit)
  return target;
}

size_t LatSimPurePursuit::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LatSimPurePursuit)
  size_t total_size = 0;

  if (_internal_has_gain()) {
    // required double gain = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_max_lookahead_dist()) {
    // required double max_lookahead_dist = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_min_lookahead_dist()) {
    // required double min_lookahead_dist = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t LatSimPurePursuit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LatSimPurePursuit)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double gain = 1;
    total_size += 1 + 8;

    // required double max_lookahead_dist = 2;
    total_size += 1 + 8;

    // required double min_lookahead_dist = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LatSimPurePursuit::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LatSimPurePursuit)
  GOOGLE_DCHECK_NE(&from, this);
  const LatSimPurePursuit* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LatSimPurePursuit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LatSimPurePursuit)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LatSimPurePursuit)
    MergeFrom(*source);
  }
}

void LatSimPurePursuit::MergeFrom(const LatSimPurePursuit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LatSimPurePursuit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gain_ = from.gain_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_lookahead_dist_ = from.max_lookahead_dist_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_lookahead_dist_ = from.min_lookahead_dist_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LatSimPurePursuit::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LatSimPurePursuit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LatSimPurePursuit::CopyFrom(const LatSimPurePursuit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LatSimPurePursuit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LatSimPurePursuit::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LatSimPurePursuit::InternalSwap(LatSimPurePursuit* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LatSimPurePursuit, min_lookahead_dist_)
      + sizeof(LatSimPurePursuit::min_lookahead_dist_)
      - PROTOBUF_FIELD_OFFSET(LatSimPurePursuit, gain_)>(
          reinterpret_cast<char*>(&gain_),
          reinterpret_cast<char*>(&other->gain_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LatSimPurePursuit::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class LatSimDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<LatSimDetail>()._has_bits_);
  static const ::planning::eudm::LatSimPurePursuit& pure_pursuit(const LatSimDetail* msg);
  static void set_has_pure_pursuit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::planning::eudm::LatSimLimit& limit(const LatSimDetail* msg);
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::planning::eudm::LatSimPurePursuit&
LatSimDetail::_Internal::pure_pursuit(const LatSimDetail* msg) {
  return *msg->pure_pursuit_;
}
const ::planning::eudm::LatSimLimit&
LatSimDetail::_Internal::limit(const LatSimDetail* msg) {
  return *msg->limit_;
}
LatSimDetail::LatSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.LatSimDetail)
}
LatSimDetail::LatSimDetail(const LatSimDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pure_pursuit()) {
    pure_pursuit_ = new ::planning::eudm::LatSimPurePursuit(*from.pure_pursuit_);
  } else {
    pure_pursuit_ = nullptr;
  }
  if (from._internal_has_limit()) {
    limit_ = new ::planning::eudm::LatSimLimit(*from.limit_);
  } else {
    limit_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:planning.eudm.LatSimDetail)
}

void LatSimDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pure_pursuit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&pure_pursuit_)) + sizeof(limit_));
}

LatSimDetail::~LatSimDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.LatSimDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LatSimDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pure_pursuit_;
  if (this != internal_default_instance()) delete limit_;
}

void LatSimDetail::ArenaDtor(void* object) {
  LatSimDetail* _this = reinterpret_cast< LatSimDetail* >(object);
  (void)_this;
}
void LatSimDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LatSimDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LatSimDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.LatSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pure_pursuit_ != nullptr);
      pure_pursuit_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(limit_ != nullptr);
      limit_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LatSimDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pure_pursuit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.LatSimLimit limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LatSimDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.LatSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pure_pursuit(this), target, stream);
  }

  // required .planning.eudm.LatSimLimit limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::limit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.LatSimDetail)
  return target;
}

size_t LatSimDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.LatSimDetail)
  size_t total_size = 0;

  if (_internal_has_pure_pursuit()) {
    // required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pure_pursuit_);
  }

  if (_internal_has_limit()) {
    // required .planning.eudm.LatSimLimit limit = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *limit_);
  }

  return total_size;
}
size_t LatSimDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.LatSimDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .planning.eudm.LatSimPurePursuit pure_pursuit = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pure_pursuit_);

    // required .planning.eudm.LatSimLimit limit = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *limit_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LatSimDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.LatSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const LatSimDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LatSimDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.LatSimDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.LatSimDetail)
    MergeFrom(*source);
  }
}

void LatSimDetail::MergeFrom(const LatSimDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.LatSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pure_pursuit()->::planning::eudm::LatSimPurePursuit::MergeFrom(from._internal_pure_pursuit());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_limit()->::planning::eudm::LatSimLimit::MergeFrom(from._internal_limit());
    }
  }
}

void LatSimDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.LatSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LatSimDetail::CopyFrom(const LatSimDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.LatSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LatSimDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_pure_pursuit()) {
    if (!pure_pursuit_->IsInitialized()) return false;
  }
  if (_internal_has_limit()) {
    if (!limit_->IsInitialized()) return false;
  }
  return true;
}

void LatSimDetail::InternalSwap(LatSimDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LatSimDetail, limit_)
      + sizeof(LatSimDetail::limit_)
      - PROTOBUF_FIELD_OFFSET(LatSimDetail, pure_pursuit_)>(
          reinterpret_cast<char*>(&pure_pursuit_),
          reinterpret_cast<char*>(&other->pure_pursuit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LatSimDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class EvasiveSimDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<EvasiveSimDetail>()._has_bits_);
  static void set_has_evasive_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lon_acc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lon_jerk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lon_extraspeed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_head_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_virtual_barrier_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_virtual_barrier_tic(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

EvasiveSimDetail::EvasiveSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.EvasiveSimDetail)
}
EvasiveSimDetail::EvasiveSimDetail(const EvasiveSimDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&lon_acc_, &from.lon_acc_,
    static_cast<size_t>(reinterpret_cast<char*>(&virtual_barrier_enable_) -
    reinterpret_cast<char*>(&lon_acc_)) + sizeof(virtual_barrier_enable_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.EvasiveSimDetail)
}

void EvasiveSimDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lon_acc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&virtual_barrier_enable_) -
    reinterpret_cast<char*>(&lon_acc_)) + sizeof(virtual_barrier_enable_));
}

EvasiveSimDetail::~EvasiveSimDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.EvasiveSimDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EvasiveSimDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EvasiveSimDetail::ArenaDtor(void* object) {
  EvasiveSimDetail* _this = reinterpret_cast< EvasiveSimDetail* >(object);
  (void)_this;
}
void EvasiveSimDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EvasiveSimDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EvasiveSimDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.EvasiveSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&lon_acc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&virtual_barrier_enable_) -
        reinterpret_cast<char*>(&lon_acc_)) + sizeof(virtual_barrier_enable_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EvasiveSimDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool evasive_enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_evasive_enable(&has_bits);
          evasive_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double lon_acc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_lon_acc(&has_bits);
          lon_acc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lon_jerk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_lon_jerk(&has_bits);
          lon_jerk_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lon_extraspeed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_lon_extraspeed(&has_bits);
          lon_extraspeed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double head_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_head_time(&has_bits);
          head_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required bool virtual_barrier_enable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_virtual_barrier_enable(&has_bits);
          virtual_barrier_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double virtual_barrier_tic = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_virtual_barrier_tic(&has_bits);
          virtual_barrier_tic_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EvasiveSimDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.EvasiveSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool evasive_enable = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_evasive_enable(), target);
  }

  // required double lon_acc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_lon_acc(), target);
  }

  // required double lon_jerk = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_lon_jerk(), target);
  }

  // required double lon_extraspeed = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_lon_extraspeed(), target);
  }

  // required double head_time = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_head_time(), target);
  }

  // required bool virtual_barrier_enable = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_virtual_barrier_enable(), target);
  }

  // required double virtual_barrier_tic = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_virtual_barrier_tic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.EvasiveSimDetail)
  return target;
}

size_t EvasiveSimDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.EvasiveSimDetail)
  size_t total_size = 0;

  if (_internal_has_lon_acc()) {
    // required double lon_acc = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_lon_jerk()) {
    // required double lon_jerk = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_lon_extraspeed()) {
    // required double lon_extraspeed = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_head_time()) {
    // required double head_time = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_virtual_barrier_tic()) {
    // required double virtual_barrier_tic = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_evasive_enable()) {
    // required bool evasive_enable = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_virtual_barrier_enable()) {
    // required bool virtual_barrier_enable = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t EvasiveSimDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.EvasiveSimDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required double lon_acc = 2;
    total_size += 1 + 8;

    // required double lon_jerk = 3;
    total_size += 1 + 8;

    // required double lon_extraspeed = 4;
    total_size += 1 + 8;

    // required double head_time = 5;
    total_size += 1 + 8;

    // required double virtual_barrier_tic = 7;
    total_size += 1 + 8;

    // required bool evasive_enable = 1;
    total_size += 1 + 1;

    // required bool virtual_barrier_enable = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EvasiveSimDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.EvasiveSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const EvasiveSimDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EvasiveSimDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.EvasiveSimDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.EvasiveSimDetail)
    MergeFrom(*source);
  }
}

void EvasiveSimDetail::MergeFrom(const EvasiveSimDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.EvasiveSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      lon_acc_ = from.lon_acc_;
    }
    if (cached_has_bits & 0x00000002u) {
      lon_jerk_ = from.lon_jerk_;
    }
    if (cached_has_bits & 0x00000004u) {
      lon_extraspeed_ = from.lon_extraspeed_;
    }
    if (cached_has_bits & 0x00000008u) {
      head_time_ = from.head_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      virtual_barrier_tic_ = from.virtual_barrier_tic_;
    }
    if (cached_has_bits & 0x00000020u) {
      evasive_enable_ = from.evasive_enable_;
    }
    if (cached_has_bits & 0x00000040u) {
      virtual_barrier_enable_ = from.virtual_barrier_enable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EvasiveSimDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.EvasiveSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EvasiveSimDetail::CopyFrom(const EvasiveSimDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.EvasiveSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvasiveSimDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EvasiveSimDetail::InternalSwap(EvasiveSimDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EvasiveSimDetail, virtual_barrier_enable_)
      + sizeof(EvasiveSimDetail::virtual_barrier_enable_)
      - PROTOBUF_FIELD_OFFSET(EvasiveSimDetail, lon_acc_)>(
          reinterpret_cast<char*>(&lon_acc_),
          reinterpret_cast<char*>(&other->lon_acc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EvasiveSimDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class ForwardSimDetail::_Internal {
 public:
  using HasBits = decltype(std::declval<ForwardSimDetail>()._has_bits_);
  static const ::planning::eudm::LonSimDetail& lon(const ForwardSimDetail* msg);
  static void set_has_lon(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::planning::eudm::LatSimDetail& lat(const ForwardSimDetail* msg);
  static void set_has_lat(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::planning::eudm::EvasiveSimDetail& evasive(const ForwardSimDetail* msg);
  static void set_has_evasive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auto_dec_if_lat_failed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cooperative_lat_range(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lon_aggressive_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

const ::planning::eudm::LonSimDetail&
ForwardSimDetail::_Internal::lon(const ForwardSimDetail* msg) {
  return *msg->lon_;
}
const ::planning::eudm::LatSimDetail&
ForwardSimDetail::_Internal::lat(const ForwardSimDetail* msg) {
  return *msg->lat_;
}
const ::planning::eudm::EvasiveSimDetail&
ForwardSimDetail::_Internal::evasive(const ForwardSimDetail* msg) {
  return *msg->evasive_;
}
ForwardSimDetail::ForwardSimDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.ForwardSimDetail)
}
ForwardSimDetail::ForwardSimDetail(const ForwardSimDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lon()) {
    lon_ = new ::planning::eudm::LonSimDetail(*from.lon_);
  } else {
    lon_ = nullptr;
  }
  if (from._internal_has_lat()) {
    lat_ = new ::planning::eudm::LatSimDetail(*from.lat_);
  } else {
    lat_ = nullptr;
  }
  if (from._internal_has_evasive()) {
    evasive_ = new ::planning::eudm::EvasiveSimDetail(*from.evasive_);
  } else {
    evasive_ = nullptr;
  }
  ::memcpy(&cooperative_lat_range_, &from.cooperative_lat_range_,
    static_cast<size_t>(reinterpret_cast<char*>(&auto_dec_if_lat_failed_) -
    reinterpret_cast<char*>(&cooperative_lat_range_)) + sizeof(auto_dec_if_lat_failed_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.ForwardSimDetail)
}

void ForwardSimDetail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lon_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&auto_dec_if_lat_failed_) -
    reinterpret_cast<char*>(&lon_)) + sizeof(auto_dec_if_lat_failed_));
}

ForwardSimDetail::~ForwardSimDetail() {
  // @@protoc_insertion_point(destructor:planning.eudm.ForwardSimDetail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ForwardSimDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete lon_;
  if (this != internal_default_instance()) delete lat_;
  if (this != internal_default_instance()) delete evasive_;
}

void ForwardSimDetail::ArenaDtor(void* object) {
  ForwardSimDetail* _this = reinterpret_cast< ForwardSimDetail* >(object);
  (void)_this;
}
void ForwardSimDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ForwardSimDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ForwardSimDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.ForwardSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(lon_ != nullptr);
      lon_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lat_ != nullptr);
      lat_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(evasive_ != nullptr);
      evasive_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&cooperative_lat_range_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&auto_dec_if_lat_failed_) -
        reinterpret_cast<char*>(&cooperative_lat_range_)) + sizeof(auto_dec_if_lat_failed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForwardSimDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.LonSimDetail lon = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_lon(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.LatSimDetail lat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.EvasiveSimDetail evasive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_evasive(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool auto_dec_if_lat_failed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_auto_dec_if_lat_failed(&has_bits);
          auto_dec_if_lat_failed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double cooperative_lat_range = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_cooperative_lat_range(&has_bits);
          cooperative_lat_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lon_aggressive_ratio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_lon_aggressive_ratio(&has_bits);
          lon_aggressive_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ForwardSimDetail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.ForwardSimDetail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.LonSimDetail lon = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::lon(this), target, stream);
  }

  // required .planning.eudm.LatSimDetail lat = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lat(this), target, stream);
  }

  // required .planning.eudm.EvasiveSimDetail evasive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::evasive(this), target, stream);
  }

  // required bool auto_dec_if_lat_failed = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_auto_dec_if_lat_failed(), target);
  }

  // required double cooperative_lat_range = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_cooperative_lat_range(), target);
  }

  // required double lon_aggressive_ratio = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_lon_aggressive_ratio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.ForwardSimDetail)
  return target;
}

size_t ForwardSimDetail::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.ForwardSimDetail)
  size_t total_size = 0;

  if (_internal_has_lon()) {
    // required .planning.eudm.LonSimDetail lon = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lon_);
  }

  if (_internal_has_lat()) {
    // required .planning.eudm.LatSimDetail lat = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lat_);
  }

  if (_internal_has_evasive()) {
    // required .planning.eudm.EvasiveSimDetail evasive = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *evasive_);
  }

  if (_internal_has_cooperative_lat_range()) {
    // required double cooperative_lat_range = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_lon_aggressive_ratio()) {
    // required double lon_aggressive_ratio = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_auto_dec_if_lat_failed()) {
    // required bool auto_dec_if_lat_failed = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ForwardSimDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.ForwardSimDetail)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required .planning.eudm.LonSimDetail lon = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lon_);

    // required .planning.eudm.LatSimDetail lat = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lat_);

    // required .planning.eudm.EvasiveSimDetail evasive = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *evasive_);

    // required double cooperative_lat_range = 5;
    total_size += 1 + 8;

    // required double lon_aggressive_ratio = 6;
    total_size += 1 + 8;

    // required bool auto_dec_if_lat_failed = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ForwardSimDetail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.ForwardSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  const ForwardSimDetail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ForwardSimDetail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.ForwardSimDetail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.ForwardSimDetail)
    MergeFrom(*source);
  }
}

void ForwardSimDetail::MergeFrom(const ForwardSimDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.ForwardSimDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_lon()->::planning::eudm::LonSimDetail::MergeFrom(from._internal_lon());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lat()->::planning::eudm::LatSimDetail::MergeFrom(from._internal_lat());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_evasive()->::planning::eudm::EvasiveSimDetail::MergeFrom(from._internal_evasive());
    }
    if (cached_has_bits & 0x00000008u) {
      cooperative_lat_range_ = from.cooperative_lat_range_;
    }
    if (cached_has_bits & 0x00000010u) {
      lon_aggressive_ratio_ = from.lon_aggressive_ratio_;
    }
    if (cached_has_bits & 0x00000020u) {
      auto_dec_if_lat_failed_ = from.auto_dec_if_lat_failed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ForwardSimDetail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.ForwardSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ForwardSimDetail::CopyFrom(const ForwardSimDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.ForwardSimDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForwardSimDetail::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_lon()) {
    if (!lon_->IsInitialized()) return false;
  }
  if (_internal_has_lat()) {
    if (!lat_->IsInitialized()) return false;
  }
  if (_internal_has_evasive()) {
    if (!evasive_->IsInitialized()) return false;
  }
  return true;
}

void ForwardSimDetail::InternalSwap(ForwardSimDetail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForwardSimDetail, auto_dec_if_lat_failed_)
      + sizeof(ForwardSimDetail::auto_dec_if_lat_failed_)
      - PROTOBUF_FIELD_OFFSET(ForwardSimDetail, lon_)>(
          reinterpret_cast<char*>(&lon_),
          reinterpret_cast<char*>(&other->lon_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForwardSimDetail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class SimRefLine::_Internal {
 public:
  using HasBits = decltype(std::declval<SimRefLine>()._has_bits_);
  static void set_has_len_vel_coeff(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_forward_len_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_forward_len_min(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_backward_len_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

SimRefLine::SimRefLine(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.SimRefLine)
}
SimRefLine::SimRefLine(const SimRefLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&len_vel_coeff_, &from.len_vel_coeff_,
    static_cast<size_t>(reinterpret_cast<char*>(&backward_len_max_) -
    reinterpret_cast<char*>(&len_vel_coeff_)) + sizeof(backward_len_max_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.SimRefLine)
}

void SimRefLine::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&len_vel_coeff_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backward_len_max_) -
    reinterpret_cast<char*>(&len_vel_coeff_)) + sizeof(backward_len_max_));
}

SimRefLine::~SimRefLine() {
  // @@protoc_insertion_point(destructor:planning.eudm.SimRefLine)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SimRefLine::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SimRefLine::ArenaDtor(void* object) {
  SimRefLine* _this = reinterpret_cast< SimRefLine* >(object);
  (void)_this;
}
void SimRefLine::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimRefLine::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimRefLine::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.SimRefLine)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&len_vel_coeff_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&backward_len_max_) -
        reinterpret_cast<char*>(&len_vel_coeff_)) + sizeof(backward_len_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimRefLine::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double len_vel_coeff = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_len_vel_coeff(&has_bits);
          len_vel_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double forward_len_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_forward_len_max(&has_bits);
          forward_len_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double forward_len_min = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_forward_len_min(&has_bits);
          forward_len_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double backward_len_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_backward_len_max(&has_bits);
          backward_len_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimRefLine::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.SimRefLine)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double len_vel_coeff = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_len_vel_coeff(), target);
  }

  // required double forward_len_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_forward_len_max(), target);
  }

  // required double forward_len_min = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_forward_len_min(), target);
  }

  // required double backward_len_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_backward_len_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.SimRefLine)
  return target;
}

size_t SimRefLine::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.SimRefLine)
  size_t total_size = 0;

  if (_internal_has_len_vel_coeff()) {
    // required double len_vel_coeff = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_forward_len_max()) {
    // required double forward_len_max = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_forward_len_min()) {
    // required double forward_len_min = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_backward_len_max()) {
    // required double backward_len_max = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t SimRefLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.SimRefLine)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double len_vel_coeff = 1;
    total_size += 1 + 8;

    // required double forward_len_max = 2;
    total_size += 1 + 8;

    // required double forward_len_min = 3;
    total_size += 1 + 8;

    // required double backward_len_max = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimRefLine::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.SimRefLine)
  GOOGLE_DCHECK_NE(&from, this);
  const SimRefLine* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SimRefLine>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.SimRefLine)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.SimRefLine)
    MergeFrom(*source);
  }
}

void SimRefLine::MergeFrom(const SimRefLine& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.SimRefLine)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      len_vel_coeff_ = from.len_vel_coeff_;
    }
    if (cached_has_bits & 0x00000002u) {
      forward_len_max_ = from.forward_len_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      forward_len_min_ = from.forward_len_min_;
    }
    if (cached_has_bits & 0x00000008u) {
      backward_len_max_ = from.backward_len_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimRefLine::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.SimRefLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimRefLine::CopyFrom(const SimRefLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.SimRefLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimRefLine::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SimRefLine::InternalSwap(SimRefLine* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimRefLine, backward_len_max_)
      + sizeof(SimRefLine::backward_len_max_)
      - PROTOBUF_FIELD_OFFSET(SimRefLine, len_vel_coeff_)>(
          reinterpret_cast<char*>(&len_vel_coeff_),
          reinterpret_cast<char*>(&other->len_vel_coeff_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimRefLine::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class SimCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<SimCfg>()._has_bits_);
  static const ::planning::eudm::SimDurationDetail& duration(const SimCfg* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::planning::eudm::ForwardSimDetail& ego(const SimCfg* msg);
  static void set_has_ego(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::planning::eudm::ForwardSimDetail& agent(const SimCfg* msg);
  static void set_has_agent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_acc_cmd_vel_gap(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dec_cmd_vel_gap(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::planning::eudm::SimRefLine& ref_line(const SimCfg* msg);
  static void set_has_ref_line(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

const ::planning::eudm::SimDurationDetail&
SimCfg::_Internal::duration(const SimCfg* msg) {
  return *msg->duration_;
}
const ::planning::eudm::ForwardSimDetail&
SimCfg::_Internal::ego(const SimCfg* msg) {
  return *msg->ego_;
}
const ::planning::eudm::ForwardSimDetail&
SimCfg::_Internal::agent(const SimCfg* msg) {
  return *msg->agent_;
}
const ::planning::eudm::SimRefLine&
SimCfg::_Internal::ref_line(const SimCfg* msg) {
  return *msg->ref_line_;
}
SimCfg::SimCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.SimCfg)
}
SimCfg::SimCfg(const SimCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_duration()) {
    duration_ = new ::planning::eudm::SimDurationDetail(*from.duration_);
  } else {
    duration_ = nullptr;
  }
  if (from._internal_has_ego()) {
    ego_ = new ::planning::eudm::ForwardSimDetail(*from.ego_);
  } else {
    ego_ = nullptr;
  }
  if (from._internal_has_agent()) {
    agent_ = new ::planning::eudm::ForwardSimDetail(*from.agent_);
  } else {
    agent_ = nullptr;
  }
  if (from._internal_has_ref_line()) {
    ref_line_ = new ::planning::eudm::SimRefLine(*from.ref_line_);
  } else {
    ref_line_ = nullptr;
  }
  ::memcpy(&acc_cmd_vel_gap_, &from.acc_cmd_vel_gap_,
    static_cast<size_t>(reinterpret_cast<char*>(&dec_cmd_vel_gap_) -
    reinterpret_cast<char*>(&acc_cmd_vel_gap_)) + sizeof(dec_cmd_vel_gap_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.SimCfg)
}

void SimCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&duration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dec_cmd_vel_gap_) -
    reinterpret_cast<char*>(&duration_)) + sizeof(dec_cmd_vel_gap_));
}

SimCfg::~SimCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.SimCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SimCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete duration_;
  if (this != internal_default_instance()) delete ego_;
  if (this != internal_default_instance()) delete agent_;
  if (this != internal_default_instance()) delete ref_line_;
}

void SimCfg::ArenaDtor(void* object) {
  SimCfg* _this = reinterpret_cast< SimCfg* >(object);
  (void)_this;
}
void SimCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.SimCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(duration_ != nullptr);
      duration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(ego_ != nullptr);
      ego_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(agent_ != nullptr);
      agent_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(ref_line_ != nullptr);
      ref_line_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&acc_cmd_vel_gap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dec_cmd_vel_gap_) -
        reinterpret_cast<char*>(&acc_cmd_vel_gap_)) + sizeof(dec_cmd_vel_gap_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.SimDurationDetail duration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.ForwardSimDetail ego = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ego(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.ForwardSimDetail agent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_agent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double acc_cmd_vel_gap = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_acc_cmd_vel_gap(&has_bits);
          acc_cmd_vel_gap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double dec_cmd_vel_gap = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_dec_cmd_vel_gap(&has_bits);
          dec_cmd_vel_gap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.SimRefLine ref_line = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ref_line(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.SimCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.SimDurationDetail duration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::duration(this), target, stream);
  }

  // required .planning.eudm.ForwardSimDetail ego = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ego(this), target, stream);
  }

  // required .planning.eudm.ForwardSimDetail agent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::agent(this), target, stream);
  }

  // required double acc_cmd_vel_gap = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_acc_cmd_vel_gap(), target);
  }

  // required double dec_cmd_vel_gap = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_dec_cmd_vel_gap(), target);
  }

  // required .planning.eudm.SimRefLine ref_line = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::ref_line(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.SimCfg)
  return target;
}

size_t SimCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.SimCfg)
  size_t total_size = 0;

  if (_internal_has_duration()) {
    // required .planning.eudm.SimDurationDetail duration = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);
  }

  if (_internal_has_ego()) {
    // required .planning.eudm.ForwardSimDetail ego = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ego_);
  }

  if (_internal_has_agent()) {
    // required .planning.eudm.ForwardSimDetail agent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *agent_);
  }

  if (_internal_has_ref_line()) {
    // required .planning.eudm.SimRefLine ref_line = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ref_line_);
  }

  if (_internal_has_acc_cmd_vel_gap()) {
    // required double acc_cmd_vel_gap = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_dec_cmd_vel_gap()) {
    // required double dec_cmd_vel_gap = 5;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t SimCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.SimCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required .planning.eudm.SimDurationDetail duration = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *duration_);

    // required .planning.eudm.ForwardSimDetail ego = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ego_);

    // required .planning.eudm.ForwardSimDetail agent = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *agent_);

    // required .planning.eudm.SimRefLine ref_line = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ref_line_);

    // required double acc_cmd_vel_gap = 4;
    total_size += 1 + 8;

    // required double dec_cmd_vel_gap = 5;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.SimCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const SimCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SimCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.SimCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.SimCfg)
    MergeFrom(*source);
  }
}

void SimCfg::MergeFrom(const SimCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.SimCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_duration()->::planning::eudm::SimDurationDetail::MergeFrom(from._internal_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_ego()->::planning::eudm::ForwardSimDetail::MergeFrom(from._internal_ego());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_agent()->::planning::eudm::ForwardSimDetail::MergeFrom(from._internal_agent());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_ref_line()->::planning::eudm::SimRefLine::MergeFrom(from._internal_ref_line());
    }
    if (cached_has_bits & 0x00000010u) {
      acc_cmd_vel_gap_ = from.acc_cmd_vel_gap_;
    }
    if (cached_has_bits & 0x00000020u) {
      dec_cmd_vel_gap_ = from.dec_cmd_vel_gap_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.SimCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimCfg::CopyFrom(const SimCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.SimCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_duration()) {
    if (!duration_->IsInitialized()) return false;
  }
  if (_internal_has_ego()) {
    if (!ego_->IsInitialized()) return false;
  }
  if (_internal_has_agent()) {
    if (!agent_->IsInitialized()) return false;
  }
  if (_internal_has_ref_line()) {
    if (!ref_line_->IsInitialized()) return false;
  }
  return true;
}

void SimCfg::InternalSwap(SimCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimCfg, dec_cmd_vel_gap_)
      + sizeof(SimCfg::dec_cmd_vel_gap_)
      - PROTOBUF_FIELD_OFFSET(SimCfg, duration_)>(
          reinterpret_cast<char*>(&duration_),
          reinterpret_cast<char*>(&other->duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class ActiveLaneChangeCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<ActiveLaneChangeCfg>()._has_bits_);
  static void set_has_cold_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_activate_speed_lower_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_activate_speed_upper_bound(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_activate_max_duration_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_active_min_operation_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consistent_operate_time_min_gap(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_consistent_min_num_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_enable_clear_accumulation_by_forbid_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_enable_auto_cancel_by_forbid_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_enable_auto_cancel_by_outdate_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enable_auto_canbel_by_stick_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_auto_cancel_if_late_for_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000fff) ^ 0x00000fff) != 0;
  }
};

ActiveLaneChangeCfg::ActiveLaneChangeCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.ActiveLaneChangeCfg)
}
ActiveLaneChangeCfg::ActiveLaneChangeCfg(const ActiveLaneChangeCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cold_duration_, &from.cold_duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_auto_canbel_by_stick_signal_) -
    reinterpret_cast<char*>(&cold_duration_)) + sizeof(enable_auto_canbel_by_stick_signal_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.ActiveLaneChangeCfg)
}

void ActiveLaneChangeCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cold_duration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_auto_canbel_by_stick_signal_) -
    reinterpret_cast<char*>(&cold_duration_)) + sizeof(enable_auto_canbel_by_stick_signal_));
}

ActiveLaneChangeCfg::~ActiveLaneChangeCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.ActiveLaneChangeCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ActiveLaneChangeCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ActiveLaneChangeCfg::ArenaDtor(void* object) {
  ActiveLaneChangeCfg* _this = reinterpret_cast< ActiveLaneChangeCfg* >(object);
  (void)_this;
}
void ActiveLaneChangeCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActiveLaneChangeCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActiveLaneChangeCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.ActiveLaneChangeCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&cold_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&auto_cancel_if_late_for_seconds_) -
        reinterpret_cast<char*>(&cold_duration_)) + sizeof(auto_cancel_if_late_for_seconds_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&enable_clear_accumulation_by_forbid_signal_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_auto_canbel_by_stick_signal_) -
        reinterpret_cast<char*>(&enable_clear_accumulation_by_forbid_signal_)) + sizeof(enable_auto_canbel_by_stick_signal_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActiveLaneChangeCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double cold_duration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_cold_duration(&has_bits);
          cold_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double activate_speed_lower_bound = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_activate_speed_lower_bound(&has_bits);
          activate_speed_lower_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double activate_speed_upper_bound = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_activate_speed_upper_bound(&has_bits);
          activate_speed_upper_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double activate_max_duration_in_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_activate_max_duration_in_seconds(&has_bits);
          activate_max_duration_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double active_min_operation_in_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_active_min_operation_in_seconds(&has_bits);
          active_min_operation_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double consistent_operate_time_min_gap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_consistent_operate_time_min_gap(&has_bits);
          consistent_operate_time_min_gap_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double consistent_min_num_frame = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_consistent_min_num_frame(&has_bits);
          consistent_min_num_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required bool enable_clear_accumulation_by_forbid_signal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_enable_clear_accumulation_by_forbid_signal(&has_bits);
          enable_clear_accumulation_by_forbid_signal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_auto_cancel_by_forbid_signal = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_enable_auto_cancel_by_forbid_signal(&has_bits);
          enable_auto_cancel_by_forbid_signal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_auto_cancel_by_outdate_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_enable_auto_cancel_by_outdate_time(&has_bits);
          enable_auto_cancel_by_outdate_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_auto_canbel_by_stick_signal = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_enable_auto_canbel_by_stick_signal(&has_bits);
          enable_auto_canbel_by_stick_signal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double auto_cancel_if_late_for_seconds = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 97)) {
          _Internal::set_has_auto_cancel_if_late_for_seconds(&has_bits);
          auto_cancel_if_late_for_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActiveLaneChangeCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.ActiveLaneChangeCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double cold_duration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_cold_duration(), target);
  }

  // required double activate_speed_lower_bound = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_activate_speed_lower_bound(), target);
  }

  // required double activate_speed_upper_bound = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_activate_speed_upper_bound(), target);
  }

  // required double activate_max_duration_in_seconds = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_activate_max_duration_in_seconds(), target);
  }

  // required double active_min_operation_in_seconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_active_min_operation_in_seconds(), target);
  }

  // required double consistent_operate_time_min_gap = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_consistent_operate_time_min_gap(), target);
  }

  // required double consistent_min_num_frame = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_consistent_min_num_frame(), target);
  }

  // required bool enable_clear_accumulation_by_forbid_signal = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_enable_clear_accumulation_by_forbid_signal(), target);
  }

  // required bool enable_auto_cancel_by_forbid_signal = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_enable_auto_cancel_by_forbid_signal(), target);
  }

  // required bool enable_auto_cancel_by_outdate_time = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_enable_auto_cancel_by_outdate_time(), target);
  }

  // required bool enable_auto_canbel_by_stick_signal = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_enable_auto_canbel_by_stick_signal(), target);
  }

  // required double auto_cancel_if_late_for_seconds = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_auto_cancel_if_late_for_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.ActiveLaneChangeCfg)
  return target;
}

size_t ActiveLaneChangeCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.ActiveLaneChangeCfg)
  size_t total_size = 0;

  if (_internal_has_cold_duration()) {
    // required double cold_duration = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_activate_speed_lower_bound()) {
    // required double activate_speed_lower_bound = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_activate_speed_upper_bound()) {
    // required double activate_speed_upper_bound = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_activate_max_duration_in_seconds()) {
    // required double activate_max_duration_in_seconds = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_active_min_operation_in_seconds()) {
    // required double active_min_operation_in_seconds = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_consistent_operate_time_min_gap()) {
    // required double consistent_operate_time_min_gap = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_consistent_min_num_frame()) {
    // required double consistent_min_num_frame = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_auto_cancel_if_late_for_seconds()) {
    // required double auto_cancel_if_late_for_seconds = 12;
    total_size += 1 + 8;
  }

  if (_internal_has_enable_clear_accumulation_by_forbid_signal()) {
    // required bool enable_clear_accumulation_by_forbid_signal = 8;
    total_size += 1 + 1;
  }

  if (_internal_has_enable_auto_cancel_by_forbid_signal()) {
    // required bool enable_auto_cancel_by_forbid_signal = 9;
    total_size += 1 + 1;
  }

  if (_internal_has_enable_auto_cancel_by_outdate_time()) {
    // required bool enable_auto_cancel_by_outdate_time = 10;
    total_size += 1 + 1;
  }

  if (_internal_has_enable_auto_canbel_by_stick_signal()) {
    // required bool enable_auto_canbel_by_stick_signal = 11;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ActiveLaneChangeCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.ActiveLaneChangeCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000fff) ^ 0x00000fff) == 0) {  // All required fields are present.
    // required double cold_duration = 1;
    total_size += 1 + 8;

    // required double activate_speed_lower_bound = 2;
    total_size += 1 + 8;

    // required double activate_speed_upper_bound = 3;
    total_size += 1 + 8;

    // required double activate_max_duration_in_seconds = 4;
    total_size += 1 + 8;

    // required double active_min_operation_in_seconds = 5;
    total_size += 1 + 8;

    // required double consistent_operate_time_min_gap = 6;
    total_size += 1 + 8;

    // required double consistent_min_num_frame = 7;
    total_size += 1 + 8;

    // required double auto_cancel_if_late_for_seconds = 12;
    total_size += 1 + 8;

    // required bool enable_clear_accumulation_by_forbid_signal = 8;
    total_size += 1 + 1;

    // required bool enable_auto_cancel_by_forbid_signal = 9;
    total_size += 1 + 1;

    // required bool enable_auto_cancel_by_outdate_time = 10;
    total_size += 1 + 1;

    // required bool enable_auto_canbel_by_stick_signal = 11;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActiveLaneChangeCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.ActiveLaneChangeCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const ActiveLaneChangeCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ActiveLaneChangeCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.ActiveLaneChangeCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.ActiveLaneChangeCfg)
    MergeFrom(*source);
  }
}

void ActiveLaneChangeCfg::MergeFrom(const ActiveLaneChangeCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.ActiveLaneChangeCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      cold_duration_ = from.cold_duration_;
    }
    if (cached_has_bits & 0x00000002u) {
      activate_speed_lower_bound_ = from.activate_speed_lower_bound_;
    }
    if (cached_has_bits & 0x00000004u) {
      activate_speed_upper_bound_ = from.activate_speed_upper_bound_;
    }
    if (cached_has_bits & 0x00000008u) {
      activate_max_duration_in_seconds_ = from.activate_max_duration_in_seconds_;
    }
    if (cached_has_bits & 0x00000010u) {
      active_min_operation_in_seconds_ = from.active_min_operation_in_seconds_;
    }
    if (cached_has_bits & 0x00000020u) {
      consistent_operate_time_min_gap_ = from.consistent_operate_time_min_gap_;
    }
    if (cached_has_bits & 0x00000040u) {
      consistent_min_num_frame_ = from.consistent_min_num_frame_;
    }
    if (cached_has_bits & 0x00000080u) {
      auto_cancel_if_late_for_seconds_ = from.auto_cancel_if_late_for_seconds_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      enable_clear_accumulation_by_forbid_signal_ = from.enable_clear_accumulation_by_forbid_signal_;
    }
    if (cached_has_bits & 0x00000200u) {
      enable_auto_cancel_by_forbid_signal_ = from.enable_auto_cancel_by_forbid_signal_;
    }
    if (cached_has_bits & 0x00000400u) {
      enable_auto_cancel_by_outdate_time_ = from.enable_auto_cancel_by_outdate_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      enable_auto_canbel_by_stick_signal_ = from.enable_auto_canbel_by_stick_signal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ActiveLaneChangeCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.ActiveLaneChangeCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActiveLaneChangeCfg::CopyFrom(const ActiveLaneChangeCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.ActiveLaneChangeCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActiveLaneChangeCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ActiveLaneChangeCfg::InternalSwap(ActiveLaneChangeCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActiveLaneChangeCfg, enable_auto_canbel_by_stick_signal_)
      + sizeof(ActiveLaneChangeCfg::enable_auto_canbel_by_stick_signal_)
      - PROTOBUF_FIELD_OFFSET(ActiveLaneChangeCfg, cold_duration_)>(
          reinterpret_cast<char*>(&cold_duration_),
          reinterpret_cast<char*>(&other->cold_duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActiveLaneChangeCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class FunctionCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<FunctionCfg>()._has_bits_);
  static void set_has_mobil_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_active_lc_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::planning::eudm::ActiveLaneChangeCfg& active_lc(const FunctionCfg* msg);
  static void set_has_active_lc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stick_lane_change_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::planning::eudm::ActiveLaneChangeCfg&
FunctionCfg::_Internal::active_lc(const FunctionCfg* msg) {
  return *msg->active_lc_;
}
FunctionCfg::FunctionCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.FunctionCfg)
}
FunctionCfg::FunctionCfg(const FunctionCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_active_lc()) {
    active_lc_ = new ::planning::eudm::ActiveLaneChangeCfg(*from.active_lc_);
  } else {
    active_lc_ = nullptr;
  }
  ::memcpy(&stick_lane_change_in_seconds_, &from.stick_lane_change_in_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&active_lc_enable_) -
    reinterpret_cast<char*>(&stick_lane_change_in_seconds_)) + sizeof(active_lc_enable_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.FunctionCfg)
}

void FunctionCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&active_lc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&active_lc_enable_) -
    reinterpret_cast<char*>(&active_lc_)) + sizeof(active_lc_enable_));
}

FunctionCfg::~FunctionCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.FunctionCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FunctionCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete active_lc_;
}

void FunctionCfg::ArenaDtor(void* object) {
  FunctionCfg* _this = reinterpret_cast< FunctionCfg* >(object);
  (void)_this;
}
void FunctionCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FunctionCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FunctionCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.FunctionCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(active_lc_ != nullptr);
    active_lc_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&stick_lane_change_in_seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&active_lc_enable_) -
        reinterpret_cast<char*>(&stick_lane_change_in_seconds_)) + sizeof(active_lc_enable_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool mobil_enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_mobil_enable(&has_bits);
          mobil_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool active_lc_enable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_active_lc_enable(&has_bits);
          active_lc_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_active_lc(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double stick_lane_change_in_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_stick_lane_change_in_seconds(&has_bits);
          stick_lane_change_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FunctionCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.FunctionCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool mobil_enable = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_mobil_enable(), target);
  }

  // required bool active_lc_enable = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_active_lc_enable(), target);
  }

  // required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::active_lc(this), target, stream);
  }

  // required double stick_lane_change_in_seconds = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_stick_lane_change_in_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.FunctionCfg)
  return target;
}

size_t FunctionCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.FunctionCfg)
  size_t total_size = 0;

  if (_internal_has_active_lc()) {
    // required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *active_lc_);
  }

  if (_internal_has_stick_lane_change_in_seconds()) {
    // required double stick_lane_change_in_seconds = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_mobil_enable()) {
    // required bool mobil_enable = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_active_lc_enable()) {
    // required bool active_lc_enable = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t FunctionCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.FunctionCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .planning.eudm.ActiveLaneChangeCfg active_lc = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *active_lc_);

    // required double stick_lane_change_in_seconds = 4;
    total_size += 1 + 8;

    // required bool mobil_enable = 1;
    total_size += 1 + 1;

    // required bool active_lc_enable = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FunctionCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.FunctionCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const FunctionCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FunctionCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.FunctionCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.FunctionCfg)
    MergeFrom(*source);
  }
}

void FunctionCfg::MergeFrom(const FunctionCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.FunctionCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_active_lc()->::planning::eudm::ActiveLaneChangeCfg::MergeFrom(from._internal_active_lc());
    }
    if (cached_has_bits & 0x00000002u) {
      stick_lane_change_in_seconds_ = from.stick_lane_change_in_seconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      mobil_enable_ = from.mobil_enable_;
    }
    if (cached_has_bits & 0x00000008u) {
      active_lc_enable_ = from.active_lc_enable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FunctionCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.FunctionCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FunctionCfg::CopyFrom(const FunctionCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.FunctionCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_active_lc()) {
    if (!active_lc_->IsInitialized()) return false;
  }
  return true;
}

void FunctionCfg::InternalSwap(FunctionCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FunctionCfg, active_lc_enable_)
      + sizeof(FunctionCfg::active_lc_enable_)
      - PROTOBUF_FIELD_OFFSET(FunctionCfg, active_lc_)>(
          reinterpret_cast<char*>(&active_lc_),
          reinterpret_cast<char*>(&other->active_lc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class RssCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<RssCfg>()._has_bits_);
  static void set_has_response_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_longitudinal_acc_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_longitudinal_brake_min(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_longitudinal_brake_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lateral_acc_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lateral_brake_min(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lateral_brake_max(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_lateral_miu(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

RssCfg::RssCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.RssCfg)
}
RssCfg::RssCfg(const RssCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&response_time_, &from.response_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&lateral_miu_) -
    reinterpret_cast<char*>(&response_time_)) + sizeof(lateral_miu_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.RssCfg)
}

void RssCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&response_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lateral_miu_) -
    reinterpret_cast<char*>(&response_time_)) + sizeof(lateral_miu_));
}

RssCfg::~RssCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.RssCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RssCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void RssCfg::ArenaDtor(void* object) {
  RssCfg* _this = reinterpret_cast< RssCfg* >(object);
  (void)_this;
}
void RssCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RssCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RssCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.RssCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&response_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lateral_miu_) -
        reinterpret_cast<char*>(&response_time_)) + sizeof(lateral_miu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RssCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double response_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_response_time(&has_bits);
          response_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double longitudinal_acc_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_longitudinal_acc_max(&has_bits);
          longitudinal_acc_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double longitudinal_brake_min = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_longitudinal_brake_min(&has_bits);
          longitudinal_brake_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double longitudinal_brake_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_longitudinal_brake_max(&has_bits);
          longitudinal_brake_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lateral_acc_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 41)) {
          _Internal::set_has_lateral_acc_max(&has_bits);
          lateral_acc_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lateral_brake_min = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_lateral_brake_min(&has_bits);
          lateral_brake_min_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lateral_brake_max = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_lateral_brake_max(&has_bits);
          lateral_brake_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double lateral_miu = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_lateral_miu(&has_bits);
          lateral_miu_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RssCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.RssCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double response_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_response_time(), target);
  }

  // required double longitudinal_acc_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_longitudinal_acc_max(), target);
  }

  // required double longitudinal_brake_min = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_longitudinal_brake_min(), target);
  }

  // required double longitudinal_brake_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_longitudinal_brake_max(), target);
  }

  // required double lateral_acc_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_lateral_acc_max(), target);
  }

  // required double lateral_brake_min = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_lateral_brake_min(), target);
  }

  // required double lateral_brake_max = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_lateral_brake_max(), target);
  }

  // required double lateral_miu = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_lateral_miu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.RssCfg)
  return target;
}

size_t RssCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.RssCfg)
  size_t total_size = 0;

  if (_internal_has_response_time()) {
    // required double response_time = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_longitudinal_acc_max()) {
    // required double longitudinal_acc_max = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_longitudinal_brake_min()) {
    // required double longitudinal_brake_min = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_longitudinal_brake_max()) {
    // required double longitudinal_brake_max = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_lateral_acc_max()) {
    // required double lateral_acc_max = 5;
    total_size += 1 + 8;
  }

  if (_internal_has_lateral_brake_min()) {
    // required double lateral_brake_min = 6;
    total_size += 1 + 8;
  }

  if (_internal_has_lateral_brake_max()) {
    // required double lateral_brake_max = 7;
    total_size += 1 + 8;
  }

  if (_internal_has_lateral_miu()) {
    // required double lateral_miu = 8;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t RssCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.RssCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required double response_time = 1;
    total_size += 1 + 8;

    // required double longitudinal_acc_max = 2;
    total_size += 1 + 8;

    // required double longitudinal_brake_min = 3;
    total_size += 1 + 8;

    // required double longitudinal_brake_max = 4;
    total_size += 1 + 8;

    // required double lateral_acc_max = 5;
    total_size += 1 + 8;

    // required double lateral_brake_min = 6;
    total_size += 1 + 8;

    // required double lateral_brake_max = 7;
    total_size += 1 + 8;

    // required double lateral_miu = 8;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RssCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.RssCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const RssCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RssCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.RssCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.RssCfg)
    MergeFrom(*source);
  }
}

void RssCfg::MergeFrom(const RssCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.RssCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      response_time_ = from.response_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      longitudinal_acc_max_ = from.longitudinal_acc_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      longitudinal_brake_min_ = from.longitudinal_brake_min_;
    }
    if (cached_has_bits & 0x00000008u) {
      longitudinal_brake_max_ = from.longitudinal_brake_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      lateral_acc_max_ = from.lateral_acc_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      lateral_brake_min_ = from.lateral_brake_min_;
    }
    if (cached_has_bits & 0x00000040u) {
      lateral_brake_max_ = from.lateral_brake_max_;
    }
    if (cached_has_bits & 0x00000080u) {
      lateral_miu_ = from.lateral_miu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RssCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.RssCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RssCfg::CopyFrom(const RssCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.RssCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RssCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RssCfg::InternalSwap(RssCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RssCfg, lateral_miu_)
      + sizeof(RssCfg::lateral_miu_)
      - PROTOBUF_FIELD_OFFSET(RssCfg, response_time_)>(
          reinterpret_cast<char*>(&response_time_),
          reinterpret_cast<char*>(&other->response_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RssCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class StrictCheckCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<StrictCheckCfg>()._has_bits_);
  static void set_has_inflation_w(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_inflation_h(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StrictCheckCfg::StrictCheckCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.StrictCheckCfg)
}
StrictCheckCfg::StrictCheckCfg(const StrictCheckCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&inflation_w_, &from.inflation_w_,
    static_cast<size_t>(reinterpret_cast<char*>(&inflation_h_) -
    reinterpret_cast<char*>(&inflation_w_)) + sizeof(inflation_h_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.StrictCheckCfg)
}

void StrictCheckCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&inflation_w_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&inflation_h_) -
    reinterpret_cast<char*>(&inflation_w_)) + sizeof(inflation_h_));
}

StrictCheckCfg::~StrictCheckCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.StrictCheckCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StrictCheckCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StrictCheckCfg::ArenaDtor(void* object) {
  StrictCheckCfg* _this = reinterpret_cast< StrictCheckCfg* >(object);
  (void)_this;
}
void StrictCheckCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StrictCheckCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StrictCheckCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.StrictCheckCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&inflation_w_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&inflation_h_) -
        reinterpret_cast<char*>(&inflation_w_)) + sizeof(inflation_h_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrictCheckCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required double inflation_w = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_inflation_w(&has_bits);
          inflation_w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double inflation_h = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_inflation_h(&has_bits);
          inflation_h_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StrictCheckCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.StrictCheckCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double inflation_w = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_inflation_w(), target);
  }

  // required double inflation_h = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_inflation_h(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.StrictCheckCfg)
  return target;
}

size_t StrictCheckCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.StrictCheckCfg)
  size_t total_size = 0;

  if (_internal_has_inflation_w()) {
    // required double inflation_w = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_inflation_h()) {
    // required double inflation_h = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t StrictCheckCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.StrictCheckCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double inflation_w = 1;
    total_size += 1 + 8;

    // required double inflation_h = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StrictCheckCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.StrictCheckCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const StrictCheckCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StrictCheckCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.StrictCheckCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.StrictCheckCfg)
    MergeFrom(*source);
  }
}

void StrictCheckCfg::MergeFrom(const StrictCheckCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.StrictCheckCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      inflation_w_ = from.inflation_w_;
    }
    if (cached_has_bits & 0x00000002u) {
      inflation_h_ = from.inflation_h_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StrictCheckCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.StrictCheckCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StrictCheckCfg::CopyFrom(const StrictCheckCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.StrictCheckCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrictCheckCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StrictCheckCfg::InternalSwap(StrictCheckCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StrictCheckCfg, inflation_h_)
      + sizeof(StrictCheckCfg::inflation_h_)
      - PROTOBUF_FIELD_OFFSET(StrictCheckCfg, inflation_w_)>(
          reinterpret_cast<char*>(&inflation_w_),
          reinterpret_cast<char*>(&other->inflation_w_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StrictCheckCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class SafetyCfg::_Internal {
 public:
  using HasBits = decltype(std::declval<SafetyCfg>()._has_bits_);
  static const ::planning::eudm::StrictCheckCfg& strict(const SafetyCfg* msg);
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_strict_check_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::planning::eudm::RssCfg& rss(const SafetyCfg* msg);
  static void set_has_rss(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rss_check_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::planning::eudm::RssCfg& rss_strict_as_front(const SafetyCfg* msg);
  static void set_has_rss_strict_as_front(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::planning::eudm::RssCfg& rss_strict_as_rear(const SafetyCfg* msg);
  static void set_has_rss_strict_as_rear(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rss_for_layers_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

const ::planning::eudm::StrictCheckCfg&
SafetyCfg::_Internal::strict(const SafetyCfg* msg) {
  return *msg->strict_;
}
const ::planning::eudm::RssCfg&
SafetyCfg::_Internal::rss(const SafetyCfg* msg) {
  return *msg->rss_;
}
const ::planning::eudm::RssCfg&
SafetyCfg::_Internal::rss_strict_as_front(const SafetyCfg* msg) {
  return *msg->rss_strict_as_front_;
}
const ::planning::eudm::RssCfg&
SafetyCfg::_Internal::rss_strict_as_rear(const SafetyCfg* msg) {
  return *msg->rss_strict_as_rear_;
}
SafetyCfg::SafetyCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.SafetyCfg)
}
SafetyCfg::SafetyCfg(const SafetyCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_strict()) {
    strict_ = new ::planning::eudm::StrictCheckCfg(*from.strict_);
  } else {
    strict_ = nullptr;
  }
  if (from._internal_has_rss()) {
    rss_ = new ::planning::eudm::RssCfg(*from.rss_);
  } else {
    rss_ = nullptr;
  }
  if (from._internal_has_rss_strict_as_front()) {
    rss_strict_as_front_ = new ::planning::eudm::RssCfg(*from.rss_strict_as_front_);
  } else {
    rss_strict_as_front_ = nullptr;
  }
  if (from._internal_has_rss_strict_as_rear()) {
    rss_strict_as_rear_ = new ::planning::eudm::RssCfg(*from.rss_strict_as_rear_);
  } else {
    rss_strict_as_rear_ = nullptr;
  }
  ::memcpy(&strict_check_enable_, &from.strict_check_enable_,
    static_cast<size_t>(reinterpret_cast<char*>(&rss_for_layers_enable_) -
    reinterpret_cast<char*>(&strict_check_enable_)) + sizeof(rss_for_layers_enable_));
  // @@protoc_insertion_point(copy_constructor:planning.eudm.SafetyCfg)
}

void SafetyCfg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&strict_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rss_for_layers_enable_) -
    reinterpret_cast<char*>(&strict_)) + sizeof(rss_for_layers_enable_));
}

SafetyCfg::~SafetyCfg() {
  // @@protoc_insertion_point(destructor:planning.eudm.SafetyCfg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SafetyCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete strict_;
  if (this != internal_default_instance()) delete rss_;
  if (this != internal_default_instance()) delete rss_strict_as_front_;
  if (this != internal_default_instance()) delete rss_strict_as_rear_;
}

void SafetyCfg::ArenaDtor(void* object) {
  SafetyCfg* _this = reinterpret_cast< SafetyCfg* >(object);
  (void)_this;
}
void SafetyCfg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SafetyCfg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SafetyCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.SafetyCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(strict_ != nullptr);
      strict_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(rss_ != nullptr);
      rss_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rss_strict_as_front_ != nullptr);
      rss_strict_as_front_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rss_strict_as_rear_ != nullptr);
      rss_strict_as_rear_->Clear();
    }
  }
  ::memset(&strict_check_enable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rss_for_layers_enable_) -
      reinterpret_cast<char*>(&strict_check_enable_)) + sizeof(rss_for_layers_enable_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SafetyCfg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .planning.eudm.StrictCheckCfg strict = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_strict(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool strict_check_enable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_strict_check_enable(&has_bits);
          strict_check_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.RssCfg rss = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rss(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool rss_check_enable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_rss_check_enable(&has_bits);
          rss_check_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.RssCfg rss_strict_as_front = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rss_strict_as_front(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.RssCfg rss_strict_as_rear = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_rss_strict_as_rear(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool rss_for_layers_enable = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_rss_for_layers_enable(&has_bits);
          rss_for_layers_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SafetyCfg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.SafetyCfg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .planning.eudm.StrictCheckCfg strict = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::strict(this), target, stream);
  }

  // required bool strict_check_enable = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_strict_check_enable(), target);
  }

  // required .planning.eudm.RssCfg rss = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::rss(this), target, stream);
  }

  // required bool rss_check_enable = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_rss_check_enable(), target);
  }

  // required .planning.eudm.RssCfg rss_strict_as_front = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::rss_strict_as_front(this), target, stream);
  }

  // required .planning.eudm.RssCfg rss_strict_as_rear = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::rss_strict_as_rear(this), target, stream);
  }

  // required bool rss_for_layers_enable = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_rss_for_layers_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.SafetyCfg)
  return target;
}

size_t SafetyCfg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.SafetyCfg)
  size_t total_size = 0;

  if (_internal_has_strict()) {
    // required .planning.eudm.StrictCheckCfg strict = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *strict_);
  }

  if (_internal_has_rss()) {
    // required .planning.eudm.RssCfg rss = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_);
  }

  if (_internal_has_rss_strict_as_front()) {
    // required .planning.eudm.RssCfg rss_strict_as_front = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_strict_as_front_);
  }

  if (_internal_has_rss_strict_as_rear()) {
    // required .planning.eudm.RssCfg rss_strict_as_rear = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_strict_as_rear_);
  }

  if (_internal_has_strict_check_enable()) {
    // required bool strict_check_enable = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_rss_check_enable()) {
    // required bool rss_check_enable = 4;
    total_size += 1 + 1;
  }

  if (_internal_has_rss_for_layers_enable()) {
    // required bool rss_for_layers_enable = 7;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t SafetyCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.SafetyCfg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required .planning.eudm.StrictCheckCfg strict = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *strict_);

    // required .planning.eudm.RssCfg rss = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_);

    // required .planning.eudm.RssCfg rss_strict_as_front = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_strict_as_front_);

    // required .planning.eudm.RssCfg rss_strict_as_rear = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rss_strict_as_rear_);

    // required bool strict_check_enable = 2;
    total_size += 1 + 1;

    // required bool rss_check_enable = 4;
    total_size += 1 + 1;

    // required bool rss_for_layers_enable = 7;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SafetyCfg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.SafetyCfg)
  GOOGLE_DCHECK_NE(&from, this);
  const SafetyCfg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SafetyCfg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.SafetyCfg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.SafetyCfg)
    MergeFrom(*source);
  }
}

void SafetyCfg::MergeFrom(const SafetyCfg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.SafetyCfg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_strict()->::planning::eudm::StrictCheckCfg::MergeFrom(from._internal_strict());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_rss()->::planning::eudm::RssCfg::MergeFrom(from._internal_rss());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rss_strict_as_front()->::planning::eudm::RssCfg::MergeFrom(from._internal_rss_strict_as_front());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rss_strict_as_rear()->::planning::eudm::RssCfg::MergeFrom(from._internal_rss_strict_as_rear());
    }
    if (cached_has_bits & 0x00000010u) {
      strict_check_enable_ = from.strict_check_enable_;
    }
    if (cached_has_bits & 0x00000020u) {
      rss_check_enable_ = from.rss_check_enable_;
    }
    if (cached_has_bits & 0x00000040u) {
      rss_for_layers_enable_ = from.rss_for_layers_enable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SafetyCfg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.SafetyCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SafetyCfg::CopyFrom(const SafetyCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.SafetyCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SafetyCfg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_strict()) {
    if (!strict_->IsInitialized()) return false;
  }
  if (_internal_has_rss()) {
    if (!rss_->IsInitialized()) return false;
  }
  if (_internal_has_rss_strict_as_front()) {
    if (!rss_strict_as_front_->IsInitialized()) return false;
  }
  if (_internal_has_rss_strict_as_rear()) {
    if (!rss_strict_as_rear_->IsInitialized()) return false;
  }
  return true;
}

void SafetyCfg::InternalSwap(SafetyCfg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SafetyCfg, rss_for_layers_enable_)
      + sizeof(SafetyCfg::rss_for_layers_enable_)
      - PROTOBUF_FIELD_OFFSET(SafetyCfg, strict_)>(
          reinterpret_cast<char*>(&strict_),
          reinterpret_cast<char*>(&other->strict_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SafetyCfg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Config::_Internal {
 public:
  using HasBits = decltype(std::declval<Config>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::planning::eudm::CostAssessCfg& cost(const Config* msg);
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::planning::eudm::SimCfg& sim(const Config* msg);
  static void set_has_sim(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::planning::eudm::FunctionCfg& function(const Config* msg);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::planning::eudm::SafetyCfg& safety(const Config* msg);
  static void set_has_safety(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

const ::planning::eudm::CostAssessCfg&
Config::_Internal::cost(const Config* msg) {
  return *msg->cost_;
}
const ::planning::eudm::SimCfg&
Config::_Internal::sim(const Config* msg) {
  return *msg->sim_;
}
const ::planning::eudm::FunctionCfg&
Config::_Internal::function(const Config* msg) {
  return *msg->function_;
}
const ::planning::eudm::SafetyCfg&
Config::_Internal::safety(const Config* msg) {
  return *msg->safety_;
}
Config::Config(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:planning.eudm.Config)
}
Config::Config(const Config& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArena());
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_version()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArena());
  }
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArena());
  }
  if (from._internal_has_cost()) {
    cost_ = new ::planning::eudm::CostAssessCfg(*from.cost_);
  } else {
    cost_ = nullptr;
  }
  if (from._internal_has_sim()) {
    sim_ = new ::planning::eudm::SimCfg(*from.sim_);
  } else {
    sim_ = nullptr;
  }
  if (from._internal_has_function()) {
    function_ = new ::planning::eudm::FunctionCfg(*from.function_);
  } else {
    function_ = nullptr;
  }
  if (from._internal_has_safety()) {
    safety_ = new ::planning::eudm::SafetyCfg(*from.safety_);
  } else {
    safety_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:planning.eudm.Config)
}

void Config::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&safety_) -
    reinterpret_cast<char*>(&cost_)) + sizeof(safety_));
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:planning.eudm.Config)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Config::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete cost_;
  if (this != internal_default_instance()) delete sim_;
  if (this != internal_default_instance()) delete function_;
  if (this != internal_default_instance()) delete safety_;
}

void Config::ArenaDtor(void* object) {
  Config* _this = reinterpret_cast< Config* >(object);
  (void)_this;
}
void Config::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Config::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Config::Clear() {
// @@protoc_insertion_point(message_clear_start:planning.eudm.Config)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(cost_ != nullptr);
      cost_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(sim_ != nullptr);
      sim_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(function_ != nullptr);
      function_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(safety_ != nullptr);
      safety_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Config::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "planning.eudm.Config.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "planning.eudm.Config.version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "planning.eudm.Config.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.CostAssessCfg cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cost(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.SimCfg sim = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sim(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.FunctionCfg function = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_function(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .planning.eudm.SafetyCfg safety = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_safety(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Config::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:planning.eudm.Config)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "planning.eudm.Config.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "planning.eudm.Config.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // required string status = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "planning.eudm.Config.status");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_status(), target);
  }

  // required .planning.eudm.CostAssessCfg cost = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::cost(this), target, stream);
  }

  // required .planning.eudm.SimCfg sim = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::sim(this), target, stream);
  }

  // required .planning.eudm.FunctionCfg function = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::function(this), target, stream);
  }

  // required .planning.eudm.SafetyCfg safety = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::safety(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:planning.eudm.Config)
  return target;
}

size_t Config::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:planning.eudm.Config)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_version()) {
    // required string version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  if (_internal_has_status()) {
    // required string status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  if (_internal_has_cost()) {
    // required .planning.eudm.CostAssessCfg cost = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cost_);
  }

  if (_internal_has_sim()) {
    // required .planning.eudm.SimCfg sim = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sim_);
  }

  if (_internal_has_function()) {
    // required .planning.eudm.FunctionCfg function = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *function_);
  }

  if (_internal_has_safety()) {
    // required .planning.eudm.SafetyCfg safety = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *safety_);
  }

  return total_size;
}
size_t Config::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:planning.eudm.Config)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());

    // required string status = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());

    // required .planning.eudm.CostAssessCfg cost = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cost_);

    // required .planning.eudm.SimCfg sim = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sim_);

    // required .planning.eudm.FunctionCfg function = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *function_);

    // required .planning.eudm.SafetyCfg safety = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *safety_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Config::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:planning.eudm.Config)
  GOOGLE_DCHECK_NE(&from, this);
  const Config* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Config>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:planning.eudm.Config)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:planning.eudm.Config)
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:planning.eudm.Config)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_cost()->::planning::eudm::CostAssessCfg::MergeFrom(from._internal_cost());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_sim()->::planning::eudm::SimCfg::MergeFrom(from._internal_sim());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_function()->::planning::eudm::FunctionCfg::MergeFrom(from._internal_function());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_safety()->::planning::eudm::SafetyCfg::MergeFrom(from._internal_safety());
    }
  }
}

void Config::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:planning.eudm.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:planning.eudm.Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_cost()) {
    if (!cost_->IsInitialized()) return false;
  }
  if (_internal_has_sim()) {
    if (!sim_->IsInitialized()) return false;
  }
  if (_internal_has_function()) {
    if (!function_->IsInitialized()) return false;
  }
  if (_internal_has_safety()) {
    if (!safety_->IsInitialized()) return false;
  }
  return true;
}

void Config::InternalSwap(Config* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  status_.Swap(&other->status_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Config, safety_)
      + sizeof(Config::safety_)
      - PROTOBUF_FIELD_OFFSET(Config, cost_)>(
          reinterpret_cast<char*>(&cost_),
          reinterpret_cast<char*>(&other->cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Config::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace eudm
}  // namespace planning
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::planning::eudm::EfficiencyAssessDetail* Arena::CreateMaybeMessage< ::planning::eudm::EfficiencyAssessDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::EfficiencyAssessDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::SafetyAssessDetail* Arena::CreateMaybeMessage< ::planning::eudm::SafetyAssessDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::SafetyAssessDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::UserIntentionAssessDetail* Arena::CreateMaybeMessage< ::planning::eudm::UserIntentionAssessDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::UserIntentionAssessDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::NavigationAssessDetail* Arena::CreateMaybeMessage< ::planning::eudm::NavigationAssessDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::NavigationAssessDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::CostAssessCfg* Arena::CreateMaybeMessage< ::planning::eudm::CostAssessCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::CostAssessCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::SimDurationDetail* Arena::CreateMaybeMessage< ::planning::eudm::SimDurationDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::SimDurationDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LonSimLimit* Arena::CreateMaybeMessage< ::planning::eudm::LonSimLimit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LonSimLimit >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LonSimIdm* Arena::CreateMaybeMessage< ::planning::eudm::LonSimIdm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LonSimIdm >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LonSimDetail* Arena::CreateMaybeMessage< ::planning::eudm::LonSimDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LonSimDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LatSimLimit* Arena::CreateMaybeMessage< ::planning::eudm::LatSimLimit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LatSimLimit >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LatSimPurePursuit* Arena::CreateMaybeMessage< ::planning::eudm::LatSimPurePursuit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LatSimPurePursuit >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::LatSimDetail* Arena::CreateMaybeMessage< ::planning::eudm::LatSimDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::LatSimDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::EvasiveSimDetail* Arena::CreateMaybeMessage< ::planning::eudm::EvasiveSimDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::EvasiveSimDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::ForwardSimDetail* Arena::CreateMaybeMessage< ::planning::eudm::ForwardSimDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::ForwardSimDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::SimRefLine* Arena::CreateMaybeMessage< ::planning::eudm::SimRefLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::SimRefLine >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::SimCfg* Arena::CreateMaybeMessage< ::planning::eudm::SimCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::SimCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::ActiveLaneChangeCfg* Arena::CreateMaybeMessage< ::planning::eudm::ActiveLaneChangeCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::ActiveLaneChangeCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::FunctionCfg* Arena::CreateMaybeMessage< ::planning::eudm::FunctionCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::FunctionCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::RssCfg* Arena::CreateMaybeMessage< ::planning::eudm::RssCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::RssCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::StrictCheckCfg* Arena::CreateMaybeMessage< ::planning::eudm::StrictCheckCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::StrictCheckCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::SafetyCfg* Arena::CreateMaybeMessage< ::planning::eudm::SafetyCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::SafetyCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::planning::eudm::Config* Arena::CreateMaybeMessage< ::planning::eudm::Config >(Arena* arena) {
  return Arena::CreateMessageInternal< ::planning::eudm::Config >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

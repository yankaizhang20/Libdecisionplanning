// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssc_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ssc_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ssc_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ssc_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ssc_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ssc_5fconfig_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_ssc_5fconfig_2eproto_metadata_getter(int index);
namespace planning {
namespace ssc {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class DynamicBounds;
struct DynamicBoundsDefaultTypeInternal;
extern DynamicBoundsDefaultTypeInternal _DynamicBounds_default_instance_;
class InflateSteps;
struct InflateStepsDefaultTypeInternal;
extern InflateStepsDefaultTypeInternal _InflateSteps_default_instance_;
class SscMapCfg;
struct SscMapCfgDefaultTypeInternal;
extern SscMapCfgDefaultTypeInternal _SscMapCfg_default_instance_;
class SscPlannerCfg;
struct SscPlannerCfgDefaultTypeInternal;
extern SscPlannerCfgDefaultTypeInternal _SscPlannerCfg_default_instance_;
}  // namespace ssc
}  // namespace planning
PROTOBUF_NAMESPACE_OPEN
template<> ::planning::ssc::Config* Arena::CreateMaybeMessage<::planning::ssc::Config>(Arena*);
template<> ::planning::ssc::DynamicBounds* Arena::CreateMaybeMessage<::planning::ssc::DynamicBounds>(Arena*);
template<> ::planning::ssc::InflateSteps* Arena::CreateMaybeMessage<::planning::ssc::InflateSteps>(Arena*);
template<> ::planning::ssc::SscMapCfg* Arena::CreateMaybeMessage<::planning::ssc::SscMapCfg>(Arena*);
template<> ::planning::ssc::SscPlannerCfg* Arena::CreateMaybeMessage<::planning::ssc::SscPlannerCfg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace planning {
namespace ssc {

// ===================================================================

class SscPlannerCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.ssc.SscPlannerCfg) */ {
 public:
  inline SscPlannerCfg() : SscPlannerCfg(nullptr) {}
  virtual ~SscPlannerCfg();
  explicit constexpr SscPlannerCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SscPlannerCfg(const SscPlannerCfg& from);
  SscPlannerCfg(SscPlannerCfg&& from) noexcept
    : SscPlannerCfg() {
    *this = ::std::move(from);
  }

  inline SscPlannerCfg& operator=(const SscPlannerCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SscPlannerCfg& operator=(SscPlannerCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SscPlannerCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SscPlannerCfg* internal_default_instance() {
    return reinterpret_cast<const SscPlannerCfg*>(
               &_SscPlannerCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SscPlannerCfg& a, SscPlannerCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(SscPlannerCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SscPlannerCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SscPlannerCfg* New() const final {
    return CreateMaybeMessage<SscPlannerCfg>(nullptr);
  }

  SscPlannerCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SscPlannerCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SscPlannerCfg& from);
  void MergeFrom(const SscPlannerCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SscPlannerCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.ssc.SscPlannerCfg";
  }
  protected:
  explicit SscPlannerCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_ssc_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelocitySingularityEpsFieldNumber = 1,
    kLowSpeedThresholdFieldNumber = 2,
    kWeightProximityFieldNumber = 3,
    kIsFittingOnlyFieldNumber = 4,
  };
  // required double velocity_singularity_eps = 1;
  bool has_velocity_singularity_eps() const;
  private:
  bool _internal_has_velocity_singularity_eps() const;
  public:
  void clear_velocity_singularity_eps();
  double velocity_singularity_eps() const;
  void set_velocity_singularity_eps(double value);
  private:
  double _internal_velocity_singularity_eps() const;
  void _internal_set_velocity_singularity_eps(double value);
  public:

  // required double low_speed_threshold = 2;
  bool has_low_speed_threshold() const;
  private:
  bool _internal_has_low_speed_threshold() const;
  public:
  void clear_low_speed_threshold();
  double low_speed_threshold() const;
  void set_low_speed_threshold(double value);
  private:
  double _internal_low_speed_threshold() const;
  void _internal_set_low_speed_threshold(double value);
  public:

  // required double weight_proximity = 3;
  bool has_weight_proximity() const;
  private:
  bool _internal_has_weight_proximity() const;
  public:
  void clear_weight_proximity();
  double weight_proximity() const;
  void set_weight_proximity(double value);
  private:
  double _internal_weight_proximity() const;
  void _internal_set_weight_proximity(double value);
  public:

  // required bool is_fitting_only = 4;
  bool has_is_fitting_only() const;
  private:
  bool _internal_has_is_fitting_only() const;
  public:
  void clear_is_fitting_only();
  bool is_fitting_only() const;
  void set_is_fitting_only(bool value);
  private:
  bool _internal_is_fitting_only() const;
  void _internal_set_is_fitting_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:planning.ssc.SscPlannerCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double velocity_singularity_eps_;
  double low_speed_threshold_;
  double weight_proximity_;
  bool is_fitting_only_;
  friend struct ::TableStruct_ssc_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class InflateSteps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.ssc.InflateSteps) */ {
 public:
  inline InflateSteps() : InflateSteps(nullptr) {}
  virtual ~InflateSteps();
  explicit constexpr InflateSteps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InflateSteps(const InflateSteps& from);
  InflateSteps(InflateSteps&& from) noexcept
    : InflateSteps() {
    *this = ::std::move(from);
  }

  inline InflateSteps& operator=(const InflateSteps& from) {
    CopyFrom(from);
    return *this;
  }
  inline InflateSteps& operator=(InflateSteps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InflateSteps& default_instance() {
    return *internal_default_instance();
  }
  static inline const InflateSteps* internal_default_instance() {
    return reinterpret_cast<const InflateSteps*>(
               &_InflateSteps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InflateSteps& a, InflateSteps& b) {
    a.Swap(&b);
  }
  inline void Swap(InflateSteps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InflateSteps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InflateSteps* New() const final {
    return CreateMaybeMessage<InflateSteps>(nullptr);
  }

  InflateSteps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InflateSteps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InflateSteps& from);
  void MergeFrom(const InflateSteps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InflateSteps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.ssc.InflateSteps";
  }
  protected:
  explicit InflateSteps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_ssc_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXPFieldNumber = 1,
    kXNFieldNumber = 2,
    kYPFieldNumber = 3,
    kYNFieldNumber = 4,
    kZPFieldNumber = 5,
    kZNFieldNumber = 6,
  };
  // required int32 x_p = 1;
  bool has_x_p() const;
  private:
  bool _internal_has_x_p() const;
  public:
  void clear_x_p();
  ::PROTOBUF_NAMESPACE_ID::int32 x_p() const;
  void set_x_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x_p() const;
  void _internal_set_x_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 x_n = 2;
  bool has_x_n() const;
  private:
  bool _internal_has_x_n() const;
  public:
  void clear_x_n();
  ::PROTOBUF_NAMESPACE_ID::int32 x_n() const;
  void set_x_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x_n() const;
  void _internal_set_x_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 y_p = 3;
  bool has_y_p() const;
  private:
  bool _internal_has_y_p() const;
  public:
  void clear_y_p();
  ::PROTOBUF_NAMESPACE_ID::int32 y_p() const;
  void set_y_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y_p() const;
  void _internal_set_y_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 y_n = 4;
  bool has_y_n() const;
  private:
  bool _internal_has_y_n() const;
  public:
  void clear_y_n();
  ::PROTOBUF_NAMESPACE_ID::int32 y_n() const;
  void set_y_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y_n() const;
  void _internal_set_y_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 z_p = 5;
  bool has_z_p() const;
  private:
  bool _internal_has_z_p() const;
  public:
  void clear_z_p();
  ::PROTOBUF_NAMESPACE_ID::int32 z_p() const;
  void set_z_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_z_p() const;
  void _internal_set_z_p(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 z_n = 6;
  bool has_z_n() const;
  private:
  bool _internal_has_z_n() const;
  public:
  void clear_z_n();
  ::PROTOBUF_NAMESPACE_ID::int32 z_n() const;
  void set_z_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_z_n() const;
  void _internal_set_z_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:planning.ssc.InflateSteps)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_p_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_n_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_p_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_n_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_p_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_n_;
  friend struct ::TableStruct_ssc_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DynamicBounds PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.ssc.DynamicBounds) */ {
 public:
  inline DynamicBounds() : DynamicBounds(nullptr) {}
  virtual ~DynamicBounds();
  explicit constexpr DynamicBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicBounds(const DynamicBounds& from);
  DynamicBounds(DynamicBounds&& from) noexcept
    : DynamicBounds() {
    *this = ::std::move(from);
  }

  inline DynamicBounds& operator=(const DynamicBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicBounds& operator=(DynamicBounds&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DynamicBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicBounds* internal_default_instance() {
    return reinterpret_cast<const DynamicBounds*>(
               &_DynamicBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DynamicBounds& a, DynamicBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicBounds* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicBounds* New() const final {
    return CreateMaybeMessage<DynamicBounds>(nullptr);
  }

  DynamicBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicBounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DynamicBounds& from);
  void MergeFrom(const DynamicBounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicBounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.ssc.DynamicBounds";
  }
  protected:
  explicit DynamicBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_ssc_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxLonVelFieldNumber = 1,
    kMinLonVelFieldNumber = 2,
    kMaxLonAccFieldNumber = 3,
    kMaxLonDecFieldNumber = 4,
    kMaxLatVelFieldNumber = 5,
    kMaxLatAccFieldNumber = 6,
  };
  // required double max_lon_vel = 1;
  bool has_max_lon_vel() const;
  private:
  bool _internal_has_max_lon_vel() const;
  public:
  void clear_max_lon_vel();
  double max_lon_vel() const;
  void set_max_lon_vel(double value);
  private:
  double _internal_max_lon_vel() const;
  void _internal_set_max_lon_vel(double value);
  public:

  // required double min_lon_vel = 2;
  bool has_min_lon_vel() const;
  private:
  bool _internal_has_min_lon_vel() const;
  public:
  void clear_min_lon_vel();
  double min_lon_vel() const;
  void set_min_lon_vel(double value);
  private:
  double _internal_min_lon_vel() const;
  void _internal_set_min_lon_vel(double value);
  public:

  // required double max_lon_acc = 3;
  bool has_max_lon_acc() const;
  private:
  bool _internal_has_max_lon_acc() const;
  public:
  void clear_max_lon_acc();
  double max_lon_acc() const;
  void set_max_lon_acc(double value);
  private:
  double _internal_max_lon_acc() const;
  void _internal_set_max_lon_acc(double value);
  public:

  // required double max_lon_dec = 4;
  bool has_max_lon_dec() const;
  private:
  bool _internal_has_max_lon_dec() const;
  public:
  void clear_max_lon_dec();
  double max_lon_dec() const;
  void set_max_lon_dec(double value);
  private:
  double _internal_max_lon_dec() const;
  void _internal_set_max_lon_dec(double value);
  public:

  // required double max_lat_vel = 5;
  bool has_max_lat_vel() const;
  private:
  bool _internal_has_max_lat_vel() const;
  public:
  void clear_max_lat_vel();
  double max_lat_vel() const;
  void set_max_lat_vel(double value);
  private:
  double _internal_max_lat_vel() const;
  void _internal_set_max_lat_vel(double value);
  public:

  // required double max_lat_acc = 6;
  bool has_max_lat_acc() const;
  private:
  bool _internal_has_max_lat_acc() const;
  public:
  void clear_max_lat_acc();
  double max_lat_acc() const;
  void set_max_lat_acc(double value);
  private:
  double _internal_max_lat_acc() const;
  void _internal_set_max_lat_acc(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.ssc.DynamicBounds)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double max_lon_vel_;
  double min_lon_vel_;
  double max_lon_acc_;
  double max_lon_dec_;
  double max_lat_vel_;
  double max_lat_acc_;
  friend struct ::TableStruct_ssc_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class SscMapCfg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.ssc.SscMapCfg) */ {
 public:
  inline SscMapCfg() : SscMapCfg(nullptr) {}
  virtual ~SscMapCfg();
  explicit constexpr SscMapCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SscMapCfg(const SscMapCfg& from);
  SscMapCfg(SscMapCfg&& from) noexcept
    : SscMapCfg() {
    *this = ::std::move(from);
  }

  inline SscMapCfg& operator=(const SscMapCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SscMapCfg& operator=(SscMapCfg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SscMapCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SscMapCfg* internal_default_instance() {
    return reinterpret_cast<const SscMapCfg*>(
               &_SscMapCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SscMapCfg& a, SscMapCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(SscMapCfg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SscMapCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SscMapCfg* New() const final {
    return CreateMaybeMessage<SscMapCfg>(nullptr);
  }

  SscMapCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SscMapCfg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SscMapCfg& from);
  void MergeFrom(const SscMapCfg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SscMapCfg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.ssc.SscMapCfg";
  }
  protected:
  explicit SscMapCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_ssc_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDynBoundsFieldNumber = 8,
    kInflStepsFieldNumber = 10,
    kMapSizeXFieldNumber = 1,
    kMapSizeYFieldNumber = 2,
    kMapReslXFieldNumber = 4,
    kMapReslYFieldNumber = 5,
    kMapReslZFieldNumber = 6,
    kMapSizeZFieldNumber = 3,
    kMaxGridsAlongTimeFieldNumber = 9,
    kSBackLenFieldNumber = 7,
  };
  // required .planning.ssc.DynamicBounds dyn_bounds = 8;
  bool has_dyn_bounds() const;
  private:
  bool _internal_has_dyn_bounds() const;
  public:
  void clear_dyn_bounds();
  const ::planning::ssc::DynamicBounds& dyn_bounds() const;
  ::planning::ssc::DynamicBounds* release_dyn_bounds();
  ::planning::ssc::DynamicBounds* mutable_dyn_bounds();
  void set_allocated_dyn_bounds(::planning::ssc::DynamicBounds* dyn_bounds);
  private:
  const ::planning::ssc::DynamicBounds& _internal_dyn_bounds() const;
  ::planning::ssc::DynamicBounds* _internal_mutable_dyn_bounds();
  public:
  void unsafe_arena_set_allocated_dyn_bounds(
      ::planning::ssc::DynamicBounds* dyn_bounds);
  ::planning::ssc::DynamicBounds* unsafe_arena_release_dyn_bounds();

  // required .planning.ssc.InflateSteps infl_steps = 10;
  bool has_infl_steps() const;
  private:
  bool _internal_has_infl_steps() const;
  public:
  void clear_infl_steps();
  const ::planning::ssc::InflateSteps& infl_steps() const;
  ::planning::ssc::InflateSteps* release_infl_steps();
  ::planning::ssc::InflateSteps* mutable_infl_steps();
  void set_allocated_infl_steps(::planning::ssc::InflateSteps* infl_steps);
  private:
  const ::planning::ssc::InflateSteps& _internal_infl_steps() const;
  ::planning::ssc::InflateSteps* _internal_mutable_infl_steps();
  public:
  void unsafe_arena_set_allocated_infl_steps(
      ::planning::ssc::InflateSteps* infl_steps);
  ::planning::ssc::InflateSteps* unsafe_arena_release_infl_steps();

  // required int32 map_size_x = 1;
  bool has_map_size_x() const;
  private:
  bool _internal_has_map_size_x() const;
  public:
  void clear_map_size_x();
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_x() const;
  void set_map_size_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_map_size_x() const;
  void _internal_set_map_size_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 map_size_y = 2;
  bool has_map_size_y() const;
  private:
  bool _internal_has_map_size_y() const;
  public:
  void clear_map_size_y();
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_y() const;
  void set_map_size_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_map_size_y() const;
  void _internal_set_map_size_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required double map_resl_x = 4;
  bool has_map_resl_x() const;
  private:
  bool _internal_has_map_resl_x() const;
  public:
  void clear_map_resl_x();
  double map_resl_x() const;
  void set_map_resl_x(double value);
  private:
  double _internal_map_resl_x() const;
  void _internal_set_map_resl_x(double value);
  public:

  // required double map_resl_y = 5;
  bool has_map_resl_y() const;
  private:
  bool _internal_has_map_resl_y() const;
  public:
  void clear_map_resl_y();
  double map_resl_y() const;
  void set_map_resl_y(double value);
  private:
  double _internal_map_resl_y() const;
  void _internal_set_map_resl_y(double value);
  public:

  // required double map_resl_z = 6;
  bool has_map_resl_z() const;
  private:
  bool _internal_has_map_resl_z() const;
  public:
  void clear_map_resl_z();
  double map_resl_z() const;
  void set_map_resl_z(double value);
  private:
  double _internal_map_resl_z() const;
  void _internal_set_map_resl_z(double value);
  public:

  // required int32 map_size_z = 3;
  bool has_map_size_z() const;
  private:
  bool _internal_has_map_size_z() const;
  public:
  void clear_map_size_z();
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_z() const;
  void set_map_size_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_map_size_z() const;
  void _internal_set_map_size_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 max_grids_along_time = 9;
  bool has_max_grids_along_time() const;
  private:
  bool _internal_has_max_grids_along_time() const;
  public:
  void clear_max_grids_along_time();
  ::PROTOBUF_NAMESPACE_ID::int32 max_grids_along_time() const;
  void set_max_grids_along_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_grids_along_time() const;
  void _internal_set_max_grids_along_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required double s_back_len = 7;
  bool has_s_back_len() const;
  private:
  bool _internal_has_s_back_len() const;
  public:
  void clear_s_back_len();
  double s_back_len() const;
  void set_s_back_len(double value);
  private:
  double _internal_s_back_len() const;
  void _internal_set_s_back_len(double value);
  public:

  // @@protoc_insertion_point(class_scope:planning.ssc.SscMapCfg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::planning::ssc::DynamicBounds* dyn_bounds_;
  ::planning::ssc::InflateSteps* infl_steps_;
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_x_;
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_y_;
  double map_resl_x_;
  double map_resl_y_;
  double map_resl_z_;
  ::PROTOBUF_NAMESPACE_ID::int32 map_size_z_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_grids_along_time_;
  double s_back_len_;
  friend struct ::TableStruct_ssc_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:planning.ssc.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  virtual ~Config();
  explicit constexpr Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "planning.ssc.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_ssc_5fconfig_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kStatusFieldNumber = 3,
    kPlannerCfgFieldNumber = 4,
    kMapCfgFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required string status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // required .planning.ssc.SscPlannerCfg planner_cfg = 4;
  bool has_planner_cfg() const;
  private:
  bool _internal_has_planner_cfg() const;
  public:
  void clear_planner_cfg();
  const ::planning::ssc::SscPlannerCfg& planner_cfg() const;
  ::planning::ssc::SscPlannerCfg* release_planner_cfg();
  ::planning::ssc::SscPlannerCfg* mutable_planner_cfg();
  void set_allocated_planner_cfg(::planning::ssc::SscPlannerCfg* planner_cfg);
  private:
  const ::planning::ssc::SscPlannerCfg& _internal_planner_cfg() const;
  ::planning::ssc::SscPlannerCfg* _internal_mutable_planner_cfg();
  public:
  void unsafe_arena_set_allocated_planner_cfg(
      ::planning::ssc::SscPlannerCfg* planner_cfg);
  ::planning::ssc::SscPlannerCfg* unsafe_arena_release_planner_cfg();

  // required .planning.ssc.SscMapCfg map_cfg = 5;
  bool has_map_cfg() const;
  private:
  bool _internal_has_map_cfg() const;
  public:
  void clear_map_cfg();
  const ::planning::ssc::SscMapCfg& map_cfg() const;
  ::planning::ssc::SscMapCfg* release_map_cfg();
  ::planning::ssc::SscMapCfg* mutable_map_cfg();
  void set_allocated_map_cfg(::planning::ssc::SscMapCfg* map_cfg);
  private:
  const ::planning::ssc::SscMapCfg& _internal_map_cfg() const;
  ::planning::ssc::SscMapCfg* _internal_mutable_map_cfg();
  public:
  void unsafe_arena_set_allocated_map_cfg(
      ::planning::ssc::SscMapCfg* map_cfg);
  ::planning::ssc::SscMapCfg* unsafe_arena_release_map_cfg();

  // @@protoc_insertion_point(class_scope:planning.ssc.Config)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::planning::ssc::SscPlannerCfg* planner_cfg_;
  ::planning::ssc::SscMapCfg* map_cfg_;
  friend struct ::TableStruct_ssc_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SscPlannerCfg

// required double velocity_singularity_eps = 1;
inline bool SscPlannerCfg::_internal_has_velocity_singularity_eps() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SscPlannerCfg::has_velocity_singularity_eps() const {
  return _internal_has_velocity_singularity_eps();
}
inline void SscPlannerCfg::clear_velocity_singularity_eps() {
  velocity_singularity_eps_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SscPlannerCfg::_internal_velocity_singularity_eps() const {
  return velocity_singularity_eps_;
}
inline double SscPlannerCfg::velocity_singularity_eps() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscPlannerCfg.velocity_singularity_eps)
  return _internal_velocity_singularity_eps();
}
inline void SscPlannerCfg::_internal_set_velocity_singularity_eps(double value) {
  _has_bits_[0] |= 0x00000001u;
  velocity_singularity_eps_ = value;
}
inline void SscPlannerCfg::set_velocity_singularity_eps(double value) {
  _internal_set_velocity_singularity_eps(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscPlannerCfg.velocity_singularity_eps)
}

// required double low_speed_threshold = 2;
inline bool SscPlannerCfg::_internal_has_low_speed_threshold() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SscPlannerCfg::has_low_speed_threshold() const {
  return _internal_has_low_speed_threshold();
}
inline void SscPlannerCfg::clear_low_speed_threshold() {
  low_speed_threshold_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SscPlannerCfg::_internal_low_speed_threshold() const {
  return low_speed_threshold_;
}
inline double SscPlannerCfg::low_speed_threshold() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscPlannerCfg.low_speed_threshold)
  return _internal_low_speed_threshold();
}
inline void SscPlannerCfg::_internal_set_low_speed_threshold(double value) {
  _has_bits_[0] |= 0x00000002u;
  low_speed_threshold_ = value;
}
inline void SscPlannerCfg::set_low_speed_threshold(double value) {
  _internal_set_low_speed_threshold(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscPlannerCfg.low_speed_threshold)
}

// required double weight_proximity = 3;
inline bool SscPlannerCfg::_internal_has_weight_proximity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SscPlannerCfg::has_weight_proximity() const {
  return _internal_has_weight_proximity();
}
inline void SscPlannerCfg::clear_weight_proximity() {
  weight_proximity_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SscPlannerCfg::_internal_weight_proximity() const {
  return weight_proximity_;
}
inline double SscPlannerCfg::weight_proximity() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscPlannerCfg.weight_proximity)
  return _internal_weight_proximity();
}
inline void SscPlannerCfg::_internal_set_weight_proximity(double value) {
  _has_bits_[0] |= 0x00000004u;
  weight_proximity_ = value;
}
inline void SscPlannerCfg::set_weight_proximity(double value) {
  _internal_set_weight_proximity(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscPlannerCfg.weight_proximity)
}

// required bool is_fitting_only = 4;
inline bool SscPlannerCfg::_internal_has_is_fitting_only() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SscPlannerCfg::has_is_fitting_only() const {
  return _internal_has_is_fitting_only();
}
inline void SscPlannerCfg::clear_is_fitting_only() {
  is_fitting_only_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SscPlannerCfg::_internal_is_fitting_only() const {
  return is_fitting_only_;
}
inline bool SscPlannerCfg::is_fitting_only() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscPlannerCfg.is_fitting_only)
  return _internal_is_fitting_only();
}
inline void SscPlannerCfg::_internal_set_is_fitting_only(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_fitting_only_ = value;
}
inline void SscPlannerCfg::set_is_fitting_only(bool value) {
  _internal_set_is_fitting_only(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscPlannerCfg.is_fitting_only)
}

// -------------------------------------------------------------------

// InflateSteps

// required int32 x_p = 1;
inline bool InflateSteps::_internal_has_x_p() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InflateSteps::has_x_p() const {
  return _internal_has_x_p();
}
inline void InflateSteps::clear_x_p() {
  x_p_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_x_p() const {
  return x_p_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::x_p() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.x_p)
  return _internal_x_p();
}
inline void InflateSteps::_internal_set_x_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_p_ = value;
}
inline void InflateSteps::set_x_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x_p(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.x_p)
}

// required int32 x_n = 2;
inline bool InflateSteps::_internal_has_x_n() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InflateSteps::has_x_n() const {
  return _internal_has_x_n();
}
inline void InflateSteps::clear_x_n() {
  x_n_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_x_n() const {
  return x_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::x_n() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.x_n)
  return _internal_x_n();
}
inline void InflateSteps::_internal_set_x_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  x_n_ = value;
}
inline void InflateSteps::set_x_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x_n(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.x_n)
}

// required int32 y_p = 3;
inline bool InflateSteps::_internal_has_y_p() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InflateSteps::has_y_p() const {
  return _internal_has_y_p();
}
inline void InflateSteps::clear_y_p() {
  y_p_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_y_p() const {
  return y_p_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::y_p() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.y_p)
  return _internal_y_p();
}
inline void InflateSteps::_internal_set_y_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  y_p_ = value;
}
inline void InflateSteps::set_y_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y_p(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.y_p)
}

// required int32 y_n = 4;
inline bool InflateSteps::_internal_has_y_n() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InflateSteps::has_y_n() const {
  return _internal_has_y_n();
}
inline void InflateSteps::clear_y_n() {
  y_n_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_y_n() const {
  return y_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::y_n() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.y_n)
  return _internal_y_n();
}
inline void InflateSteps::_internal_set_y_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  y_n_ = value;
}
inline void InflateSteps::set_y_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y_n(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.y_n)
}

// required int32 z_p = 5;
inline bool InflateSteps::_internal_has_z_p() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InflateSteps::has_z_p() const {
  return _internal_has_z_p();
}
inline void InflateSteps::clear_z_p() {
  z_p_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_z_p() const {
  return z_p_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::z_p() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.z_p)
  return _internal_z_p();
}
inline void InflateSteps::_internal_set_z_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  z_p_ = value;
}
inline void InflateSteps::set_z_p(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_z_p(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.z_p)
}

// required int32 z_n = 6;
inline bool InflateSteps::_internal_has_z_n() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InflateSteps::has_z_n() const {
  return _internal_has_z_n();
}
inline void InflateSteps::clear_z_n() {
  z_n_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::_internal_z_n() const {
  return z_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InflateSteps::z_n() const {
  // @@protoc_insertion_point(field_get:planning.ssc.InflateSteps.z_n)
  return _internal_z_n();
}
inline void InflateSteps::_internal_set_z_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  z_n_ = value;
}
inline void InflateSteps::set_z_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_z_n(value);
  // @@protoc_insertion_point(field_set:planning.ssc.InflateSteps.z_n)
}

// -------------------------------------------------------------------

// DynamicBounds

// required double max_lon_vel = 1;
inline bool DynamicBounds::_internal_has_max_lon_vel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DynamicBounds::has_max_lon_vel() const {
  return _internal_has_max_lon_vel();
}
inline void DynamicBounds::clear_max_lon_vel() {
  max_lon_vel_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DynamicBounds::_internal_max_lon_vel() const {
  return max_lon_vel_;
}
inline double DynamicBounds::max_lon_vel() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.max_lon_vel)
  return _internal_max_lon_vel();
}
inline void DynamicBounds::_internal_set_max_lon_vel(double value) {
  _has_bits_[0] |= 0x00000001u;
  max_lon_vel_ = value;
}
inline void DynamicBounds::set_max_lon_vel(double value) {
  _internal_set_max_lon_vel(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.max_lon_vel)
}

// required double min_lon_vel = 2;
inline bool DynamicBounds::_internal_has_min_lon_vel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DynamicBounds::has_min_lon_vel() const {
  return _internal_has_min_lon_vel();
}
inline void DynamicBounds::clear_min_lon_vel() {
  min_lon_vel_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double DynamicBounds::_internal_min_lon_vel() const {
  return min_lon_vel_;
}
inline double DynamicBounds::min_lon_vel() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.min_lon_vel)
  return _internal_min_lon_vel();
}
inline void DynamicBounds::_internal_set_min_lon_vel(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_lon_vel_ = value;
}
inline void DynamicBounds::set_min_lon_vel(double value) {
  _internal_set_min_lon_vel(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.min_lon_vel)
}

// required double max_lon_acc = 3;
inline bool DynamicBounds::_internal_has_max_lon_acc() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DynamicBounds::has_max_lon_acc() const {
  return _internal_has_max_lon_acc();
}
inline void DynamicBounds::clear_max_lon_acc() {
  max_lon_acc_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double DynamicBounds::_internal_max_lon_acc() const {
  return max_lon_acc_;
}
inline double DynamicBounds::max_lon_acc() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.max_lon_acc)
  return _internal_max_lon_acc();
}
inline void DynamicBounds::_internal_set_max_lon_acc(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_lon_acc_ = value;
}
inline void DynamicBounds::set_max_lon_acc(double value) {
  _internal_set_max_lon_acc(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.max_lon_acc)
}

// required double max_lon_dec = 4;
inline bool DynamicBounds::_internal_has_max_lon_dec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DynamicBounds::has_max_lon_dec() const {
  return _internal_has_max_lon_dec();
}
inline void DynamicBounds::clear_max_lon_dec() {
  max_lon_dec_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double DynamicBounds::_internal_max_lon_dec() const {
  return max_lon_dec_;
}
inline double DynamicBounds::max_lon_dec() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.max_lon_dec)
  return _internal_max_lon_dec();
}
inline void DynamicBounds::_internal_set_max_lon_dec(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_lon_dec_ = value;
}
inline void DynamicBounds::set_max_lon_dec(double value) {
  _internal_set_max_lon_dec(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.max_lon_dec)
}

// required double max_lat_vel = 5;
inline bool DynamicBounds::_internal_has_max_lat_vel() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DynamicBounds::has_max_lat_vel() const {
  return _internal_has_max_lat_vel();
}
inline void DynamicBounds::clear_max_lat_vel() {
  max_lat_vel_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double DynamicBounds::_internal_max_lat_vel() const {
  return max_lat_vel_;
}
inline double DynamicBounds::max_lat_vel() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.max_lat_vel)
  return _internal_max_lat_vel();
}
inline void DynamicBounds::_internal_set_max_lat_vel(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_lat_vel_ = value;
}
inline void DynamicBounds::set_max_lat_vel(double value) {
  _internal_set_max_lat_vel(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.max_lat_vel)
}

// required double max_lat_acc = 6;
inline bool DynamicBounds::_internal_has_max_lat_acc() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DynamicBounds::has_max_lat_acc() const {
  return _internal_has_max_lat_acc();
}
inline void DynamicBounds::clear_max_lat_acc() {
  max_lat_acc_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double DynamicBounds::_internal_max_lat_acc() const {
  return max_lat_acc_;
}
inline double DynamicBounds::max_lat_acc() const {
  // @@protoc_insertion_point(field_get:planning.ssc.DynamicBounds.max_lat_acc)
  return _internal_max_lat_acc();
}
inline void DynamicBounds::_internal_set_max_lat_acc(double value) {
  _has_bits_[0] |= 0x00000020u;
  max_lat_acc_ = value;
}
inline void DynamicBounds::set_max_lat_acc(double value) {
  _internal_set_max_lat_acc(value);
  // @@protoc_insertion_point(field_set:planning.ssc.DynamicBounds.max_lat_acc)
}

// -------------------------------------------------------------------

// SscMapCfg

// required int32 map_size_x = 1;
inline bool SscMapCfg::_internal_has_map_size_x() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_size_x() const {
  return _internal_has_map_size_x();
}
inline void SscMapCfg::clear_map_size_x() {
  map_size_x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::_internal_map_size_x() const {
  return map_size_x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::map_size_x() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_size_x)
  return _internal_map_size_x();
}
inline void SscMapCfg::_internal_set_map_size_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  map_size_x_ = value;
}
inline void SscMapCfg::set_map_size_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_map_size_x(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_size_x)
}

// required int32 map_size_y = 2;
inline bool SscMapCfg::_internal_has_map_size_y() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_size_y() const {
  return _internal_has_map_size_y();
}
inline void SscMapCfg::clear_map_size_y() {
  map_size_y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::_internal_map_size_y() const {
  return map_size_y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::map_size_y() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_size_y)
  return _internal_map_size_y();
}
inline void SscMapCfg::_internal_set_map_size_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  map_size_y_ = value;
}
inline void SscMapCfg::set_map_size_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_map_size_y(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_size_y)
}

// required int32 map_size_z = 3;
inline bool SscMapCfg::_internal_has_map_size_z() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_size_z() const {
  return _internal_has_map_size_z();
}
inline void SscMapCfg::clear_map_size_z() {
  map_size_z_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::_internal_map_size_z() const {
  return map_size_z_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::map_size_z() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_size_z)
  return _internal_map_size_z();
}
inline void SscMapCfg::_internal_set_map_size_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  map_size_z_ = value;
}
inline void SscMapCfg::set_map_size_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_map_size_z(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_size_z)
}

// required double map_resl_x = 4;
inline bool SscMapCfg::_internal_has_map_resl_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_resl_x() const {
  return _internal_has_map_resl_x();
}
inline void SscMapCfg::clear_map_resl_x() {
  map_resl_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SscMapCfg::_internal_map_resl_x() const {
  return map_resl_x_;
}
inline double SscMapCfg::map_resl_x() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_resl_x)
  return _internal_map_resl_x();
}
inline void SscMapCfg::_internal_set_map_resl_x(double value) {
  _has_bits_[0] |= 0x00000010u;
  map_resl_x_ = value;
}
inline void SscMapCfg::set_map_resl_x(double value) {
  _internal_set_map_resl_x(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_resl_x)
}

// required double map_resl_y = 5;
inline bool SscMapCfg::_internal_has_map_resl_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_resl_y() const {
  return _internal_has_map_resl_y();
}
inline void SscMapCfg::clear_map_resl_y() {
  map_resl_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double SscMapCfg::_internal_map_resl_y() const {
  return map_resl_y_;
}
inline double SscMapCfg::map_resl_y() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_resl_y)
  return _internal_map_resl_y();
}
inline void SscMapCfg::_internal_set_map_resl_y(double value) {
  _has_bits_[0] |= 0x00000020u;
  map_resl_y_ = value;
}
inline void SscMapCfg::set_map_resl_y(double value) {
  _internal_set_map_resl_y(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_resl_y)
}

// required double map_resl_z = 6;
inline bool SscMapCfg::_internal_has_map_resl_z() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SscMapCfg::has_map_resl_z() const {
  return _internal_has_map_resl_z();
}
inline void SscMapCfg::clear_map_resl_z() {
  map_resl_z_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double SscMapCfg::_internal_map_resl_z() const {
  return map_resl_z_;
}
inline double SscMapCfg::map_resl_z() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.map_resl_z)
  return _internal_map_resl_z();
}
inline void SscMapCfg::_internal_set_map_resl_z(double value) {
  _has_bits_[0] |= 0x00000040u;
  map_resl_z_ = value;
}
inline void SscMapCfg::set_map_resl_z(double value) {
  _internal_set_map_resl_z(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.map_resl_z)
}

// required double s_back_len = 7;
inline bool SscMapCfg::_internal_has_s_back_len() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SscMapCfg::has_s_back_len() const {
  return _internal_has_s_back_len();
}
inline void SscMapCfg::clear_s_back_len() {
  s_back_len_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline double SscMapCfg::_internal_s_back_len() const {
  return s_back_len_;
}
inline double SscMapCfg::s_back_len() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.s_back_len)
  return _internal_s_back_len();
}
inline void SscMapCfg::_internal_set_s_back_len(double value) {
  _has_bits_[0] |= 0x00000200u;
  s_back_len_ = value;
}
inline void SscMapCfg::set_s_back_len(double value) {
  _internal_set_s_back_len(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.s_back_len)
}

// required .planning.ssc.DynamicBounds dyn_bounds = 8;
inline bool SscMapCfg::_internal_has_dyn_bounds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || dyn_bounds_ != nullptr);
  return value;
}
inline bool SscMapCfg::has_dyn_bounds() const {
  return _internal_has_dyn_bounds();
}
inline void SscMapCfg::clear_dyn_bounds() {
  if (dyn_bounds_ != nullptr) dyn_bounds_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::planning::ssc::DynamicBounds& SscMapCfg::_internal_dyn_bounds() const {
  const ::planning::ssc::DynamicBounds* p = dyn_bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::ssc::DynamicBounds&>(
      ::planning::ssc::_DynamicBounds_default_instance_);
}
inline const ::planning::ssc::DynamicBounds& SscMapCfg::dyn_bounds() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.dyn_bounds)
  return _internal_dyn_bounds();
}
inline void SscMapCfg::unsafe_arena_set_allocated_dyn_bounds(
    ::planning::ssc::DynamicBounds* dyn_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dyn_bounds_);
  }
  dyn_bounds_ = dyn_bounds;
  if (dyn_bounds) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.ssc.SscMapCfg.dyn_bounds)
}
inline ::planning::ssc::DynamicBounds* SscMapCfg::release_dyn_bounds() {
  _has_bits_[0] &= ~0x00000001u;
  ::planning::ssc::DynamicBounds* temp = dyn_bounds_;
  dyn_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::ssc::DynamicBounds* SscMapCfg::unsafe_arena_release_dyn_bounds() {
  // @@protoc_insertion_point(field_release:planning.ssc.SscMapCfg.dyn_bounds)
  _has_bits_[0] &= ~0x00000001u;
  ::planning::ssc::DynamicBounds* temp = dyn_bounds_;
  dyn_bounds_ = nullptr;
  return temp;
}
inline ::planning::ssc::DynamicBounds* SscMapCfg::_internal_mutable_dyn_bounds() {
  _has_bits_[0] |= 0x00000001u;
  if (dyn_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::ssc::DynamicBounds>(GetArena());
    dyn_bounds_ = p;
  }
  return dyn_bounds_;
}
inline ::planning::ssc::DynamicBounds* SscMapCfg::mutable_dyn_bounds() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.SscMapCfg.dyn_bounds)
  return _internal_mutable_dyn_bounds();
}
inline void SscMapCfg::set_allocated_dyn_bounds(::planning::ssc::DynamicBounds* dyn_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dyn_bounds_;
  }
  if (dyn_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dyn_bounds);
    if (message_arena != submessage_arena) {
      dyn_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dyn_bounds, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dyn_bounds_ = dyn_bounds;
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.SscMapCfg.dyn_bounds)
}

// required int32 max_grids_along_time = 9;
inline bool SscMapCfg::_internal_has_max_grids_along_time() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SscMapCfg::has_max_grids_along_time() const {
  return _internal_has_max_grids_along_time();
}
inline void SscMapCfg::clear_max_grids_along_time() {
  max_grids_along_time_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::_internal_max_grids_along_time() const {
  return max_grids_along_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SscMapCfg::max_grids_along_time() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.max_grids_along_time)
  return _internal_max_grids_along_time();
}
inline void SscMapCfg::_internal_set_max_grids_along_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  max_grids_along_time_ = value;
}
inline void SscMapCfg::set_max_grids_along_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_grids_along_time(value);
  // @@protoc_insertion_point(field_set:planning.ssc.SscMapCfg.max_grids_along_time)
}

// required .planning.ssc.InflateSteps infl_steps = 10;
inline bool SscMapCfg::_internal_has_infl_steps() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || infl_steps_ != nullptr);
  return value;
}
inline bool SscMapCfg::has_infl_steps() const {
  return _internal_has_infl_steps();
}
inline void SscMapCfg::clear_infl_steps() {
  if (infl_steps_ != nullptr) infl_steps_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::planning::ssc::InflateSteps& SscMapCfg::_internal_infl_steps() const {
  const ::planning::ssc::InflateSteps* p = infl_steps_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::ssc::InflateSteps&>(
      ::planning::ssc::_InflateSteps_default_instance_);
}
inline const ::planning::ssc::InflateSteps& SscMapCfg::infl_steps() const {
  // @@protoc_insertion_point(field_get:planning.ssc.SscMapCfg.infl_steps)
  return _internal_infl_steps();
}
inline void SscMapCfg::unsafe_arena_set_allocated_infl_steps(
    ::planning::ssc::InflateSteps* infl_steps) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(infl_steps_);
  }
  infl_steps_ = infl_steps;
  if (infl_steps) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.ssc.SscMapCfg.infl_steps)
}
inline ::planning::ssc::InflateSteps* SscMapCfg::release_infl_steps() {
  _has_bits_[0] &= ~0x00000002u;
  ::planning::ssc::InflateSteps* temp = infl_steps_;
  infl_steps_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::ssc::InflateSteps* SscMapCfg::unsafe_arena_release_infl_steps() {
  // @@protoc_insertion_point(field_release:planning.ssc.SscMapCfg.infl_steps)
  _has_bits_[0] &= ~0x00000002u;
  ::planning::ssc::InflateSteps* temp = infl_steps_;
  infl_steps_ = nullptr;
  return temp;
}
inline ::planning::ssc::InflateSteps* SscMapCfg::_internal_mutable_infl_steps() {
  _has_bits_[0] |= 0x00000002u;
  if (infl_steps_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::ssc::InflateSteps>(GetArena());
    infl_steps_ = p;
  }
  return infl_steps_;
}
inline ::planning::ssc::InflateSteps* SscMapCfg::mutable_infl_steps() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.SscMapCfg.infl_steps)
  return _internal_mutable_infl_steps();
}
inline void SscMapCfg::set_allocated_infl_steps(::planning::ssc::InflateSteps* infl_steps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete infl_steps_;
  }
  if (infl_steps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(infl_steps);
    if (message_arena != submessage_arena) {
      infl_steps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, infl_steps, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  infl_steps_ = infl_steps;
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.SscMapCfg.infl_steps)
}

// -------------------------------------------------------------------

// Config

// required string name = 1;
inline bool Config::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Config::has_name() const {
  return _internal_has_name();
}
inline void Config::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Config::name() const {
  // @@protoc_insertion_point(field_get:planning.ssc.Config.name)
  return _internal_name();
}
inline void Config::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:planning.ssc.Config.name)
}
inline std::string* Config::mutable_name() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.Config.name)
  return _internal_mutable_name();
}
inline const std::string& Config::_internal_name() const {
  return name_.Get();
}
inline void Config::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.ssc.Config.name)
}
inline void Config::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.ssc.Config.name)
}
inline void Config::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.ssc.Config.name)
}
inline std::string* Config::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_name() {
  // @@protoc_insertion_point(field_release:planning.ssc.Config.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.Config.name)
}

// required string version = 2;
inline bool Config::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Config::has_version() const {
  return _internal_has_version();
}
inline void Config::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Config::version() const {
  // @@protoc_insertion_point(field_get:planning.ssc.Config.version)
  return _internal_version();
}
inline void Config::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:planning.ssc.Config.version)
}
inline std::string* Config::mutable_version() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.Config.version)
  return _internal_mutable_version();
}
inline const std::string& Config::_internal_version() const {
  return version_.Get();
}
inline void Config::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.ssc.Config.version)
}
inline void Config::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.ssc.Config.version)
}
inline void Config::set_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.ssc.Config.version)
}
inline std::string* Config::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_version() {
  // @@protoc_insertion_point(field_release:planning.ssc.Config.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.Config.version)
}

// required string status = 3;
inline bool Config::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Config::has_status() const {
  return _internal_has_status();
}
inline void Config::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Config::status() const {
  // @@protoc_insertion_point(field_get:planning.ssc.Config.status)
  return _internal_status();
}
inline void Config::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:planning.ssc.Config.status)
}
inline std::string* Config::mutable_status() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.Config.status)
  return _internal_mutable_status();
}
inline const std::string& Config::_internal_status() const {
  return status_.Get();
}
inline void Config::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Config::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:planning.ssc.Config.status)
}
inline void Config::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:planning.ssc.Config.status)
}
inline void Config::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:planning.ssc.Config.status)
}
inline std::string* Config::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Config::release_status() {
  // @@protoc_insertion_point(field_release:planning.ssc.Config.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Config::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.Config.status)
}

// required .planning.ssc.SscPlannerCfg planner_cfg = 4;
inline bool Config::_internal_has_planner_cfg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || planner_cfg_ != nullptr);
  return value;
}
inline bool Config::has_planner_cfg() const {
  return _internal_has_planner_cfg();
}
inline void Config::clear_planner_cfg() {
  if (planner_cfg_ != nullptr) planner_cfg_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::planning::ssc::SscPlannerCfg& Config::_internal_planner_cfg() const {
  const ::planning::ssc::SscPlannerCfg* p = planner_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::ssc::SscPlannerCfg&>(
      ::planning::ssc::_SscPlannerCfg_default_instance_);
}
inline const ::planning::ssc::SscPlannerCfg& Config::planner_cfg() const {
  // @@protoc_insertion_point(field_get:planning.ssc.Config.planner_cfg)
  return _internal_planner_cfg();
}
inline void Config::unsafe_arena_set_allocated_planner_cfg(
    ::planning::ssc::SscPlannerCfg* planner_cfg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planner_cfg_);
  }
  planner_cfg_ = planner_cfg;
  if (planner_cfg) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.ssc.Config.planner_cfg)
}
inline ::planning::ssc::SscPlannerCfg* Config::release_planner_cfg() {
  _has_bits_[0] &= ~0x00000008u;
  ::planning::ssc::SscPlannerCfg* temp = planner_cfg_;
  planner_cfg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::ssc::SscPlannerCfg* Config::unsafe_arena_release_planner_cfg() {
  // @@protoc_insertion_point(field_release:planning.ssc.Config.planner_cfg)
  _has_bits_[0] &= ~0x00000008u;
  ::planning::ssc::SscPlannerCfg* temp = planner_cfg_;
  planner_cfg_ = nullptr;
  return temp;
}
inline ::planning::ssc::SscPlannerCfg* Config::_internal_mutable_planner_cfg() {
  _has_bits_[0] |= 0x00000008u;
  if (planner_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::ssc::SscPlannerCfg>(GetArena());
    planner_cfg_ = p;
  }
  return planner_cfg_;
}
inline ::planning::ssc::SscPlannerCfg* Config::mutable_planner_cfg() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.Config.planner_cfg)
  return _internal_mutable_planner_cfg();
}
inline void Config::set_allocated_planner_cfg(::planning::ssc::SscPlannerCfg* planner_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete planner_cfg_;
  }
  if (planner_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(planner_cfg);
    if (message_arena != submessage_arena) {
      planner_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planner_cfg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  planner_cfg_ = planner_cfg;
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.Config.planner_cfg)
}

// required .planning.ssc.SscMapCfg map_cfg = 5;
inline bool Config::_internal_has_map_cfg() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || map_cfg_ != nullptr);
  return value;
}
inline bool Config::has_map_cfg() const {
  return _internal_has_map_cfg();
}
inline void Config::clear_map_cfg() {
  if (map_cfg_ != nullptr) map_cfg_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::planning::ssc::SscMapCfg& Config::_internal_map_cfg() const {
  const ::planning::ssc::SscMapCfg* p = map_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::planning::ssc::SscMapCfg&>(
      ::planning::ssc::_SscMapCfg_default_instance_);
}
inline const ::planning::ssc::SscMapCfg& Config::map_cfg() const {
  // @@protoc_insertion_point(field_get:planning.ssc.Config.map_cfg)
  return _internal_map_cfg();
}
inline void Config::unsafe_arena_set_allocated_map_cfg(
    ::planning::ssc::SscMapCfg* map_cfg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_cfg_);
  }
  map_cfg_ = map_cfg;
  if (map_cfg) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:planning.ssc.Config.map_cfg)
}
inline ::planning::ssc::SscMapCfg* Config::release_map_cfg() {
  _has_bits_[0] &= ~0x00000010u;
  ::planning::ssc::SscMapCfg* temp = map_cfg_;
  map_cfg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::planning::ssc::SscMapCfg* Config::unsafe_arena_release_map_cfg() {
  // @@protoc_insertion_point(field_release:planning.ssc.Config.map_cfg)
  _has_bits_[0] &= ~0x00000010u;
  ::planning::ssc::SscMapCfg* temp = map_cfg_;
  map_cfg_ = nullptr;
  return temp;
}
inline ::planning::ssc::SscMapCfg* Config::_internal_mutable_map_cfg() {
  _has_bits_[0] |= 0x00000010u;
  if (map_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::planning::ssc::SscMapCfg>(GetArena());
    map_cfg_ = p;
  }
  return map_cfg_;
}
inline ::planning::ssc::SscMapCfg* Config::mutable_map_cfg() {
  // @@protoc_insertion_point(field_mutable:planning.ssc.Config.map_cfg)
  return _internal_mutable_map_cfg();
}
inline void Config::set_allocated_map_cfg(::planning::ssc::SscMapCfg* map_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete map_cfg_;
  }
  if (map_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(map_cfg);
    if (message_arena != submessage_arena) {
      map_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map_cfg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  map_cfg_ = map_cfg;
  // @@protoc_insertion_point(field_set_allocated:planning.ssc.Config.map_cfg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ssc
}  // namespace planning

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ssc_5fconfig_2eproto
